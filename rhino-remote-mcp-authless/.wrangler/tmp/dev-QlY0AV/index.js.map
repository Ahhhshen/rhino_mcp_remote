{
  "version": 3,
  "sources": ["../bundle-N4jBZJ/strip-cf-connecting-ip-header.js", "../../../node_modules/unenv/dist/runtime/_internal/utils.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs", "../../../node_modules/unenv/dist/runtime/node/perf_hooks.mjs", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs", "../../../node_modules/unenv/dist/runtime/mock/noop.mjs", "../../../node_modules/unenv/dist/runtime/node/console.mjs", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs", "../../../node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console", "../../../node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs", "../../../node_modules/unenv/dist/runtime/node/tty.mjs", "../../../node_modules/unenv/dist/runtime/node/internal/process/process.mjs", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs", "../../../node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process", "wrangler-modules-watch:wrangler:modules-watch", "../../../node_modules/wrangler/templates/modules-watch-stub.js", "../../../node_modules/ajv/lib/compile/codegen/code.ts", "../../../node_modules/ajv/lib/compile/codegen/scope.ts", "../../../node_modules/ajv/lib/compile/codegen/index.ts", "../../../node_modules/ajv/lib/compile/util.ts", "../../../node_modules/ajv/lib/compile/names.ts", "../../../node_modules/ajv/lib/compile/errors.ts", "../../../node_modules/ajv/lib/compile/validate/boolSchema.ts", "../../../node_modules/ajv/lib/compile/rules.ts", "../../../node_modules/ajv/lib/compile/validate/applicability.ts", "../../../node_modules/ajv/lib/compile/validate/dataType.ts", "../../../node_modules/ajv/lib/compile/validate/defaults.ts", "../../../node_modules/ajv/lib/vocabularies/code.ts", "../../../node_modules/ajv/lib/compile/validate/keyword.ts", "../../../node_modules/ajv/lib/compile/validate/subschema.ts", "../../../node_modules/fast-deep-equal/index.js", "../../../node_modules/json-schema-traverse/index.js", "../../../node_modules/ajv/lib/compile/resolve.ts", "../../../node_modules/ajv/lib/compile/validate/index.ts", "../../../node_modules/ajv/lib/runtime/validation_error.ts", "../../../node_modules/ajv/lib/compile/ref_error.ts", "../../../node_modules/ajv/lib/compile/index.ts", "../../../node_modules/ajv/dist/refs/data.json", "../../../node_modules/fast-uri/lib/scopedChars.js", "../../../node_modules/fast-uri/lib/utils.js", "../../../node_modules/fast-uri/lib/schemes.js", "../../../node_modules/fast-uri/index.js", "../../../node_modules/ajv/lib/runtime/uri.ts", "../../../node_modules/ajv/lib/core.ts", "../../../node_modules/ajv/lib/vocabularies/core/id.ts", "../../../node_modules/ajv/lib/vocabularies/core/ref.ts", "../../../node_modules/ajv/lib/vocabularies/core/index.ts", "../../../node_modules/ajv/lib/vocabularies/validation/limitNumber.ts", "../../../node_modules/ajv/lib/vocabularies/validation/multipleOf.ts", "../../../node_modules/ajv/lib/runtime/ucs2length.ts", "../../../node_modules/ajv/lib/vocabularies/validation/limitLength.ts", "../../../node_modules/ajv/lib/vocabularies/validation/pattern.ts", "../../../node_modules/ajv/lib/vocabularies/validation/limitProperties.ts", "../../../node_modules/ajv/lib/vocabularies/validation/required.ts", "../../../node_modules/ajv/lib/vocabularies/validation/limitItems.ts", "../../../node_modules/ajv/lib/runtime/equal.ts", "../../../node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts", "../../../node_modules/ajv/lib/vocabularies/validation/const.ts", "../../../node_modules/ajv/lib/vocabularies/validation/enum.ts", "../../../node_modules/ajv/lib/vocabularies/validation/index.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/items.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/items2020.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/contains.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/dependencies.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/properties.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/not.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/anyOf.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/oneOf.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/allOf.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/if.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/thenElse.ts", "../../../node_modules/ajv/lib/vocabularies/applicator/index.ts", "../../../node_modules/ajv/lib/vocabularies/format/format.ts", "../../../node_modules/ajv/lib/vocabularies/format/index.ts", "../../../node_modules/ajv/lib/vocabularies/metadata.ts", "../../../node_modules/ajv/lib/vocabularies/draft7.ts", "../../../node_modules/ajv/lib/vocabularies/discriminator/types.ts", "../../../node_modules/ajv/lib/vocabularies/discriminator/index.ts", "../../../node_modules/ajv/dist/refs/json-schema-draft-07.json", "../../../node_modules/ajv/lib/ajv.ts", "../../../node_modules/secure-json-parse/index.js", "../bundle-N4jBZJ/middleware-loader.entry.ts", "../bundle-N4jBZJ/middleware-insertion-facade.js", "../../../src/index.ts", "../../../node_modules/agents/src/mcp/do-oauth-client-provider.ts", "../../../node_modules/agents/dist/chunk-HMLY7DHA.js", "../../../node_modules/partysocket/dist/index.mjs", "../../../node_modules/partysocket/src/ws.ts", "../../../node_modules/agents/src/client.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/client/sse.ts", "../../../node_modules/eventsource-parser/src/errors.ts", "../../../node_modules/eventsource-parser/src/parse.ts", "../../../node_modules/eventsource/src/errors.ts", "../../../node_modules/eventsource/src/EventSource.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/types.ts", "../../../node_modules/zod/lib/index.mjs", "../../../node_modules/@modelcontextprotocol/sdk/src/client/auth.ts", "../../../node_modules/pkce-challenge/dist/index.browser.js", "../../../node_modules/@modelcontextprotocol/sdk/src/shared/auth.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/client/index.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/shared/protocol.ts", "../../../node_modules/@ai-sdk/provider/src/errors/ai-sdk-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/api-call-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/empty-response-body-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/get-error-message.ts", "../../../node_modules/@ai-sdk/provider/src/errors/invalid-argument-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/invalid-prompt-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/invalid-response-data-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/json-parse-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/load-api-key-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/load-setting-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/no-content-generated-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/no-such-model-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/too-many-embedding-values-for-call-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/type-validation-error.ts", "../../../node_modules/@ai-sdk/provider/src/errors/unsupported-functionality-error.ts", "../../../node_modules/@ai-sdk/provider/src/json-value/is-json.ts", "../../../node_modules/@ai-sdk/provider-utils/node_modules/nanoid/non-secure/index.js", "../../../node_modules/@ai-sdk/provider-utils/src/combine-headers.ts", "../../../node_modules/@ai-sdk/provider-utils/src/convert-async-iterator-to-readable-stream.ts", "../../../node_modules/@ai-sdk/provider-utils/src/delay.ts", "../../../node_modules/@ai-sdk/provider-utils/src/event-source-parser-stream.ts", "../../../node_modules/@ai-sdk/provider-utils/src/extract-response-headers.ts", "../../../node_modules/@ai-sdk/provider-utils/src/generate-id.ts", "../../../node_modules/@ai-sdk/provider-utils/src/get-error-message.ts", "../../../node_modules/@ai-sdk/provider-utils/src/get-from-api.ts", "../../../node_modules/@ai-sdk/provider-utils/src/remove-undefined-entries.ts", "../../../node_modules/@ai-sdk/provider-utils/src/is-abort-error.ts", "../../../node_modules/@ai-sdk/provider-utils/src/load-api-key.ts", "../../../node_modules/@ai-sdk/provider-utils/src/load-optional-setting.ts", "../../../node_modules/@ai-sdk/provider-utils/src/load-setting.ts", "../../../node_modules/@ai-sdk/provider-utils/src/parse-json.ts", "../../../node_modules/@ai-sdk/provider-utils/src/validate-types.ts", "../../../node_modules/@ai-sdk/provider-utils/src/validator.ts", "../../../node_modules/@ai-sdk/provider-utils/src/parse-provider-options.ts", "../../../node_modules/@ai-sdk/provider-utils/src/post-to-api.ts", "../../../node_modules/@ai-sdk/provider-utils/src/resolve.ts", "../../../node_modules/@ai-sdk/provider-utils/src/response-handler.ts", "../../../node_modules/@ai-sdk/provider-utils/src/uint8-utils.ts", "../../../node_modules/@ai-sdk/provider-utils/src/without-trailing-slash.ts", "../../../node_modules/zod-to-json-schema/dist/esm/index.js", "../../../node_modules/zod-to-json-schema/dist/esm/Options.js", "../../../node_modules/zod-to-json-schema/dist/esm/Refs.js", "../../../node_modules/zod-to-json-schema/dist/esm/errorMessages.js", "../../../node_modules/zod-to-json-schema/dist/esm/parseDef.js", "../../../node_modules/zod-to-json-schema/dist/esm/selectParser.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/any.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/array.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/branded.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/catch.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/date.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/default.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/effects.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/enum.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/literal.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/map.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/record.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/string.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/never.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/null.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/union.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/number.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/object.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/optional.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/promise.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/set.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js", "../../../node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js", "../../../node_modules/zod-to-json-schema/dist/esm/parseTypes.js", "../../../node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js", "../../../node_modules/@ai-sdk/ui-utils/src/index.ts", "../../../node_modules/@ai-sdk/ui-utils/src/assistant-stream-parts.ts", "../../../node_modules/@ai-sdk/ui-utils/src/process-chat-response.ts", "../../../node_modules/@ai-sdk/ui-utils/src/duplicated/usage.ts", "../../../node_modules/@ai-sdk/ui-utils/src/parse-partial-json.ts", "../../../node_modules/@ai-sdk/ui-utils/src/fix-json.ts", "../../../node_modules/@ai-sdk/ui-utils/src/data-stream-parts.ts", "../../../node_modules/@ai-sdk/ui-utils/src/process-data-stream.ts", "../../../node_modules/@ai-sdk/ui-utils/src/process-chat-text-response.ts", "../../../node_modules/@ai-sdk/ui-utils/src/process-text-stream.ts", "../../../node_modules/@ai-sdk/ui-utils/src/call-chat-api.ts", "../../../node_modules/@ai-sdk/ui-utils/src/call-completion-api.ts", "../../../node_modules/@ai-sdk/ui-utils/src/data-url.ts", "../../../node_modules/@ai-sdk/ui-utils/src/extract-max-tool-invocation-step.ts", "../../../node_modules/@ai-sdk/ui-utils/src/get-message-parts.ts", "../../../node_modules/@ai-sdk/ui-utils/src/fill-message-parts.ts", "../../../node_modules/@ai-sdk/ui-utils/src/is-deep-equal-data.ts", "../../../node_modules/@ai-sdk/ui-utils/src/prepare-attachments-for-request.ts", "../../../node_modules/@ai-sdk/ui-utils/src/process-assistant-stream.ts", "../../../node_modules/@ai-sdk/ui-utils/src/schema.ts", "../../../node_modules/@ai-sdk/ui-utils/src/zod-schema.ts", "../../../node_modules/@ai-sdk/ui-utils/src/should-resubmit-messages.ts", "../../../node_modules/@ai-sdk/ui-utils/src/update-tool-call-result.ts", "../../../node_modules/ai/core/index.ts", "../../../node_modules/ai/core/data-stream/create-data-stream.ts", "../../../node_modules/ai/core/util/prepare-response-headers.ts", "../../../node_modules/ai/core/data-stream/create-data-stream-response.ts", "../../../node_modules/ai/core/util/prepare-outgoing-http-headers.ts", "../../../node_modules/ai/core/util/write-to-server-response.ts", "../../../node_modules/ai/core/data-stream/pipe-data-stream-to-response.ts", "../../../node_modules/ai/errors/invalid-argument-error.ts", "../../../node_modules/ai/util/retry-with-exponential-backoff.ts", "../../../node_modules/ai/util/retry-error.ts", "../../../node_modules/ai/core/prompt/prepare-retries.ts", "../../../node_modules/ai/core/telemetry/assemble-operation-name.ts", "../../../node_modules/ai/core/telemetry/get-base-telemetry-attributes.ts", "../../../node_modules/ai/core/telemetry/get-tracer.ts", "../../../node_modules/ai/core/telemetry/noop-tracer.ts", "../../../node_modules/ai/core/telemetry/record-span.ts", "../../../node_modules/ai/core/telemetry/select-telemetry-attributes.ts", "../../../node_modules/ai/core/embed/embed.ts", "../../../node_modules/ai/core/util/split-array.ts", "../../../node_modules/ai/core/embed/embed-many.ts", "../../../node_modules/ai/errors/no-image-generated-error.ts", "../../../node_modules/ai/core/generate-text/generated-file.ts", "../../../node_modules/ai/core/util/detect-mimetype.ts", "../../../node_modules/ai/core/generate-image/generate-image.ts", "../../../node_modules/ai/core/generate-object/generate-object.ts", "../../../node_modules/ai/errors/no-object-generated-error.ts", "../../../node_modules/ai/util/download-error.ts", "../../../node_modules/ai/util/download.ts", "../../../node_modules/ai/core/prompt/data-content.ts", "../../../node_modules/ai/core/prompt/invalid-data-content-error.ts", "../../../node_modules/ai/core/prompt/invalid-message-role-error.ts", "../../../node_modules/ai/core/prompt/split-data-url.ts", "../../../node_modules/ai/core/prompt/convert-to-language-model-prompt.ts", "../../../node_modules/ai/core/prompt/prepare-call-settings.ts", "../../../node_modules/ai/core/prompt/standardize-prompt.ts", "../../../node_modules/ai/core/prompt/attachments-to-parts.ts", "../../../node_modules/ai/core/prompt/message-conversion-error.ts", "../../../node_modules/ai/core/prompt/convert-to-core-messages.ts", "../../../node_modules/ai/core/prompt/message.ts", "../../../node_modules/ai/core/types/provider-metadata.ts", "../../../node_modules/ai/core/types/json-value.ts", "../../../node_modules/ai/core/prompt/content-part.ts", "../../../node_modules/ai/core/prompt/tool-result-content.ts", "../../../node_modules/ai/core/types/usage.ts", "../../../node_modules/ai/core/generate-object/inject-json-instruction.ts", "../../../node_modules/ai/core/generate-object/output-strategy.ts", "../../../node_modules/ai/core/util/async-iterable-stream.ts", "../../../node_modules/ai/core/generate-object/validate-object-generation-input.ts", "../../../node_modules/ai/core/prompt/stringify-for-telemetry.ts", "../../../node_modules/ai/core/generate-object/stream-object.ts", "../../../node_modules/ai/util/delayed-promise.ts", "../../../node_modules/ai/util/create-resolvable-promise.ts", "../../../node_modules/ai/core/util/create-stitchable-stream.ts", "../../../node_modules/ai/core/util/now.ts", "../../../node_modules/ai/core/generate-text/generate-text.ts", "../../../node_modules/ai/errors/no-output-specified-error.ts", "../../../node_modules/ai/errors/tool-execution-error.ts", "../../../node_modules/ai/core/prompt/prepare-tools-and-tool-choice.ts", "../../../node_modules/ai/core/util/is-non-empty-object.ts", "../../../node_modules/ai/core/util/split-on-last-whitespace.ts", "../../../node_modules/ai/core/util/remove-text-after-last-whitespace.ts", "../../../node_modules/ai/core/generate-text/parse-tool-call.ts", "../../../node_modules/ai/errors/invalid-tool-arguments-error.ts", "../../../node_modules/ai/errors/no-such-tool-error.ts", "../../../node_modules/ai/errors/tool-call-repair-error.ts", "../../../node_modules/ai/core/generate-text/reasoning-detail.ts", "../../../node_modules/ai/core/generate-text/to-response-messages.ts", "../../../node_modules/ai/core/generate-text/output.ts", "../../../node_modules/ai/errors/index.ts", "../../../node_modules/ai/errors/invalid-stream-part-error.ts", "../../../node_modules/ai/errors/mcp-client-error.ts", "../../../node_modules/ai/core/generate-text/smooth-stream.ts", "../../../node_modules/ai/core/generate-text/stream-text.ts", "../../../node_modules/ai/util/as-array.ts", "../../../node_modules/ai/util/consume-stream.ts", "../../../node_modules/ai/core/util/merge-streams.ts", "../../../node_modules/ai/core/generate-text/run-tools-transformation.ts", "../../../node_modules/ai/errors/no-speech-generated-error.ts", "../../../node_modules/ai/core/generate-speech/generated-audio-file.ts", "../../../node_modules/ai/core/generate-speech/generate-speech.ts", "../../../node_modules/ai/errors/no-transcript-generated-error.ts", "../../../node_modules/ai/core/transcribe/transcribe.ts", "../../../node_modules/ai/core/util/merge-objects.ts", "../../../node_modules/ai/core/middleware/default-settings-middleware.ts", "../../../node_modules/ai/core/util/get-potential-start-index.ts", "../../../node_modules/ai/core/middleware/extract-reasoning-middleware.ts", "../../../node_modules/ai/core/middleware/simulate-streaming-middleware.ts", "../../../node_modules/ai/core/middleware/wrap-language-model.ts", "../../../node_modules/ai/core/prompt/append-client-message.ts", "../../../node_modules/ai/core/prompt/append-response-messages.ts", "../../../node_modules/ai/core/registry/custom-provider.ts", "../../../node_modules/ai/core/registry/no-such-provider-error.ts", "../../../node_modules/ai/core/registry/provider-registry.ts", "../../../node_modules/ai/core/tool/mcp/mcp-client.ts", "../../../node_modules/ai/core/tool/tool.ts", "../../../node_modules/ai/core/tool/mcp/mcp-sse-transport.ts", "../../../node_modules/ai/core/tool/mcp/json-rpc-message.ts", "../../../node_modules/ai/core/tool/mcp/types.ts", "../../../node_modules/ai/core/tool/mcp/mcp-transport.ts", "../../../node_modules/ai/core/util/cosine-similarity.ts", "../../../node_modules/ai/core/util/simulate-readable-stream.ts", "../../../node_modules/ai/streams/assistant-response.ts", "../../../node_modules/ai/streams/langchain-adapter.ts", "../../../node_modules/ai/streams/stream-callbacks.ts", "../../../node_modules/ai/streams/llamaindex-adapter.ts", "../../../node_modules/ai/streams/stream-data.ts", "../../../node_modules/ai/util/constants.ts", "../../../node_modules/nanoid/index.browser.js", "../../../node_modules/nanoid/url-alphabet/index.js", "../../../node_modules/agents/src/mcp/sse-edge.ts", "../../../node_modules/agents/src/mcp/client-connection.ts", "../../../node_modules/agents/src/mcp/client.ts", "../../../node_modules/partyserver/src/index.ts", "../../../node_modules/partyserver/src/connection.ts", "../../../node_modules/cron-schedule/src/cron-parser.ts", "../../../node_modules/cron-schedule/src/cron.ts", "../../../node_modules/cron-schedule/src/utils.ts", "../../../node_modules/@cloudflare/unenv-preset/dist/runtime/node/async_hooks.mjs", "../../../node_modules/agents/src/index.ts", "../../../node_modules/agents/src/mcp/index.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/server/mcp.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/server/index.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/server/completable.ts", "../../../node_modules/@modelcontextprotocol/sdk/src/shared/uriTemplate.ts", "../../../src/rhino-tools.ts", "../../../src/rhino-script-categories.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../../../node_modules/wrangler/templates/middleware/common.ts"],
  "sourceRoot": "D:\\Github\\rhino_mcp_remote\\rhino-remote-mcp-authless\\.wrangler\\tmp\\dev-QlY0AV",
  "sourcesContent": ["function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/* @__NO_SIDE_EFFECTS__ */\nexport function rawHeaders(headers) {\n\tconst rawHeaders = [];\n\tfor (const key in headers) {\n\t\tif (Array.isArray(headers[key])) {\n\t\t\tfor (const h of headers[key]) {\n\t\t\t\trawHeaders.push(key, h);\n\t\t\t}\n\t\t} else {\n\t\t\trawHeaders.push(key, headers[key]);\n\t\t}\n\t}\n\treturn rawHeaders;\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function mergeFns(...functions) {\n\treturn function(...args) {\n\t\tfor (const fn of functions) {\n\t\t\tfn(...args);\n\t\t}\n\t};\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function createNotImplementedError(name) {\n\treturn new Error(`[unenv] ${name} is not implemented yet!`);\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplemented(name) {\n\tconst fn = () => {\n\t\tthrow createNotImplementedError(name);\n\t};\n\treturn Object.assign(fn, { __unenv__: true });\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplementedAsync(name) {\n\tconst fn = notImplemented(name);\n\tfn.__promisify__ = () => notImplemented(name + \".__promisify__\");\n\tfn.native = fn;\n\treturn fn;\n}\n/* @__NO_SIDE_EFFECTS__ */\nexport function notImplementedClass(name) {\n\treturn class {\n\t\t__unenv__ = true;\n\t\tconstructor() {\n\t\t\tthrow new Error(`[unenv] ${name} is not implemented yet!`);\n\t\t}\n\t};\n}\n", "import { createNotImplementedError } from \"../../../_internal/utils.mjs\";\nconst _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();\nconst _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;\nconst nodeTiming = {\n\tname: \"node\",\n\tentryType: \"node\",\n\tstartTime: 0,\n\tduration: 0,\n\tnodeStart: 0,\n\tv8Start: 0,\n\tbootstrapComplete: 0,\n\tenvironment: 0,\n\tloopStart: 0,\n\tloopExit: 0,\n\tidleTime: 0,\n\tuvMetricsInfo: {\n\t\tloopCount: 0,\n\t\tevents: 0,\n\t\teventsWaiting: 0\n\t},\n\tdetail: undefined,\n\ttoJSON() {\n\t\treturn this;\n\t}\n};\nexport class PerformanceEntry {\n\t__unenv__ = true;\n\tdetail;\n\tentryType = \"event\";\n\tname;\n\tstartTime;\n\tconstructor(name, options) {\n\t\tthis.name = name;\n\t\tthis.startTime = options?.startTime || _performanceNow();\n\t\tthis.detail = options?.detail;\n\t}\n\tget duration() {\n\t\treturn _performanceNow() - this.startTime;\n\t}\n\ttoJSON() {\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tentryType: this.entryType,\n\t\t\tstartTime: this.startTime,\n\t\t\tduration: this.duration,\n\t\t\tdetail: this.detail\n\t\t};\n\t}\n}\nexport const PerformanceMark = class PerformanceMark extends PerformanceEntry {\n\tentryType = \"mark\";\n\tconstructor() {\n\t\tsuper(...arguments);\n\t}\n\tget duration() {\n\t\treturn 0;\n\t}\n};\nexport class PerformanceMeasure extends PerformanceEntry {\n\tentryType = \"measure\";\n}\nexport class PerformanceResourceTiming extends PerformanceEntry {\n\tentryType = \"resource\";\n\tserverTiming = [];\n\tconnectEnd = 0;\n\tconnectStart = 0;\n\tdecodedBodySize = 0;\n\tdomainLookupEnd = 0;\n\tdomainLookupStart = 0;\n\tencodedBodySize = 0;\n\tfetchStart = 0;\n\tinitiatorType = \"\";\n\tname = \"\";\n\tnextHopProtocol = \"\";\n\tredirectEnd = 0;\n\tredirectStart = 0;\n\trequestStart = 0;\n\tresponseEnd = 0;\n\tresponseStart = 0;\n\tsecureConnectionStart = 0;\n\tstartTime = 0;\n\ttransferSize = 0;\n\tworkerStart = 0;\n\tresponseStatus = 0;\n}\nexport class PerformanceObserverEntryList {\n\t__unenv__ = true;\n\tgetEntries() {\n\t\treturn [];\n\t}\n\tgetEntriesByName(_name, _type) {\n\t\treturn [];\n\t}\n\tgetEntriesByType(type) {\n\t\treturn [];\n\t}\n}\nexport class Performance {\n\t__unenv__ = true;\n\ttimeOrigin = _timeOrigin;\n\teventCounts = new Map();\n\t_entries = [];\n\t_resourceTimingBufferSize = 0;\n\tnavigation = undefined;\n\ttiming = undefined;\n\ttimerify(_fn, _options) {\n\t\tthrow createNotImplementedError(\"Performance.timerify\");\n\t}\n\tget nodeTiming() {\n\t\treturn nodeTiming;\n\t}\n\teventLoopUtilization() {\n\t\treturn {};\n\t}\n\tmarkResourceTiming() {\n\t\treturn new PerformanceResourceTiming(\"\");\n\t}\n\tonresourcetimingbufferfull = null;\n\tnow() {\n\t\tif (this.timeOrigin === _timeOrigin) {\n\t\t\treturn _performanceNow();\n\t\t}\n\t\treturn Date.now() - this.timeOrigin;\n\t}\n\tclearMarks(markName) {\n\t\tthis._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== \"mark\");\n\t}\n\tclearMeasures(measureName) {\n\t\tthis._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== \"measure\");\n\t}\n\tclearResourceTimings() {\n\t\tthis._entries = this._entries.filter((e) => e.entryType !== \"resource\" || e.entryType !== \"navigation\");\n\t}\n\tgetEntries() {\n\t\treturn this._entries;\n\t}\n\tgetEntriesByName(name, type) {\n\t\treturn this._entries.filter((e) => e.name === name && (!type || e.entryType === type));\n\t}\n\tgetEntriesByType(type) {\n\t\treturn this._entries.filter((e) => e.entryType === type);\n\t}\n\tmark(name, options) {\n\t\tconst entry = new PerformanceMark(name, options);\n\t\tthis._entries.push(entry);\n\t\treturn entry;\n\t}\n\tmeasure(measureName, startOrMeasureOptions, endMark) {\n\t\tlet start;\n\t\tlet end;\n\t\tif (typeof startOrMeasureOptions === \"string\") {\n\t\t\tstart = this.getEntriesByName(startOrMeasureOptions, \"mark\")[0]?.startTime;\n\t\t\tend = this.getEntriesByName(endMark, \"mark\")[0]?.startTime;\n\t\t} else {\n\t\t\tstart = Number.parseFloat(startOrMeasureOptions?.start) || this.now();\n\t\t\tend = Number.parseFloat(startOrMeasureOptions?.end) || this.now();\n\t\t}\n\t\tconst entry = new PerformanceMeasure(measureName, {\n\t\t\tstartTime: start,\n\t\t\tdetail: {\n\t\t\t\tstart,\n\t\t\t\tend\n\t\t\t}\n\t\t});\n\t\tthis._entries.push(entry);\n\t\treturn entry;\n\t}\n\tsetResourceTimingBufferSize(maxSize) {\n\t\tthis._resourceTimingBufferSize = maxSize;\n\t}\n\taddEventListener(type, listener, options) {\n\t\tthrow createNotImplementedError(\"Performance.addEventListener\");\n\t}\n\tremoveEventListener(type, listener, options) {\n\t\tthrow createNotImplementedError(\"Performance.removeEventListener\");\n\t}\n\tdispatchEvent(event) {\n\t\tthrow createNotImplementedError(\"Performance.dispatchEvent\");\n\t}\n\ttoJSON() {\n\t\treturn this;\n\t}\n}\nexport class PerformanceObserver {\n\t__unenv__ = true;\n\tstatic supportedEntryTypes = [];\n\t_callback = null;\n\tconstructor(callback) {\n\t\tthis._callback = callback;\n\t}\n\ttakeRecords() {\n\t\treturn [];\n\t}\n\tdisconnect() {\n\t\tthrow createNotImplementedError(\"PerformanceObserver.disconnect\");\n\t}\n\tobserve(options) {\n\t\tthrow createNotImplementedError(\"PerformanceObserver.observe\");\n\t}\n\tbind(fn) {\n\t\treturn fn;\n\t}\n\trunInAsyncScope(fn, thisArg, ...args) {\n\t\treturn fn.call(thisArg, ...args);\n\t}\n\tasyncId() {\n\t\treturn 0;\n\t}\n\ttriggerAsyncId() {\n\t\treturn 0;\n\t}\n\temitDestroy() {\n\t\treturn this;\n\t}\n}\nexport const performance = globalThis.performance && \"addEventListener\" in globalThis.performance ? globalThis.performance : new Performance();\n", "import { IntervalHistogram, RecordableHistogram } from \"./internal/perf_hooks/histogram.mjs\";\nimport { performance, Performance, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceObserverEntryList, PerformanceObserver, PerformanceResourceTiming } from \"./internal/perf_hooks/performance.mjs\";\nexport * from \"./internal/perf_hooks/performance.mjs\";\nimport { NODE_PERFORMANCE_GC_MAJOR, NODE_PERFORMANCE_GC_MINOR, NODE_PERFORMANCE_GC_INCREMENTAL, NODE_PERFORMANCE_GC_WEAKCB, NODE_PERFORMANCE_GC_FLAGS_NO, NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED, NODE_PERFORMANCE_GC_FLAGS_FORCED, NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING, NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE, NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY, NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE, NODE_PERFORMANCE_ENTRY_TYPE_GC, NODE_PERFORMANCE_ENTRY_TYPE_HTTP, NODE_PERFORMANCE_ENTRY_TYPE_HTTP2, NODE_PERFORMANCE_ENTRY_TYPE_NET, NODE_PERFORMANCE_ENTRY_TYPE_DNS, NODE_PERFORMANCE_MILESTONE_TIME_ORIGIN_TIMESTAMP, NODE_PERFORMANCE_MILESTONE_TIME_ORIGIN, NODE_PERFORMANCE_MILESTONE_ENVIRONMENT, NODE_PERFORMANCE_MILESTONE_NODE_START, NODE_PERFORMANCE_MILESTONE_V8_START, NODE_PERFORMANCE_MILESTONE_LOOP_START, NODE_PERFORMANCE_MILESTONE_LOOP_EXIT, NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE } from \"./internal/perf_hooks/constants.mjs\";\nexport const constants = {\n\tNODE_PERFORMANCE_GC_MAJOR,\n\tNODE_PERFORMANCE_GC_MINOR,\n\tNODE_PERFORMANCE_GC_INCREMENTAL,\n\tNODE_PERFORMANCE_GC_WEAKCB,\n\tNODE_PERFORMANCE_GC_FLAGS_NO,\n\tNODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED,\n\tNODE_PERFORMANCE_GC_FLAGS_FORCED,\n\tNODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING,\n\tNODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE,\n\tNODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY,\n\tNODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE,\n\tNODE_PERFORMANCE_ENTRY_TYPE_GC,\n\tNODE_PERFORMANCE_ENTRY_TYPE_HTTP,\n\tNODE_PERFORMANCE_ENTRY_TYPE_HTTP2,\n\tNODE_PERFORMANCE_ENTRY_TYPE_NET,\n\tNODE_PERFORMANCE_ENTRY_TYPE_DNS,\n\tNODE_PERFORMANCE_MILESTONE_TIME_ORIGIN_TIMESTAMP,\n\tNODE_PERFORMANCE_MILESTONE_TIME_ORIGIN,\n\tNODE_PERFORMANCE_MILESTONE_ENVIRONMENT,\n\tNODE_PERFORMANCE_MILESTONE_NODE_START,\n\tNODE_PERFORMANCE_MILESTONE_V8_START,\n\tNODE_PERFORMANCE_MILESTONE_LOOP_START,\n\tNODE_PERFORMANCE_MILESTONE_LOOP_EXIT,\n\tNODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE\n};\nexport const monitorEventLoopDelay = function(_options) {\n\treturn new IntervalHistogram();\n};\nexport const createHistogram = function(_options) {\n\treturn new RecordableHistogram();\n};\nexport default {\n\tPerformance,\n\tPerformanceMark,\n\tPerformanceEntry,\n\tPerformanceMeasure,\n\tPerformanceObserverEntryList,\n\tPerformanceObserver,\n\tPerformanceResourceTiming,\n\tperformance,\n\tconstants,\n\tcreateHistogram,\n\tmonitorEventLoopDelay\n};\n", "import {\n  performance,\n  Performance,\n  PerformanceEntry,\n  PerformanceMark,\n  PerformanceMeasure,\n  PerformanceObserver,\n  PerformanceObserverEntryList,\n  PerformanceResourceTiming\n} from \"node:perf_hooks\";\nglobalThis.performance = performance;\nglobalThis.Performance = Performance;\nglobalThis.PerformanceEntry = PerformanceEntry;\nglobalThis.PerformanceMark = PerformanceMark;\nglobalThis.PerformanceMeasure = PerformanceMeasure;\nglobalThis.PerformanceObserver = PerformanceObserver;\nglobalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;\nglobalThis.PerformanceResourceTiming = PerformanceResourceTiming;\n", "export default Object.assign(() => {}, { __unenv__: true });\n", "import { Writable } from \"node:stream\";\nimport noop from \"../mock/noop.mjs\";\nimport { notImplemented, notImplementedClass } from \"../_internal/utils.mjs\";\nconst _console = globalThis.console;\nexport const _ignoreErrors = true;\nexport const _stderr = new Writable();\nexport const _stdout = new Writable();\nexport const log = _console?.log ?? noop;\nexport const info = _console?.info ?? log;\nexport const trace = _console?.trace ?? info;\nexport const debug = _console?.debug ?? log;\nexport const table = _console?.table ?? log;\nexport const error = _console?.error ?? log;\nexport const warn = _console?.warn ?? error;\nexport const createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented(\"console.createTask\");\nexport const assert = /* @__PURE__ */ notImplemented(\"console.assert\");\nexport const clear = _console?.clear ?? noop;\nexport const count = _console?.count ?? noop;\nexport const countReset = _console?.countReset ?? noop;\nexport const dir = _console?.dir ?? noop;\nexport const dirxml = _console?.dirxml ?? noop;\nexport const group = _console?.group ?? noop;\nexport const groupEnd = _console?.groupEnd ?? noop;\nexport const groupCollapsed = _console?.groupCollapsed ?? noop;\nexport const profile = _console?.profile ?? noop;\nexport const profileEnd = _console?.profileEnd ?? noop;\nexport const time = _console?.time ?? noop;\nexport const timeEnd = _console?.timeEnd ?? noop;\nexport const timeLog = _console?.timeLog ?? noop;\nexport const timeStamp = _console?.timeStamp ?? noop;\nexport const Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass(\"console.Console\");\nexport const _times = /* @__PURE__ */ new Map();\nexport function context() {\n\treturn _console;\n}\nexport const _stdoutErrorHandler = noop;\nexport const _stderrErrorHandler = noop;\nexport default {\n\t_times,\n\t_ignoreErrors,\n\t_stdoutErrorHandler,\n\t_stderrErrorHandler,\n\t_stdout,\n\t_stderr,\n\tassert,\n\tclear,\n\tConsole,\n\tcount,\n\tcountReset,\n\tdebug,\n\tdir,\n\tdirxml,\n\terror,\n\tcontext,\n\tcreateTask,\n\tgroup,\n\tgroupEnd,\n\tgroupCollapsed,\n\tinfo,\n\tlog,\n\tprofile,\n\tprofileEnd,\n\ttable,\n\ttime,\n\ttimeEnd,\n\ttimeLog,\n\ttimeStamp,\n\ttrace,\n\twarn\n};\n", "import {\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times,\n  Console\n} from \"unenv/node/console\";\nexport {\n  Console,\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times\n} from \"unenv/node/console\";\nconst workerdConsole = globalThis[\"console\"];\nexport const {\n  assert,\n  clear,\n  // @ts-expect-error undocumented public API\n  context,\n  count,\n  countReset,\n  // @ts-expect-error undocumented public API\n  createTask,\n  debug,\n  dir,\n  dirxml,\n  error,\n  group,\n  groupCollapsed,\n  groupEnd,\n  info,\n  log,\n  profile,\n  profileEnd,\n  table,\n  time,\n  timeEnd,\n  timeLog,\n  timeStamp,\n  trace,\n  warn\n} = workerdConsole;\nObject.assign(workerdConsole, {\n  Console,\n  _ignoreErrors,\n  _stderr,\n  _stderrErrorHandler,\n  _stdout,\n  _stdoutErrorHandler,\n  _times\n});\nexport default workerdConsole;\n", "import { default as defaultExport } from \"@cloudflare/unenv-preset/node/console\";\nglobalThis.console = defaultExport;", "export const hrtime = /* @__PURE__ */ Object.assign(function hrtime(startTime) {\n\tconst now = Date.now();\n\tconst seconds = Math.trunc(now / 1e3);\n\tconst nanos = now % 1e3 * 1e6;\n\tif (startTime) {\n\t\tlet diffSeconds = seconds - startTime[0];\n\t\tlet diffNanos = nanos - startTime[0];\n\t\tif (diffNanos < 0) {\n\t\t\tdiffSeconds = diffSeconds - 1;\n\t\t\tdiffNanos = 1e9 + diffNanos;\n\t\t}\n\t\treturn [diffSeconds, diffNanos];\n\t}\n\treturn [seconds, nanos];\n}, { bigint: function bigint() {\n\treturn BigInt(Date.now() * 1e6);\n} });\n", "export class WriteStream {\n\tfd;\n\tcolumns = 80;\n\trows = 24;\n\tisTTY = false;\n\tconstructor(fd) {\n\t\tthis.fd = fd;\n\t}\n\tclearLine(dir, callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tclearScreenDown(callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tcursorTo(x, y, callback) {\n\t\tcallback && typeof callback === \"function\" && callback();\n\t\treturn false;\n\t}\n\tmoveCursor(dx, dy, callback) {\n\t\tcallback && callback();\n\t\treturn false;\n\t}\n\tgetColorDepth(env) {\n\t\treturn 1;\n\t}\n\thasColors(count, env) {\n\t\treturn false;\n\t}\n\tgetWindowSize() {\n\t\treturn [this.columns, this.rows];\n\t}\n\twrite(str, encoding, cb) {\n\t\tif (str instanceof Uint8Array) {\n\t\t\tstr = new TextDecoder().decode(str);\n\t\t}\n\t\ttry {\n\t\t\tconsole.log(str);\n\t\t} catch {}\n\t\tcb && typeof cb === \"function\" && cb();\n\t\treturn false;\n\t}\n}\n", "export class ReadStream {\n\tfd;\n\tisRaw = false;\n\tisTTY = false;\n\tconstructor(fd) {\n\t\tthis.fd = fd;\n\t}\n\tsetRawMode(mode) {\n\t\tthis.isRaw = mode;\n\t\treturn this;\n\t}\n}\n", "import { WriteStream } from \"./internal/tty/write-stream.mjs\";\nexport { ReadStream } from \"./internal/tty/read-stream.mjs\";\nexport { WriteStream } from \"./internal/tty/write-stream.mjs\";\nexport const isatty = function() {\n\treturn false;\n};\nexport default {\n\tReadStream: WriteStream,\n\tWriteStream,\n\tisatty\n};\n", "import { EventEmitter } from \"node:events\";\nimport { ReadStream, WriteStream } from \"node:tty\";\nimport { notImplemented, createNotImplementedError } from \"../../../_internal/utils.mjs\";\nexport class Process extends EventEmitter {\n\tenv;\n\thrtime;\n\tnextTick;\n\tconstructor(impl) {\n\t\tsuper();\n\t\tthis.env = impl.env;\n\t\tthis.hrtime = impl.hrtime;\n\t\tthis.nextTick = impl.nextTick;\n\t\tfor (const prop of [...Object.getOwnPropertyNames(Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {\n\t\t\tconst value = this[prop];\n\t\t\tif (typeof value === \"function\") {\n\t\t\t\tthis[prop] = value.bind(this);\n\t\t\t}\n\t\t}\n\t}\n\temitWarning(warning, type, code) {\n\t\tconsole.warn(`${code ? `[${code}] ` : \"\"}${type ? `${type}: ` : \"\"}${warning}`);\n\t}\n\temit(...args) {\n\t\treturn super.emit(...args);\n\t}\n\tlisteners(eventName) {\n\t\treturn super.listeners(eventName);\n\t}\n\t#stdin;\n\t#stdout;\n\t#stderr;\n\tget stdin() {\n\t\treturn this.#stdin ??= new ReadStream(0);\n\t}\n\tget stdout() {\n\t\treturn this.#stdout ??= new WriteStream(1);\n\t}\n\tget stderr() {\n\t\treturn this.#stderr ??= new WriteStream(2);\n\t}\n\t#cwd = \"/\";\n\tchdir(cwd) {\n\t\tthis.#cwd = cwd;\n\t}\n\tcwd() {\n\t\treturn this.#cwd;\n\t}\n\tarch = \"\";\n\tplatform = \"\";\n\targv = [];\n\targv0 = \"\";\n\texecArgv = [];\n\texecPath = \"\";\n\ttitle = \"\";\n\tpid = 200;\n\tppid = 100;\n\tget version() {\n\t\treturn \"\";\n\t}\n\tget versions() {\n\t\treturn {};\n\t}\n\tget allowedNodeEnvironmentFlags() {\n\t\treturn new Set();\n\t}\n\tget sourceMapsEnabled() {\n\t\treturn false;\n\t}\n\tget debugPort() {\n\t\treturn 0;\n\t}\n\tget throwDeprecation() {\n\t\treturn false;\n\t}\n\tget traceDeprecation() {\n\t\treturn false;\n\t}\n\tget features() {\n\t\treturn {};\n\t}\n\tget release() {\n\t\treturn {};\n\t}\n\tget connected() {\n\t\treturn false;\n\t}\n\tget config() {\n\t\treturn {};\n\t}\n\tget moduleLoadList() {\n\t\treturn [];\n\t}\n\tconstrainedMemory() {\n\t\treturn 0;\n\t}\n\tavailableMemory() {\n\t\treturn 0;\n\t}\n\tuptime() {\n\t\treturn 0;\n\t}\n\tresourceUsage() {\n\t\treturn {};\n\t}\n\tref() {}\n\tunref() {}\n\tumask() {\n\t\tthrow createNotImplementedError(\"process.umask\");\n\t}\n\tgetBuiltinModule() {\n\t\treturn undefined;\n\t}\n\tgetActiveResourcesInfo() {\n\t\tthrow createNotImplementedError(\"process.getActiveResourcesInfo\");\n\t}\n\texit() {\n\t\tthrow createNotImplementedError(\"process.exit\");\n\t}\n\treallyExit() {\n\t\tthrow createNotImplementedError(\"process.reallyExit\");\n\t}\n\tkill() {\n\t\tthrow createNotImplementedError(\"process.kill\");\n\t}\n\tabort() {\n\t\tthrow createNotImplementedError(\"process.abort\");\n\t}\n\tdlopen() {\n\t\tthrow createNotImplementedError(\"process.dlopen\");\n\t}\n\tsetSourceMapsEnabled() {\n\t\tthrow createNotImplementedError(\"process.setSourceMapsEnabled\");\n\t}\n\tloadEnvFile() {\n\t\tthrow createNotImplementedError(\"process.loadEnvFile\");\n\t}\n\tdisconnect() {\n\t\tthrow createNotImplementedError(\"process.disconnect\");\n\t}\n\tcpuUsage() {\n\t\tthrow createNotImplementedError(\"process.cpuUsage\");\n\t}\n\tsetUncaughtExceptionCaptureCallback() {\n\t\tthrow createNotImplementedError(\"process.setUncaughtExceptionCaptureCallback\");\n\t}\n\thasUncaughtExceptionCaptureCallback() {\n\t\tthrow createNotImplementedError(\"process.hasUncaughtExceptionCaptureCallback\");\n\t}\n\tinitgroups() {\n\t\tthrow createNotImplementedError(\"process.initgroups\");\n\t}\n\topenStdin() {\n\t\tthrow createNotImplementedError(\"process.openStdin\");\n\t}\n\tassert() {\n\t\tthrow createNotImplementedError(\"process.assert\");\n\t}\n\tbinding() {\n\t\tthrow createNotImplementedError(\"process.binding\");\n\t}\n\tpermission = { has: /* @__PURE__ */ notImplemented(\"process.permission.has\") };\n\treport = {\n\t\tdirectory: \"\",\n\t\tfilename: \"\",\n\t\tsignal: \"SIGUSR2\",\n\t\tcompact: false,\n\t\treportOnFatalError: false,\n\t\treportOnSignal: false,\n\t\treportOnUncaughtException: false,\n\t\tgetReport: /* @__PURE__ */ notImplemented(\"process.report.getReport\"),\n\t\twriteReport: /* @__PURE__ */ notImplemented(\"process.report.writeReport\")\n\t};\n\tfinalization = {\n\t\tregister: /* @__PURE__ */ notImplemented(\"process.finalization.register\"),\n\t\tunregister: /* @__PURE__ */ notImplemented(\"process.finalization.unregister\"),\n\t\tregisterBeforeExit: /* @__PURE__ */ notImplemented(\"process.finalization.registerBeforeExit\")\n\t};\n\tmemoryUsage = Object.assign(() => ({\n\t\tarrayBuffers: 0,\n\t\trss: 0,\n\t\texternal: 0,\n\t\theapTotal: 0,\n\t\theapUsed: 0\n\t}), { rss: () => 0 });\n\tmainModule = undefined;\n\tdomain = undefined;\n\tsend = undefined;\n\texitCode = undefined;\n\tchannel = undefined;\n\tgetegid = undefined;\n\tgeteuid = undefined;\n\tgetgid = undefined;\n\tgetgroups = undefined;\n\tgetuid = undefined;\n\tsetegid = undefined;\n\tseteuid = undefined;\n\tsetgid = undefined;\n\tsetgroups = undefined;\n\tsetuid = undefined;\n\t_events = undefined;\n\t_eventsCount = undefined;\n\t_exiting = undefined;\n\t_maxListeners = undefined;\n\t_debugEnd = undefined;\n\t_debugProcess = undefined;\n\t_fatalException = undefined;\n\t_getActiveHandles = undefined;\n\t_getActiveRequests = undefined;\n\t_kill = undefined;\n\t_preload_modules = undefined;\n\t_rawDebug = undefined;\n\t_startProfilerIdleNotifier = undefined;\n\t_stopProfilerIdleNotifier = undefined;\n\t_tickCallback = undefined;\n\t_disconnect = undefined;\n\t_handleQueue = undefined;\n\t_pendingMessage = undefined;\n\t_channel = undefined;\n\t_send = undefined;\n\t_linkedBinding = undefined;\n}\n", "import { hrtime as UnenvHrTime } from \"unenv/node/internal/process/hrtime\";\nimport { Process as UnenvProcess } from \"unenv/node/internal/process/process\";\nconst globalProcess = globalThis[\"process\"];\nexport const getBuiltinModule = globalProcess.getBuiltinModule;\nexport const { exit, platform, nextTick } = getBuiltinModule(\n  \"node:process\"\n);\nconst unenvProcess = new UnenvProcess({\n  env: globalProcess.env,\n  hrtime: UnenvHrTime,\n  nextTick\n});\nexport const {\n  abort,\n  addListener,\n  allowedNodeEnvironmentFlags,\n  hasUncaughtExceptionCaptureCallback,\n  setUncaughtExceptionCaptureCallback,\n  loadEnvFile,\n  sourceMapsEnabled,\n  arch,\n  argv,\n  argv0,\n  chdir,\n  config,\n  connected,\n  constrainedMemory,\n  availableMemory,\n  cpuUsage,\n  cwd,\n  debugPort,\n  dlopen,\n  disconnect,\n  emit,\n  emitWarning,\n  env,\n  eventNames,\n  execArgv,\n  execPath,\n  finalization,\n  features,\n  getActiveResourcesInfo,\n  getMaxListeners,\n  hrtime,\n  kill,\n  listeners,\n  listenerCount,\n  memoryUsage,\n  on,\n  off,\n  once,\n  pid,\n  ppid,\n  prependListener,\n  prependOnceListener,\n  rawListeners,\n  release,\n  removeAllListeners,\n  removeListener,\n  report,\n  resourceUsage,\n  setMaxListeners,\n  setSourceMapsEnabled,\n  stderr,\n  stdin,\n  stdout,\n  title,\n  throwDeprecation,\n  traceDeprecation,\n  umask,\n  uptime,\n  version,\n  versions,\n  domain,\n  initgroups,\n  moduleLoadList,\n  reallyExit,\n  openStdin,\n  assert,\n  binding,\n  send,\n  exitCode,\n  channel,\n  getegid,\n  geteuid,\n  getgid,\n  getgroups,\n  getuid,\n  setegid,\n  seteuid,\n  setgid,\n  setgroups,\n  setuid,\n  permission,\n  mainModule,\n  _events,\n  _eventsCount,\n  _exiting,\n  _maxListeners,\n  _debugEnd,\n  _debugProcess,\n  _fatalException,\n  _getActiveHandles,\n  _getActiveRequests,\n  _kill,\n  _preload_modules,\n  _rawDebug,\n  _startProfilerIdleNotifier,\n  _stopProfilerIdleNotifier,\n  _tickCallback,\n  _disconnect,\n  _handleQueue,\n  _pendingMessage,\n  _channel,\n  _send,\n  _linkedBinding\n} = unenvProcess;\nconst _process = {\n  abort,\n  addListener,\n  allowedNodeEnvironmentFlags,\n  hasUncaughtExceptionCaptureCallback,\n  setUncaughtExceptionCaptureCallback,\n  loadEnvFile,\n  sourceMapsEnabled,\n  arch,\n  argv,\n  argv0,\n  chdir,\n  config,\n  connected,\n  constrainedMemory,\n  availableMemory,\n  cpuUsage,\n  cwd,\n  debugPort,\n  dlopen,\n  disconnect,\n  emit,\n  emitWarning,\n  env,\n  eventNames,\n  execArgv,\n  execPath,\n  exit,\n  finalization,\n  features,\n  getBuiltinModule,\n  getActiveResourcesInfo,\n  getMaxListeners,\n  hrtime,\n  kill,\n  listeners,\n  listenerCount,\n  memoryUsage,\n  nextTick,\n  on,\n  off,\n  once,\n  pid,\n  platform,\n  ppid,\n  prependListener,\n  prependOnceListener,\n  rawListeners,\n  release,\n  removeAllListeners,\n  removeListener,\n  report,\n  resourceUsage,\n  setMaxListeners,\n  setSourceMapsEnabled,\n  stderr,\n  stdin,\n  stdout,\n  title,\n  throwDeprecation,\n  traceDeprecation,\n  umask,\n  uptime,\n  version,\n  versions,\n  // @ts-expect-error old API\n  domain,\n  initgroups,\n  moduleLoadList,\n  reallyExit,\n  openStdin,\n  assert,\n  binding,\n  send,\n  exitCode,\n  channel,\n  getegid,\n  geteuid,\n  getgid,\n  getgroups,\n  getuid,\n  setegid,\n  seteuid,\n  setgid,\n  setgroups,\n  setuid,\n  permission,\n  mainModule,\n  _events,\n  _eventsCount,\n  _exiting,\n  _maxListeners,\n  _debugEnd,\n  _debugProcess,\n  _fatalException,\n  _getActiveHandles,\n  _getActiveRequests,\n  _kill,\n  _preload_modules,\n  _rawDebug,\n  _startProfilerIdleNotifier,\n  _stopProfilerIdleNotifier,\n  _tickCallback,\n  _disconnect,\n  _handleQueue,\n  _pendingMessage,\n  _channel,\n  _send,\n  _linkedBinding\n};\nexport default _process;\n", "import { default as defaultExport } from \"@cloudflare/unenv-preset/node/process\";\nglobalThis.process = defaultExport;", "", "// `esbuild` doesn't support returning `watch*` options from `onStart()`\n// plugin callbacks. Instead, we define an empty virtual module that is\n// imported by this injected file. Importing the module registers watchers.\nimport \"wrangler:modules-watch\";\n", "// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n", "import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n", "import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private rhs?: SafeExpr\n  ) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(\n    readonly lhs: Code,\n    public rhs: SafeExpr,\n    private readonly sideEffects?: boolean\n  ) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(\n    lhs: Code,\n    private readonly op: Code,\n    rhs: SafeExpr,\n    sideEffects?: boolean\n  ) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(\n    private condition: Code | boolean,\n    nodes?: ChildNode[]\n  ) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(\n    public name: Name,\n    public args: Code,\n    public async?: boolean\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n", "import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n", "import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n", "import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n", "import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n", "import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = (typeof _jsonTypes)[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n", "import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n", "import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n", "import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n", "import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n", "import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n", "import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n", "import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponent} from \"fast-uri\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponent): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let innerBaseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") innerBaseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = innerBaseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n", "import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n", "import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n", "import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n", "import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport {URIComponent} from \"fast-uri\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URIComponent,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n", "{\n  \"$id\": \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n  \"description\": \"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\n  \"type\": \"object\",\n  \"required\": [\"$data\"],\n  \"properties\": {\n    \"$data\": {\n      \"type\": \"string\",\n      \"anyOf\": [{\"format\": \"relative-json-pointer\"}, {\"format\": \"json-pointer\"}]\n    }\n  },\n  \"additionalProperties\": false\n}\n", "'use strict'\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n", "'use strict'\n\nconst { HEX } = require('./scopedChars')\n\nconst IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)$/u\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(IPV4_REG) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host)\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n", "'use strict'\n\nconst UUID_REG = /^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n", "'use strict'\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require('./lib/utils')\nconst SCHEMES = require('./lib/schemes')\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host)\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n", "import * as uri from \"fast-uri\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n", "export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n", "import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n", "import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n", "// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n", "import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n", "import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n", "import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n", "import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n", "import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n", "import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n", "import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n", "import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          const ref = sch.$ref\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n", "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Core schema meta-schema\",\n  \"definitions\": {\n    \"schemaArray\": {\n      \"type\": \"array\",\n      \"minItems\": 1,\n      \"items\": {\"$ref\": \"#\"}\n    },\n    \"nonNegativeInteger\": {\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"nonNegativeIntegerDefault0\": {\n      \"allOf\": [{\"$ref\": \"#/definitions/nonNegativeInteger\"}, {\"default\": 0}]\n    },\n    \"simpleTypes\": {\n      \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n    },\n    \"stringArray\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"uniqueItems\": true,\n      \"default\": []\n    }\n  },\n  \"type\": [\"object\", \"boolean\"],\n  \"properties\": {\n    \"$id\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$schema\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"$ref\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$comment\": {\n      \"type\": \"string\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"default\": true,\n    \"readOnly\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"examples\": {\n      \"type\": \"array\",\n      \"items\": true\n    },\n    \"multipleOf\": {\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"maximum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMaximum\": {\n      \"type\": \"number\"\n    },\n    \"minimum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMinimum\": {\n      \"type\": \"number\"\n    },\n    \"maxLength\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minLength\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"pattern\": {\n      \"type\": \"string\",\n      \"format\": \"regex\"\n    },\n    \"additionalItems\": {\"$ref\": \"#\"},\n    \"items\": {\n      \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/schemaArray\"}],\n      \"default\": true\n    },\n    \"maxItems\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minItems\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"uniqueItems\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"contains\": {\"$ref\": \"#\"},\n    \"maxProperties\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minProperties\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"required\": {\"$ref\": \"#/definitions/stringArray\"},\n    \"additionalProperties\": {\"$ref\": \"#\"},\n    \"definitions\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"properties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"patternProperties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"propertyNames\": {\"format\": \"regex\"},\n      \"default\": {}\n    },\n    \"dependencies\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/stringArray\"}]\n      }\n    },\n    \"propertyNames\": {\"$ref\": \"#\"},\n    \"const\": true,\n    \"enum\": {\n      \"type\": \"array\",\n      \"items\": true,\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"type\": {\n      \"anyOf\": [\n        {\"$ref\": \"#/definitions/simpleTypes\"},\n        {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/definitions/simpleTypes\"},\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      ]\n    },\n    \"format\": {\"type\": \"string\"},\n    \"contentMediaType\": {\"type\": \"string\"},\n    \"contentEncoding\": {\"type\": \"string\"},\n    \"if\": {\"$ref\": \"#\"},\n    \"then\": {\"$ref\": \"#\"},\n    \"else\": {\"$ref\": \"#\"},\n    \"allOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"anyOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"oneOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"not\": {\"$ref\": \"#\"}\n  },\n  \"default\": true\n}\n", "import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nexport class Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nmodule.exports.Ajv = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n", "'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction _parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    }\n  }\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  const protoAction = (options && options.protoAction) || 'error'\n  const constructorAction = (options && options.constructorAction) || 'error'\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })\n}\n\nfunction filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (safe === true) {\n          return null\n        } else if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(value)\n        }\n      }\n    }\n  }\n  return obj\n}\n\nfunction parse (text, reviver, options) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, options)\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nfunction safeParse (text, reviver) {\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  try {\n    return _parse(text, reviver, { safe: true })\n  } catch (_e) {\n    return null\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n}\n\nmodule.exports = parse\nmodule.exports.default = parse\nmodule.exports.parse = parse\nmodule.exports.safeParse = safeParse\nmodule.exports.scan = filter\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"D:\\\\Github\\\\rhino_mcp_remote\\\\rhino-remote-mcp-authless\\\\.wrangler\\\\tmp\\\\bundle-N4jBZJ\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"D:\\\\Github\\\\rhino_mcp_remote\\\\rhino-remote-mcp-authless\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"D:\\\\Github\\\\rhino_mcp_remote\\\\rhino-remote-mcp-authless\\\\.wrangler\\\\tmp\\\\bundle-N4jBZJ\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"D:\\\\Github\\\\rhino_mcp_remote\\\\rhino-remote-mcp-authless\\\\.wrangler\\\\tmp\\\\bundle-N4jBZJ\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"D:\\\\Github\\\\rhino_mcp_remote\\\\rhino-remote-mcp-authless\\\\src\\\\index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"D:\\\\Github\\\\rhino_mcp_remote\\\\rhino-remote-mcp-authless\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"D:\\\\Github\\\\rhino_mcp_remote\\\\rhino-remote-mcp-authless\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"D:\\\\Github\\\\rhino_mcp_remote\\\\rhino-remote-mcp-authless\\\\src\\\\index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "import { McpAgent } from \"agents/mcp\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { RhinoTools } from \"./rhino-tools\";\n\n// Export the Env interface\nexport interface Env {\n  RHINO_WS: DurableObjectNamespace;\n}\n\n// 1. Define MCP Agent\nexport class RhinoMCP extends McpAgent {\n  server = new McpServer({\n    name: \"Rhino MCP\",\n    version: \"1.0.0\",\n  });\n\n  async init() {\n    new RhinoTools(this.server);\n  }\n}\n\n// --- WebSocket <-> Rhino tool integration ---\nexport class RhinoWebSocket {\n  private state: DurableObjectState;\n  private rhinoSocket: WebSocket | null = null;\n  private requestId = 0;\n  private pending: Record<number, (resp: any) => void> = {};\n\n  constructor(state: DurableObjectState) {\n    this.state = state;\n  }\n\n  async fetch(request: Request) {\n    const url = new URL(request.url);\n\n    // WebSocket \u5347\u7EA7\n    if (request.headers.get(\"upgrade\") === \"websocket\") {\n      const { 0: client, 1: server } = new WebSocketPair();\n      server.accept();\n      this.rhinoSocket = server;\n\n      if (server.readyState !== WebSocket.OPEN) {\n        return new Response(\"WebSocket connection failed\", { status: 500 });\n      }\n\n      server.addEventListener(\"message\", async (event) => {\n        try {\n          const data = event.data;\n          const message =\n            typeof data === \"string\" ? data : new TextDecoder().decode(data);\n          console.log(\"Received message:\", message);\n\n          const msg = JSON.parse(message);\n          if (msg.id && this.pending[msg.id]) {\n            this.pending[msg.id](msg);\n            delete this.pending[msg.id];\n          } else {\n            console.log(\"Unknown message received:\", msg);\n            server.send(\n              JSON.stringify({\n                status: \"error\",\n                message: \"Unknown or unsolicited message\",\n              })\n            );\n          }\n        } catch (e) {\n          console.error(\"Error processing message:\", e);\n          server.send(\n            JSON.stringify({\n              status: \"error\",\n              message: String(e),\n            })\n          );\n        }\n      });\n\n      server.addEventListener(\"close\", () => {\n        console.log(\"WebSocket connection closed\");\n        this.rhinoSocket = null;\n      });\n\n      server.addEventListener(\"error\", (error) => {\n        console.error(\"WebSocket error:\", error);\n      });\n\n      return new Response(null, {\n        status: 101,\n        webSocket: client,\n        headers: {\n          Upgrade: \"websocket\",\n          Connection: \"Upgrade\",\n        },\n      });\n    }\n\n    // \u5904\u7406 HTTP POST /send-command\n    if (request.method === \"POST\" && url.pathname === \"/send-command\") {\n      const body = (await request.json()) as { type: string; params?: any };\n      const { type, params } = body;\n\n      // \u751F\u6210\u552F\u4E00\u8BF7\u6C42ID\n      const id = ++this.requestId;\n\n      // \u901A\u8FC7 WebSocket \u53D1\u7ED9 Rhino\n      if (!this.rhinoSocket || this.rhinoSocket.readyState !== WebSocket.OPEN) {\n        return new Response(\n          JSON.stringify({\n            status: \"error\",\n            message: \"No Rhino WebSocket client connected\",\n          }),\n          { status: 503 }\n        );\n      }\n\n      this.rhinoSocket.send(JSON.stringify({ id, type, params }));\n\n      // \u7B49\u5F85 Rhino \u8FD4\u56DE\n      const result = await new Promise((resolve, reject) => {\n        this.pending[id] = resolve;\n        setTimeout(() => {\n          if (this.pending[id]) {\n            delete this.pending[id];\n            reject(new Error(\"Timeout waiting for Rhino response\"));\n          }\n        }, 30000);\n      });\n\n      return new Response(JSON.stringify(result), { status: 200 });\n    }\n\n    return new Response(\"Not found\", { status: 404 });\n  }\n\n  async sendRhinoCommand(commandType: string, params?: any): Promise<any> {\n    if (!this.rhinoSocket || this.rhinoSocket.readyState !== 1) {\n      throw new Error(\"No Rhino WebSocket client connected\");\n    }\n    return new Promise((resolve, reject) => {\n      const id = ++this.requestId;\n      this.pending[id] = resolve;\n      const payload = { id, type: commandType, params };\n      if (this.rhinoSocket) {\n        this.rhinoSocket.send(JSON.stringify(payload));\n      }\n      setTimeout(() => {\n        if (this.pending[id]) {\n          delete this.pending[id];\n          reject(new Error(\"Timeout waiting for Rhino response\"));\n        }\n      }, 30000);\n    });\n  }\n}\n\n// Export the Durable Object class\nexport { RhinoWebSocket as RhinoWebSocketDO };\n\nexport default {\n  fetch(request: Request, env: Env, ctx: ExecutionContext) {\n    const url = new URL(request.url);\n\n    // 1. WebSocket upgrade support\n    if (request.headers.get(\"upgrade\") === \"websocket\") {\n      const id = env.RHINO_WS.idFromName(\"rhino\");\n      const obj = env.RHINO_WS.get(id);\n      return obj.fetch(request);\n    }\n\n    // 2. Original HTTP/SSE MCP server routes\n    if (url.pathname === \"/sse\" || url.pathname === \"/sse/message\") {\n      // @ts-ignore\n      return RhinoMCP.serveSSE(\"/sse\").fetch(request, env, ctx);\n    }\n\n    if (url.pathname === \"/mcp\") {\n      // @ts-ignore\n      return RhinoMCP.serve(\"/mcp\").fetch(request, env, ctx);\n    }\n\n    return new Response(\"Not found\", { status: 404 });\n  },\n};\n\n// Add sendRhinoCommand function to forward commands through DO\nexport async function sendRhinoCommand(\n  env: Env,\n  commandType: string,\n  params?: any\n): Promise<any> {\n  const id = env.RHINO_WS.idFromName(\"rhino\");\n  const obj = env.RHINO_WS.get(id);\n  const resp = await obj.fetch(\"https://dummy/send-command\", {\n    method: \"POST\",\n    body: JSON.stringify({ type: commandType, params }),\n  });\n  return await resp.json();\n}\n", "import type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\nimport type {\n  OAuthTokens,\n  OAuthClientMetadata,\n  OAuthClientInformation,\n  OAuthClientInformationFull,\n} from \"@modelcontextprotocol/sdk/shared/auth.js\";\n\n// A slight extension to the standard OAuthClientProvider interface because `redirectToAuthorization` doesn't give us the interface we need\n// This allows us to track authentication for a specific server and associated dynamic client registration\nexport interface AgentsOAuthProvider extends OAuthClientProvider {\n  authUrl: string | undefined;\n  clientId: string | undefined;\n  serverId: string | undefined;\n}\n\nexport class DurableObjectOAuthClientProvider implements AgentsOAuthProvider {\n  private authUrl_: string | undefined;\n  private serverId_: string | undefined;\n  private clientId_: string | undefined;\n\n  constructor(\n    public storage: DurableObjectStorage,\n    public clientName: string,\n    public baseRedirectUrl: string\n  ) {}\n\n  get clientMetadata(): OAuthClientMetadata {\n    return {\n      redirect_uris: [this.redirectUrl],\n      token_endpoint_auth_method: \"none\",\n      grant_types: [\"authorization_code\", \"refresh_token\"],\n      response_types: [\"code\"],\n      client_name: this.clientName,\n      client_uri: \"example.com\",\n    };\n  }\n\n  get redirectUrl() {\n    return `${this.baseRedirectUrl}/${this.serverId}`;\n  }\n\n  get clientId() {\n    if (!this.clientId_) {\n      throw new Error(\"Trying to access clientId before it was set\");\n    }\n    return this.clientId_;\n  }\n\n  set clientId(clientId_: string) {\n    this.clientId_ = clientId_;\n  }\n\n  get serverId() {\n    if (!this.serverId_) {\n      throw new Error(\"Trying to access serverId before it was set\");\n    }\n    return this.serverId_;\n  }\n\n  set serverId(serverId_: string) {\n    this.serverId_ = serverId_;\n  }\n\n  keyPrefix(clientId: string) {\n    return `/${this.clientName}/${this.serverId}/${clientId}`;\n  }\n\n  clientInfoKey(clientId: string) {\n    return `${this.keyPrefix(clientId)}/client_info/`;\n  }\n\n  async clientInformation(): Promise<OAuthClientInformation | undefined> {\n    if (!this.clientId_) {\n      return undefined;\n    }\n    return (\n      (await this.storage.get<OAuthClientInformation>(\n        this.clientInfoKey(this.clientId)\n      )) ?? undefined\n    );\n  }\n\n  async saveClientInformation(\n    clientInformation: OAuthClientInformationFull\n  ): Promise<void> {\n    await this.storage.put(\n      this.clientInfoKey(clientInformation.client_id),\n      clientInformation\n    );\n    this.clientId = clientInformation.client_id;\n  }\n\n  tokenKey(clientId: string) {\n    return `${this.keyPrefix(clientId)}/token`;\n  }\n\n  async tokens(): Promise<OAuthTokens | undefined> {\n    if (!this.clientId_) {\n      return undefined;\n    }\n    return (\n      (await this.storage.get<OAuthTokens>(this.tokenKey(this.clientId))) ??\n      undefined\n    );\n  }\n\n  async saveTokens(tokens: OAuthTokens): Promise<void> {\n    await this.storage.put(this.tokenKey(this.clientId), tokens);\n  }\n\n  get authUrl() {\n    return this.authUrl_;\n  }\n\n  /**\n   * Because this operates on the server side (but we need browser auth), we send this url back to the user\n   * and require user interact to initiate the redirect flow\n   */\n  async redirectToAuthorization(authUrl: URL): Promise<void> {\n    // We want to track the client ID in state here because the typescript SSE client sometimes does\n    // a dynamic client registration AFTER generating this redirect URL.\n    const client_id = authUrl.searchParams.get(\"client_id\");\n    if (client_id) {\n      authUrl.searchParams.append(\"state\", client_id);\n    }\n    this.authUrl_ = authUrl.toString();\n  }\n\n  codeVerifierKey(clientId: string) {\n    return `${this.keyPrefix(clientId)}/code_verifier`;\n  }\n\n  async saveCodeVerifier(verifier: string): Promise<void> {\n    await this.storage.put(this.codeVerifierKey(this.clientId), verifier);\n  }\n\n  async codeVerifier(): Promise<string> {\n    const codeVerifier = await this.storage.get<string>(\n      this.codeVerifierKey(this.clientId)\n    );\n    if (!codeVerifier) {\n      throw new Error(\"No code verifier found\");\n    }\n    return codeVerifier;\n  }\n}\n", "var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\nexport {\n  __privateGet,\n  __privateAdd,\n  __privateSet,\n  __privateMethod\n};\n//# sourceMappingURL=chunk-HMLY7DHA.js.map", "import { PartySocket } from \"./chunk-HAC622V3.mjs\";\nimport { ReconnectingWebSocket } from \"./chunk-S74YV6PU.mjs\";\nexport {\n  PartySocket,\n  ReconnectingWebSocket as WebSocket,\n  PartySocket as default\n};\n//# sourceMappingURL=index.mjs.map\n", "// TODO: lose this eslint-disable\n\n/*!\n * Reconnecting WebSocket\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\n * https://github.com/pladaria/reconnecting-websocket\n * License MIT\n */\n\nimport type { TypedEventTarget } from \"./type-helper\";\n\nif (!globalThis.EventTarget || !globalThis.Event) {\n  console.error(`\n  PartySocket requires a global 'EventTarget' class to be available!\n  You can polyfill this global by adding this to your code before any partysocket imports: \n  \n  \\`\\`\\`\n  import 'partysocket/event-target-polyfill';\n  \\`\\`\\`\n  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.\n`);\n}\n\nexport class ErrorEvent extends Event {\n  public message: string;\n  public error: Error;\n  // biome-ignore lint/suspicious/noExplicitAny: vibes\n  constructor(error: Error, target: any) {\n    super(\"error\", target);\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\nexport class CloseEvent extends Event {\n  public code: number;\n  public reason: string;\n  public wasClean = true;\n  // biome-ignore lint/style/useDefaultParameterLast: legacy\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  constructor(code = 1000, reason = \"\", target: any) {\n    super(\"close\", target);\n    this.code = code;\n    this.reason = reason;\n  }\n}\nexport interface WebSocketEventMap {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n}\n\nconst Events = {\n  Event,\n  ErrorEvent,\n  CloseEvent\n};\n\nfunction assert(condition: unknown, msg?: string): asserts condition {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\n\nfunction cloneEventBrowser(e: Event) {\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  return new (e as any).constructor(e.type, e) as Event;\n}\n\nfunction cloneEventNode(e: Event) {\n  if (\"data\" in e) {\n    const evt = new MessageEvent(e.type, e);\n    return evt;\n  }\n\n  if (\"code\" in e || \"reason\" in e) {\n    const evt = new CloseEvent(\n      // @ts-expect-error we need to fix event/listener types\n      (e.code || 1999) as number,\n      // @ts-expect-error we need to fix event/listener types\n      (e.reason || \"unknown reason\") as string,\n      e\n    );\n    return evt;\n  }\n\n  if (\"error\" in e) {\n    const evt = new ErrorEvent(e.error as Error, e);\n    return evt;\n  }\n\n  const evt = new Event(e.type, e);\n  return evt;\n}\n\nconst isNode =\n  typeof process !== \"undefined\" &&\n  typeof process.versions?.node !== \"undefined\" &&\n  typeof document === \"undefined\";\n\nconst cloneEvent = isNode ? cloneEventNode : cloneEventBrowser;\n\nexport type Options = {\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  WebSocket?: any;\n  maxReconnectionDelay?: number;\n  minReconnectionDelay?: number;\n  reconnectionDelayGrowFactor?: number;\n  minUptime?: number;\n  connectionTimeout?: number;\n  maxRetries?: number;\n  maxEnqueuedMessages?: number;\n  startClosed?: boolean;\n  debug?: boolean;\n  // biome-ignore lint/suspicious/noExplicitAny: legacy\n  debugLogger?: (...args: any[]) => void;\n};\n\nconst DEFAULT = {\n  maxReconnectionDelay: 10000,\n  minReconnectionDelay: 1000 + Math.random() * 4000,\n  minUptime: 5000,\n  reconnectionDelayGrowFactor: 1.3,\n  connectionTimeout: 4000,\n  maxRetries: Number.POSITIVE_INFINITY,\n  maxEnqueuedMessages: Number.POSITIVE_INFINITY,\n  startClosed: false,\n  debug: false\n};\n\nlet didWarnAboutMissingWebSocket = false;\n\nexport type UrlProvider = string | (() => string) | (() => Promise<string>);\nexport type ProtocolsProvider =\n  | null\n  | string\n  | string[]\n  | (() => string | string[] | null)\n  | (() => Promise<string | string[] | null>);\n\nexport type Message = string | ArrayBuffer | Blob | ArrayBufferView;\n\nexport default class ReconnectingWebSocket extends (EventTarget as TypedEventTarget<WebSocketEventMap>) {\n  private _ws: WebSocket | undefined;\n  private _retryCount = -1;\n  private _uptimeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _connectTimeout: ReturnType<typeof setTimeout> | undefined;\n  private _shouldReconnect = true;\n  private _connectLock = false;\n  private _binaryType: BinaryType = \"blob\";\n  private _closeCalled = false;\n  private _messageQueue: Message[] = [];\n\n  private _debugLogger = console.log.bind(console);\n\n  protected _url: UrlProvider;\n  protected _protocols?: ProtocolsProvider;\n  protected _options: Options;\n\n  constructor(\n    url: UrlProvider,\n    protocols?: ProtocolsProvider,\n    options: Options = {}\n  ) {\n    super();\n    this._url = url;\n    this._protocols = protocols;\n    this._options = options;\n    if (this._options.startClosed) {\n      this._shouldReconnect = false;\n    }\n    if (this._options.debugLogger) {\n      this._debugLogger = this._options.debugLogger;\n    }\n    this._connect();\n  }\n\n  static get CONNECTING() {\n    return 0;\n  }\n  static get OPEN() {\n    return 1;\n  }\n  static get CLOSING() {\n    return 2;\n  }\n  static get CLOSED() {\n    return 3;\n  }\n\n  get CONNECTING() {\n    return ReconnectingWebSocket.CONNECTING;\n  }\n  get OPEN() {\n    return ReconnectingWebSocket.OPEN;\n  }\n  get CLOSING() {\n    return ReconnectingWebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return ReconnectingWebSocket.CLOSED;\n  }\n\n  get binaryType() {\n    return this._ws ? this._ws.binaryType : this._binaryType;\n  }\n\n  set binaryType(value: BinaryType) {\n    this._binaryType = value;\n    if (this._ws) {\n      this._ws.binaryType = value;\n    }\n  }\n\n  /**\n   * Returns the number or connection retries\n   */\n  get retryCount(): number {\n    return Math.max(this._retryCount, 0);\n  }\n\n  /**\n   * The number of bytes of data that have been queued using calls to send() but not yet\n   * transmitted to the network. This value resets to zero once all queued data has been sent.\n   * This value does not reset to zero when the connection is closed; if you keep calling send(),\n   * this will continue to climb. Read only\n   */\n  get bufferedAmount(): number {\n    const bytes = this._messageQueue.reduce((acc, message) => {\n      if (typeof message === \"string\") {\n        acc += message.length; // not byte size\n      } else if (message instanceof Blob) {\n        acc += message.size;\n      } else {\n        acc += message.byteLength;\n      }\n      return acc;\n    }, 0);\n    return bytes + (this._ws ? this._ws.bufferedAmount : 0);\n  }\n\n  /**\n   * The extensions selected by the server. This is currently only the empty string or a list of\n   * extensions as negotiated by the connection\n   */\n  get extensions(): string {\n    return this._ws ? this._ws.extensions : \"\";\n  }\n\n  /**\n   * A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when creating the\n   * WebSocket object\n   */\n  get protocol(): string {\n    return this._ws ? this._ws.protocol : \"\";\n  }\n\n  /**\n   * The current state of the connection; this is one of the Ready state constants\n   */\n  get readyState(): number {\n    if (this._ws) {\n      return this._ws.readyState;\n    }\n    return this._options.startClosed\n      ? ReconnectingWebSocket.CLOSED\n      : ReconnectingWebSocket.CONNECTING;\n  }\n\n  /**\n   * The URL as resolved by the constructor\n   */\n  get url(): string {\n    return this._ws ? this._ws.url : \"\";\n  }\n\n  /**\n   * Whether the websocket object is now in reconnectable state\n   */\n  get shouldReconnect(): boolean {\n    return this._shouldReconnect;\n  }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\n   */\n  public onclose: ((event: CloseEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when an error occurs\n   */\n  public onerror: ((event: ErrorEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when a message is received from the server\n   */\n  public onmessage: ((event: MessageEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data\n   */\n  public onopen: ((event: Event) => void) | null = null;\n\n  /**\n   * Closes the WebSocket connection or connection attempt, if any. If the connection is already\n   * CLOSED, this method does nothing\n   */\n  public close(code = 1000, reason?: string) {\n    this._closeCalled = true;\n    this._shouldReconnect = false;\n    this._clearTimeouts();\n    if (!this._ws) {\n      this._debug(\"close enqueued: no ws instance\");\n      return;\n    }\n    if (this._ws.readyState === this.CLOSED) {\n      this._debug(\"close: already closed\");\n      return;\n    }\n    this._ws.close(code, reason);\n  }\n\n  /**\n   * Closes the WebSocket connection or connection attempt and connects again.\n   * Resets retry counter;\n   */\n  public reconnect(code?: number, reason?: string) {\n    this._shouldReconnect = true;\n    this._closeCalled = false;\n    this._retryCount = -1;\n    if (!this._ws || this._ws.readyState === this.CLOSED) {\n      this._connect();\n    } else {\n      this._disconnect(code, reason);\n      this._connect();\n    }\n  }\n\n  /**\n   * Enqueue specified data to be transmitted to the server over the WebSocket connection\n   */\n  public send(data: Message) {\n    if (this._ws && this._ws.readyState === this.OPEN) {\n      this._debug(\"send\", data);\n      this._ws.send(data);\n    } else {\n      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } =\n        this._options;\n      if (this._messageQueue.length < maxEnqueuedMessages) {\n        this._debug(\"enqueue\", data);\n        this._messageQueue.push(data);\n      }\n    }\n  }\n\n  private _debug(...args: unknown[]) {\n    if (this._options.debug) {\n      this._debugLogger(\"RWS>\", ...args);\n    }\n  }\n\n  private _getNextDelay() {\n    const {\n      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,\n      minReconnectionDelay = DEFAULT.minReconnectionDelay,\n      maxReconnectionDelay = DEFAULT.maxReconnectionDelay\n    } = this._options;\n    let delay = 0;\n    if (this._retryCount > 0) {\n      delay =\n        minReconnectionDelay *\n        reconnectionDelayGrowFactor ** (this._retryCount - 1);\n      if (delay > maxReconnectionDelay) {\n        delay = maxReconnectionDelay;\n      }\n    }\n    this._debug(\"next delay\", delay);\n    return delay;\n  }\n\n  private _wait(): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, this._getNextDelay());\n    });\n  }\n\n  private _getNextProtocols(\n    protocolsProvider: ProtocolsProvider | null\n  ): Promise<string | string[] | null> {\n    if (!protocolsProvider) return Promise.resolve(null);\n\n    if (\n      typeof protocolsProvider === \"string\" ||\n      Array.isArray(protocolsProvider)\n    ) {\n      return Promise.resolve(protocolsProvider);\n    }\n\n    if (typeof protocolsProvider === \"function\") {\n      const protocols = protocolsProvider();\n      if (!protocols) return Promise.resolve(null);\n\n      if (typeof protocols === \"string\" || Array.isArray(protocols)) {\n        return Promise.resolve(protocols);\n      }\n\n      // @ts-expect-error redundant check\n      if (protocols.then) {\n        return protocols;\n      }\n    }\n\n    throw Error(\"Invalid protocols\");\n  }\n\n  private _getNextUrl(urlProvider: UrlProvider): Promise<string> {\n    if (typeof urlProvider === \"string\") {\n      return Promise.resolve(urlProvider);\n    }\n    if (typeof urlProvider === \"function\") {\n      const url = urlProvider();\n      if (typeof url === \"string\") {\n        return Promise.resolve(url);\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      if (url.then) {\n        return url;\n      }\n\n      // return url;\n    }\n    throw Error(\"Invalid URL\");\n  }\n\n  private _connect() {\n    if (this._connectLock || !this._shouldReconnect) {\n      return;\n    }\n    this._connectLock = true;\n\n    const {\n      maxRetries = DEFAULT.maxRetries,\n      connectionTimeout = DEFAULT.connectionTimeout\n    } = this._options;\n\n    if (this._retryCount >= maxRetries) {\n      this._debug(\"max retries reached\", this._retryCount, \">=\", maxRetries);\n      return;\n    }\n\n    this._retryCount++;\n\n    this._debug(\"connect\", this._retryCount);\n    this._removeListeners();\n\n    this._wait()\n      .then(() =>\n        Promise.all([\n          this._getNextUrl(this._url),\n          this._getNextProtocols(this._protocols || null)\n        ])\n      )\n      .then(([url, protocols]) => {\n        // close could be called before creating the ws\n        if (this._closeCalled) {\n          this._connectLock = false;\n          return;\n        }\n        if (\n          !this._options.WebSocket &&\n          typeof WebSocket === \"undefined\" &&\n          !didWarnAboutMissingWebSocket\n        ) {\n          console.error(` No WebSocket implementation available. You should define options.WebSocket. \n\nFor example, if you're using node.js, run \\`npm install ws\\`, and then in your code:\n\nimport PartySocket from 'partysocket';\nimport WS from 'ws';\n\nconst partysocket = new PartySocket({\n  host: \"127.0.0.1:1999\",\n  room: \"test-room\",\n  WebSocket: WS\n});\n\n`);\n          didWarnAboutMissingWebSocket = true;\n        }\n        const WS: typeof WebSocket = this._options.WebSocket || WebSocket;\n        this._debug(\"connect\", { url, protocols });\n        this._ws = protocols ? new WS(url, protocols) : new WS(url);\n\n        this._ws.binaryType = this._binaryType;\n        this._connectLock = false;\n        this._addListeners();\n\n        this._connectTimeout = setTimeout(\n          () => this._handleTimeout(),\n          connectionTimeout\n        );\n      })\n      // via https://github.com/pladaria/reconnecting-websocket/pull/166\n      .catch((err) => {\n        this._connectLock = false;\n        this._handleError(new Events.ErrorEvent(Error(err.message), this));\n      });\n  }\n\n  private _handleTimeout() {\n    this._debug(\"timeout event\");\n    this._handleError(new Events.ErrorEvent(Error(\"TIMEOUT\"), this));\n  }\n\n  private _disconnect(code = 1000, reason?: string) {\n    this._clearTimeouts();\n    if (!this._ws) {\n      return;\n    }\n    this._removeListeners();\n    try {\n      if (this._ws.readyState === this.OPEN) {\n        this._ws.close(code, reason);\n      }\n      this._handleClose(new Events.CloseEvent(code, reason, this));\n    } catch (error) {\n      // ignore\n    }\n  }\n\n  private _acceptOpen() {\n    this._debug(\"accept open\");\n    this._retryCount = 0;\n  }\n\n  private _handleOpen = (event: Event) => {\n    this._debug(\"open event\");\n    const { minUptime = DEFAULT.minUptime } = this._options;\n\n    clearTimeout(this._connectTimeout);\n    this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);\n\n    assert(this._ws, \"WebSocket is not defined\");\n\n    this._ws.binaryType = this._binaryType;\n\n    // send enqueued messages (messages sent before websocket open event)\n    this._messageQueue.forEach((message) => this._ws?.send(message));\n    this._messageQueue = [];\n\n    if (this.onopen) {\n      this.onopen(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _handleMessage = (event: MessageEvent) => {\n    this._debug(\"message event\");\n\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _handleError = (event: ErrorEvent) => {\n    this._debug(\"error event\", event.message);\n    this._disconnect(\n      undefined,\n      event.message === \"TIMEOUT\" ? \"timeout\" : undefined\n    );\n\n    if (this.onerror) {\n      this.onerror(event);\n    }\n    this._debug(\"exec error listeners\");\n    this.dispatchEvent(cloneEvent(event));\n\n    this._connect();\n  };\n\n  private _handleClose = (event: CloseEvent) => {\n    this._debug(\"close event\");\n    this._clearTimeouts();\n\n    if (this._shouldReconnect) {\n      this._connect();\n    }\n\n    if (this.onclose) {\n      this.onclose(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n\n  private _removeListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"removeListeners\");\n    this._ws.removeEventListener(\"open\", this._handleOpen);\n    this._ws.removeEventListener(\"close\", this._handleClose);\n    this._ws.removeEventListener(\"message\", this._handleMessage);\n    // @ts-expect-error we need to fix event/listerner types\n    this._ws.removeEventListener(\"error\", this._handleError);\n  }\n\n  private _addListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"addListeners\");\n    this._ws.addEventListener(\"open\", this._handleOpen);\n    this._ws.addEventListener(\"close\", this._handleClose);\n    this._ws.addEventListener(\"message\", this._handleMessage);\n    // @ts-expect-error we need to fix event/listener types\n    this._ws.addEventListener(\"error\", this._handleError);\n  }\n\n  private _clearTimeouts() {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._uptimeTimeout);\n  }\n}\n", "import {\n  PartySocket,\n  type PartySocketOptions,\n  type PartyFetchOptions,\n} from \"partysocket\";\nimport type { RPCRequest, RPCResponse } from \"./\";\n\n/**\n * Options for creating an AgentClient\n */\nexport type AgentClientOptions<State = unknown> = Omit<\n  PartySocketOptions,\n  \"party\" | \"room\"\n> & {\n  /** Name of the agent to connect to */\n  agent: string;\n  /** Name of the specific Agent instance */\n  name?: string;\n  /** Called when the Agent's state is updated */\n  onStateUpdate?: (state: State, source: \"server\" | \"client\") => void;\n};\n\n/**\n * Options for streaming RPC calls\n */\nexport type StreamOptions = {\n  /** Called when a chunk of data is received */\n  onChunk?: (chunk: unknown) => void;\n  /** Called when the stream ends */\n  onDone?: (finalChunk: unknown) => void;\n  /** Called when an error occurs */\n  onError?: (error: string) => void;\n};\n\n/**\n * Options for the agentFetch function\n */\nexport type AgentClientFetchOptions = Omit<\n  PartyFetchOptions,\n  \"party\" | \"room\"\n> & {\n  /** Name of the agent to connect to */\n  agent: string;\n  /** Name of the specific Agent instance */\n  name?: string;\n};\n\n/**\n * Convert a camelCase string to a kebab-case string\n * @param str The string to convert\n * @returns The kebab-case string\n */\nexport function camelCaseToKebabCase(str: string): string {\n  // If string is all uppercase, convert to lowercase\n  if (str === str.toUpperCase() && str !== str.toLowerCase()) {\n    return str.toLowerCase().replace(/_/g, \"-\");\n  }\n\n  // Otherwise handle camelCase to kebab-case\n  let kebabified = str.replace(\n    /[A-Z]/g,\n    (letter) => `-${letter.toLowerCase()}`\n  );\n  kebabified = kebabified.startsWith(\"-\") ? kebabified.slice(1) : kebabified;\n  // Convert any remaining underscores to hyphens and remove trailing -'s\n  return kebabified.replace(/_/g, \"-\").replace(/-$/, \"\");\n}\n\n/**\n * WebSocket client for connecting to an Agent\n */\nexport class AgentClient<State = unknown> extends PartySocket {\n  /**\n   * @deprecated Use agentFetch instead\n   */\n  static fetch(_opts: PartyFetchOptions): Promise<Response> {\n    throw new Error(\n      \"AgentClient.fetch is not implemented, use agentFetch instead\"\n    );\n  }\n  agent: string;\n  name: string;\n  #options: AgentClientOptions<State>;\n  #pendingCalls = new Map<\n    string,\n    {\n      resolve: (value: unknown) => void;\n      reject: (error: Error) => void;\n      stream?: StreamOptions;\n      type?: unknown;\n    }\n  >();\n\n  constructor(options: AgentClientOptions<State>) {\n    const agentNamespace = camelCaseToKebabCase(options.agent);\n    super({\n      prefix: \"agents\",\n      party: agentNamespace,\n      room: options.name || \"default\",\n      ...options,\n    });\n    this.agent = agentNamespace;\n    this.name = options.name || \"default\";\n    this.#options = options;\n\n    this.addEventListener(\"message\", (event) => {\n      if (typeof event.data === \"string\") {\n        let parsedMessage: Record<string, unknown>;\n        try {\n          parsedMessage = JSON.parse(event.data);\n        } catch (error) {\n          // silently ignore invalid messages for now\n          // TODO: log errors with log levels\n          return;\n        }\n        if (parsedMessage.type === \"cf_agent_state\") {\n          this.#options.onStateUpdate?.(parsedMessage.state as State, \"server\");\n          return;\n        }\n        if (parsedMessage.type === \"rpc\") {\n          const response = parsedMessage as RPCResponse;\n          const pending = this.#pendingCalls.get(response.id);\n          if (!pending) return;\n\n          if (!response.success) {\n            pending.reject(new Error(response.error));\n            this.#pendingCalls.delete(response.id);\n            pending.stream?.onError?.(response.error);\n            return;\n          }\n\n          // Handle streaming responses\n          if (\"done\" in response) {\n            if (response.done) {\n              pending.resolve(response.result);\n              this.#pendingCalls.delete(response.id);\n              pending.stream?.onDone?.(response.result);\n            } else {\n              pending.stream?.onChunk?.(response.result);\n            }\n          } else {\n            // Non-streaming response\n            pending.resolve(response.result);\n            this.#pendingCalls.delete(response.id);\n          }\n        }\n      }\n    });\n  }\n\n  setState(state: State) {\n    this.send(JSON.stringify({ type: \"cf_agent_state\", state }));\n    this.#options.onStateUpdate?.(state, \"client\");\n  }\n\n  /**\n   * Call a method on the Agent\n   * @param method Name of the method to call\n   * @param args Arguments to pass to the method\n   * @param streamOptions Options for handling streaming responses\n   * @returns Promise that resolves with the method's return value\n   */\n  async call<T = unknown>(\n    method: string,\n    args: unknown[] = [],\n    streamOptions?: StreamOptions\n  ): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const id = Math.random().toString(36).slice(2);\n      this.#pendingCalls.set(id, {\n        resolve: (value: unknown) => resolve(value as T),\n        reject,\n        stream: streamOptions,\n        type: null as T,\n      });\n\n      const request: RPCRequest = {\n        type: \"rpc\",\n        id,\n        method,\n        args,\n      };\n\n      this.send(JSON.stringify(request));\n    });\n  }\n}\n\n/**\n * Make an HTTP request to an Agent\n * @param opts Connection options\n * @param init Request initialization options\n * @returns Promise resolving to a Response\n */\nexport function agentFetch(opts: AgentClientFetchOptions, init?: RequestInit) {\n  const agentNamespace = camelCaseToKebabCase(opts.agent);\n\n  return PartySocket.fetch(\n    {\n      prefix: \"agents\",\n      party: agentNamespace,\n      room: opts.name || \"default\",\n      ...opts,\n    },\n    init\n  );\n}\n", null, "/**\n * The type of error that occurred.\n * @public\n */\nexport type ErrorType = 'invalid-retry' | 'unknown-field'\n\n/**\n * Error thrown when encountering an issue during parsing.\n *\n * @public\n */\nexport class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}\n", "/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nimport {ParseError} from './errors.ts'\nimport type {EventSourceParser, ParserCallbacks} from './types.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction noop(_arg: unknown) {\n  // intentional noop\n}\n\n/**\n * Creates a new EventSource parser.\n *\n * @param callbacks - Callbacks to invoke on different parsing events:\n *   - `onEvent` when a new event is parsed\n *   - `onError` when an error occurs\n *   - `onRetry` when a new reconnection interval has been sent from the server\n *   - `onComment` when a comment is encountered in the stream\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  if (typeof callbacks === 'function') {\n    throw new TypeError(\n      '`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?',\n    )\n  }\n\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    //  This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}\n\n/**\n * For the given `chunk`, split it into lines according to spec, and return any remaining incomplete line.\n *\n * @param chunk - The chunk to split into lines\n * @returns A tuple containing an array of complete lines, and any remaining incomplete line\n * @internal\n */\nfunction splitLines(chunk: string): [complete: Array<string>, incomplete: string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n  const lines: Array<string> = []\n  let incompleteLine = ''\n  let searchIndex = 0\n\n  while (searchIndex < chunk.length) {\n    // Find next line terminator\n    const crIndex = chunk.indexOf('\\r', searchIndex)\n    const lfIndex = chunk.indexOf('\\n', searchIndex)\n\n    // Determine line end\n    let lineEnd = -1\n    if (crIndex !== -1 && lfIndex !== -1) {\n      // CRLF case\n      lineEnd = Math.min(crIndex, lfIndex)\n    } else if (crIndex !== -1) {\n      lineEnd = crIndex\n    } else if (lfIndex !== -1) {\n      lineEnd = lfIndex\n    }\n\n    // Extract line if terminator found\n    if (lineEnd === -1) {\n      // No terminator found, rest is incomplete\n      incompleteLine = chunk.slice(searchIndex)\n      break\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd)\n      lines.push(line)\n\n      // Move past line terminator\n      searchIndex = lineEnd + 1\n      if (chunk[searchIndex - 1] === '\\r' && chunk[searchIndex] === '\\n') {\n        searchIndex++\n      }\n    }\n  }\n\n  return [lines, incompleteLine]\n}\n", "/**\n * An extended version of the `Event` emitted by the `EventSource` object when an error occurs.\n * While the spec does not include any additional properties, we intentionally go beyond the spec\n * and provide some (minimal) additional information to aid in debugging.\n *\n * @public\n */\nexport class ErrorEvent extends Event {\n  /**\n   * HTTP status code, if this was triggered by an HTTP error\n   * Note: this is not part of the spec, but is included for better error handling.\n   *\n   * @public\n   */\n  public code?: number | undefined\n\n  /**\n   * Optional message attached to the error.\n   * Note: this is not part of the spec, but is included for better error handling.\n   *\n   * @public\n   */\n  public message?: string | undefined\n\n  /**\n   * Constructs a new `ErrorEvent` instance. This is typically not called directly,\n   * but rather emitted by the `EventSource` object when an error occurs.\n   *\n   * @param type - The type of the event (should be \"error\")\n   * @param errorEventInitDict - Optional properties to include in the error event\n   */\n  constructor(\n    type: string,\n    errorEventInitDict?: {message?: string | undefined; code?: number | undefined},\n  ) {\n    super(type)\n    this.code = errorEventInitDict?.code ?? undefined\n    this.message = errorEventInitDict?.message ?? undefined\n  }\n\n  /**\n   * Node.js \"hides\" the `message` and `code` properties of the `ErrorEvent` instance,\n   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,\n   * we explicitly include the properties in the `inspect` method.\n   *\n   * This is automatically called by Node.js when you `console.log` an instance of this class.\n   *\n   * @param _depth - The current depth\n   * @param options - The options passed to `util.inspect`\n   * @param inspect - The inspect function to use (prevents having to import it from `util`)\n   * @returns A string representation of the error\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](\n    _depth: number,\n    options: {colors: boolean},\n    inspect: (obj: unknown, inspectOptions: {colors: boolean}) => string,\n  ): string {\n    return inspect(inspectableError(this), options)\n  }\n\n  /**\n   * Deno \"hides\" the `message` and `code` properties of the `ErrorEvent` instance,\n   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,\n   * we explicitly include the properties in the `inspect` method.\n   *\n   * This is automatically called by Deno when you `console.log` an instance of this class.\n   *\n   * @param inspect - The inspect function to use (prevents having to import it from `util`)\n   * @param options - The options passed to `Deno.inspect`\n   * @returns A string representation of the error\n   */\n  [Symbol.for('Deno.customInspect')](\n    inspect: (obj: unknown, inspectOptions: {colors: boolean}) => string,\n    options: {colors: boolean},\n  ): string {\n    return inspect(inspectableError(this), options)\n  }\n}\n\n/**\n * For environments where DOMException may not exist, we will use a SyntaxError instead.\n * While this isn't strictly according to spec, it is very close.\n *\n * @param message - The message to include in the error\n * @returns A `DOMException` or `SyntaxError` instance\n * @internal\n */\nexport function syntaxError(message: string): SyntaxError {\n  // If someone can figure out a way to make this work without depending on DOM/Node.js typings,\n  // and without casting to `any`, please send a PR \n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const DomException = (globalThis as any).DOMException\n  if (typeof DomException === 'function') {\n    return new DomException(message, 'SyntaxError')\n  }\n\n  return new SyntaxError(message)\n}\n\n/**\n * Flatten an error into a single error message string.\n * Unwraps nested errors and joins them with a comma.\n *\n * @param err - The error to flatten\n * @returns A string representation of the error\n * @internal\n */\nexport function flattenError(err: unknown): string {\n  if (!(err instanceof Error)) {\n    return `${err}`\n  }\n\n  if ('errors' in err && Array.isArray(err.errors)) {\n    return err.errors.map(flattenError).join(', ')\n  }\n\n  if ('cause' in err && err.cause instanceof Error) {\n    return `${err}: ${flattenError(err.cause)}`\n  }\n\n  return err.message\n}\n\n/**\n * Convert an `ErrorEvent` instance into a plain object for inspection.\n *\n * @param err - The `ErrorEvent` instance to inspect\n * @returns A plain object representation of the error\n * @internal\n */\nfunction inspectableError(err: ErrorEvent) {\n  return {\n    type: err.type,\n    message: err.message,\n    code: err.code,\n    defaultPrevented: err.defaultPrevented,\n    cancelable: err.cancelable,\n    timeStamp: err.timeStamp,\n  }\n}\n", "import {createParser, type EventSourceMessage, type EventSourceParser} from 'eventsource-parser'\n\nimport {ErrorEvent, flattenError, syntaxError} from './errors.js'\nimport type {\n  AddEventListenerOptions,\n  EventListenerOptions,\n  EventListenerOrEventListenerObject,\n  EventSourceEventMap,\n  EventSourceFetchInit,\n  EventSourceInit,\n  FetchLike,\n  FetchLikeResponse,\n} from './types.js'\n\n/**\n * An `EventSource` instance opens a persistent connection to an HTTP server, which sends events\n * in `text/event-stream` format. The connection remains open until closed by calling `.close()`.\n *\n * @public\n * @example\n * ```js\n * const eventSource = new EventSource('https://example.com/stream')\n * eventSource.addEventListener('error', (error) => {\n *   console.error(error)\n * })\n * eventSource.addEventListener('message', (event) => {\n *  console.log('Received message:', event.data)\n * })\n * ```\n */\nexport class EventSource extends EventTarget {\n  /**\n   * ReadyState representing an EventSource currently trying to connect\n   *\n   * @public\n   */\n  static CONNECTING = 0 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is open (eg connected)\n   *\n   * @public\n   */\n  static OPEN = 1 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is closed (eg disconnected)\n   *\n   * @public\n   */\n  static CLOSED = 2 as const\n\n  /**\n   * ReadyState representing an EventSource currently trying to connect\n   *\n   * @public\n   */\n  readonly CONNECTING = 0 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is open (eg connected)\n   *\n   * @public\n   */\n  readonly OPEN = 1 as const\n\n  /**\n   * ReadyState representing an EventSource connection that is closed (eg disconnected)\n   *\n   * @public\n   */\n  readonly CLOSED = 2 as const\n\n  /**\n   * Returns the state of this EventSource object's connection. It can have the values described below.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)\n   *\n   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,\n   * defined in the TypeScript `dom` library.\n   *\n   * @public\n   */\n  public get readyState(): number {\n    return this.#readyState\n  }\n\n  /**\n   * Returns the URL providing the event stream.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)\n   *\n   * @public\n   */\n  public get url(): string {\n    return this.#url.href\n  }\n\n  /**\n   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to \"include\", and false otherwise.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)\n   */\n  public get withCredentials(): boolean {\n    return this.#withCredentials\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */\n  public get onerror(): ((ev: ErrorEvent) => unknown) | null {\n    return this.#onError\n  }\n  public set onerror(value: ((ev: ErrorEvent) => unknown) | null) {\n    this.#onError = value\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */\n  public get onmessage(): ((ev: MessageEvent) => unknown) | null {\n    return this.#onMessage\n  }\n  public set onmessage(value: ((ev: MessageEvent) => unknown) | null) {\n    this.#onMessage = value\n  }\n\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */\n  public get onopen(): ((ev: Event) => unknown) | null {\n    return this.#onOpen\n  }\n  public set onopen(value: ((ev: Event) => unknown) | null) {\n    this.#onOpen = value\n  }\n\n  override addEventListener<K extends keyof EventSourceEventMap>(\n    type: K,\n    listener: (this: EventSource, ev: EventSourceEventMap[K]) => unknown,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener: (this: EventSource, event: MessageEvent) => unknown,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void\n  override addEventListener(\n    type: string,\n    listener:\n      | ((this: EventSource, event: MessageEvent) => unknown)\n      | EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    const listen = listener as (this: EventSource, event: Event) => unknown\n    super.addEventListener(type, listen, options)\n  }\n\n  override removeEventListener<K extends keyof EventSourceEventMap>(\n    type: K,\n    listener: (this: EventSource, ev: EventSourceEventMap[K]) => unknown,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener: (this: EventSource, event: MessageEvent) => unknown,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void\n  override removeEventListener(\n    type: string,\n    listener:\n      | ((this: EventSource, event: MessageEvent) => unknown)\n      | EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions,\n  ): void {\n    const listen = listener as (this: EventSource, event: Event) => unknown\n    super.removeEventListener(type, listen, options)\n  }\n\n  constructor(url: string | URL, eventSourceInitDict?: EventSourceInit) {\n    super()\n\n    try {\n      if (url instanceof URL) {\n        this.#url = url\n      } else if (typeof url === 'string') {\n        this.#url = new URL(url, getBaseURL())\n      } else {\n        throw new Error('Invalid URL')\n      }\n    } catch (err) {\n      throw syntaxError('An invalid or illegal string was specified')\n    }\n\n    this.#parser = createParser({\n      onEvent: this.#onEvent,\n      onRetry: this.#onRetryChange,\n    })\n\n    this.#readyState = this.CONNECTING\n    this.#reconnectInterval = 3000\n    this.#fetch = eventSourceInitDict?.fetch ?? globalThis.fetch\n    this.#withCredentials = eventSourceInitDict?.withCredentials ?? false\n\n    this.#connect()\n  }\n\n  /**\n   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.\n   *\n   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)\n   *\n   * @public\n   */\n  close(): void {\n    if (this.#reconnectTimer) clearTimeout(this.#reconnectTimer)\n    if (this.#readyState === this.CLOSED) return\n    if (this.#controller) this.#controller.abort()\n    this.#readyState = this.CLOSED\n    this.#controller = undefined\n  }\n\n  // PRIVATES FOLLOW\n\n  /**\n   * Current connection state\n   *\n   * @internal\n   */\n  #readyState: number\n\n  /**\n   * Original URL used to connect.\n   *\n   * Note that this will stay the same even after a redirect.\n   *\n   * @internal\n   */\n  #url: URL\n\n  /**\n   * The destination URL after a redirect. Is reset on reconnection.\n   *\n   * @internal\n   */\n  #redirectUrl: URL | undefined\n\n  /**\n   * Whether to include credentials in the request\n   *\n   * @internal\n   */\n  #withCredentials: boolean\n\n  /**\n   * The fetch implementation to use\n   *\n   * @internal\n   */\n  #fetch: FetchLike\n\n  /**\n   * The reconnection time in milliseconds\n   *\n   * @internal\n   */\n  #reconnectInterval: number\n\n  /**\n   * Reference to an ongoing reconnect attempt, if any\n   *\n   * @internal\n   */\n  #reconnectTimer: ReturnType<typeof setTimeout> | undefined\n\n  /**\n   * The last event ID seen by the EventSource, which will be sent as `Last-Event-ID` in the\n   * request headers on a reconnection attempt.\n   *\n   * @internal\n   */\n  #lastEventId: string | null = null\n\n  /**\n   * The AbortController instance used to abort the fetch request\n   *\n   * @internal\n   */\n  #controller: AbortController | undefined\n\n  /**\n   * Instance of an EventSource parser (`eventsource-parser` npm module)\n   *\n   * @internal\n   */\n  #parser: EventSourceParser\n\n  /**\n   * Holds the current error handler, attached through `onerror` property directly.\n   * Note that `addEventListener('error', )` will not be stored here.\n   *\n   * @internal\n   */\n  #onError: ((ev: ErrorEvent) => unknown) | null = null\n\n  /**\n   * Holds the current message handler, attached through `onmessage` property directly.\n   * Note that `addEventListener('message', )` will not be stored here.\n   *\n   * @internal\n   */\n  #onMessage: ((ev: MessageEvent) => unknown) | null = null\n\n  /**\n   * Holds the current open handler, attached through `onopen` property directly.\n   * Note that `addEventListener('open', )` will not be stored here.\n   *\n   * @internal\n   */\n  #onOpen: ((ev: Event) => unknown) | null = null\n\n  /**\n   * Connect to the given URL and start receiving events\n   *\n   * @internal\n   */\n  #connect() {\n    this.#readyState = this.CONNECTING\n    this.#controller = new AbortController()\n\n    // Browser tests are failing if we directly call `this.#fetch()`, thus the indirection.\n    const fetch = this.#fetch\n    fetch(this.#url, this.#getRequestOptions())\n      .then(this.#onFetchResponse)\n      .catch(this.#onFetchError)\n  }\n\n  /**\n   * Handles the fetch response\n   *\n   * @param response - The Fetch(ish) response\n   * @internal\n   */\n  #onFetchResponse = async (response: FetchLikeResponse) => {\n    this.#parser.reset()\n\n    const {body, redirected, status, headers} = response\n\n    // [spec] a client can be told to stop reconnecting using the HTTP 204 No Content response code.\n    if (status === 204) {\n      // We still need to emit an error event - this mirrors the browser behavior,\n      // and without it there is no way to tell the user that the connection was closed.\n      this.#failConnection('Server sent HTTP 204, not reconnecting', 204)\n      this.close()\n      return\n    }\n\n    // [spec] Event stream requests can be redirected using HTTP 301 and 307 redirects as with\n    // [spec] normal HTTP requests.\n    // Spec does not say anything about other redirect codes (302, 308), but this seems an\n    // unintended omission, rather than a feature. Browsers will happily redirect on other 3xxs's.\n    if (redirected) {\n      this.#redirectUrl = new URL(response.url)\n    } else {\n      this.#redirectUrl = undefined\n    }\n\n    // [spec] if res's status is not 200, , then fail the connection.\n    if (status !== 200) {\n      this.#failConnection(`Non-200 status code (${status})`, status)\n      return\n    }\n\n    // [spec] or if res's `Content-Type` is not `text/event-stream`, then fail the connection.\n    const contentType = headers.get('content-type') || ''\n    if (!contentType.startsWith('text/event-stream')) {\n      this.#failConnection('Invalid content type, expected \"text/event-stream\"', status)\n      return\n    }\n\n    // [spec] if the readyState attribute is set to a value other than CLOSED\n    if (this.#readyState === this.CLOSED) {\n      return\n    }\n\n    // [spec] sets the readyState attribute to OPEN and fires an event\n    // [spec] named open at the EventSource object.\n    this.#readyState = this.OPEN\n\n    const openEvent = new Event('open')\n    this.#onOpen?.(openEvent)\n    this.dispatchEvent(openEvent)\n\n    // Ensure that the response stream is a web stream\n    if (typeof body !== 'object' || !body || !('getReader' in body)) {\n      this.#failConnection('Invalid response body, expected a web ReadableStream', status)\n      this.close() // This should only happen if `fetch` provided is \"faulty\" - don't reconnect\n      return\n    }\n\n    const decoder = new TextDecoder()\n\n    const reader = body.getReader()\n    let open = true\n\n    do {\n      const {done, value} = await reader.read()\n      if (value) {\n        this.#parser.feed(decoder.decode(value, {stream: !done}))\n      }\n\n      if (!done) {\n        continue\n      }\n\n      open = false\n      this.#parser.reset()\n\n      this.#scheduleReconnect()\n    } while (open)\n  }\n\n  /**\n   * Handles rejected requests for the EventSource endpoint\n   *\n   * @param err - The error from `fetch()`\n   * @internal\n   */\n  #onFetchError = (err: Error & {type?: string}) => {\n    this.#controller = undefined\n\n    // We expect abort errors when the user manually calls `close()` - ignore those\n    if (err.name === 'AbortError' || err.type === 'aborted') {\n      return\n    }\n\n    this.#scheduleReconnect(flattenError(err))\n  }\n\n  /**\n   * Get request options for the `fetch()` request\n   *\n   * @returns The request options\n   * @internal\n   */\n  #getRequestOptions(): EventSourceFetchInit {\n    const lastEvent = this.#lastEventId ? {'Last-Event-ID': this.#lastEventId} : undefined\n\n    const init: EventSourceFetchInit = {\n      // [spec] Let `corsAttributeState` be `Anonymous`\n      // [spec] will have their mode set to \"cors\"\n      mode: 'cors',\n      redirect: 'follow',\n      headers: {Accept: 'text/event-stream', ...lastEvent},\n      cache: 'no-store',\n      signal: this.#controller?.signal,\n    }\n\n    // Some environments crash if attempting to set `credentials` where it is not supported,\n    // eg on Cloudflare Workers. To avoid this, we only set it in browser-like environments.\n    if ('window' in globalThis) {\n      // [spec] and their credentials mode set to \"same-origin\"\n      // [spec] if the `withCredentials` attribute is `true`, set the credentials mode to \"include\"\n      init.credentials = this.withCredentials ? 'include' : 'same-origin'\n    }\n\n    return init\n  }\n\n  /**\n   * Called by EventSourceParser instance when an event has successfully been parsed\n   * and is ready to be processed.\n   *\n   * @param event - The parsed event\n   * @internal\n   */\n  #onEvent = (event: EventSourceMessage) => {\n    if (typeof event.id === 'string') {\n      this.#lastEventId = event.id\n    }\n\n    const messageEvent = new MessageEvent(event.event || 'message', {\n      data: event.data,\n      origin: this.#redirectUrl ? this.#redirectUrl.origin : this.#url.origin,\n      lastEventId: event.id || '',\n    })\n\n    // The `onmessage` property of the EventSource instance only triggers on messages without an\n    // `event` field, or ones that explicitly set `message`.\n    if (this.#onMessage && (!event.event || event.event === 'message')) {\n      this.#onMessage(messageEvent)\n    }\n\n    this.dispatchEvent(messageEvent)\n  }\n\n  /**\n   * Called by EventSourceParser instance when a new reconnection interval is received\n   * from the EventSource endpoint.\n   *\n   * @param value - The new reconnection interval in milliseconds\n   * @internal\n   */\n  #onRetryChange = (value: number) => {\n    this.#reconnectInterval = value\n  }\n\n  /**\n   * Handles the process referred to in the EventSource specification as \"failing a connection\".\n   *\n   * @param error - The error causing the connection to fail\n   * @param code - The HTTP status code, if available\n   * @internal\n   */\n  #failConnection(message?: string, code?: number) {\n    // [spec] if the readyState attribute is set to a value other than CLOSED,\n    // [spec] sets the readyState attribute to CLOSED\n    if (this.#readyState !== this.CLOSED) {\n      this.#readyState = this.CLOSED\n    }\n\n    // [spec] and fires an event named `error` at the `EventSource` object.\n    // [spec] Once the user agent has failed the connection, it does not attempt to reconnect.\n    // [spec] > Implementations are especially encouraged to report detailed information\n    // [spec] > to their development consoles whenever an error event is fired, since little\n    // [spec] > to no information can be made available in the events themselves.\n    // Printing to console is not very programatically helpful, though, so we emit a custom event.\n    const errorEvent = new ErrorEvent('error', {code, message})\n\n    this.#onError?.(errorEvent)\n    this.dispatchEvent(errorEvent)\n  }\n\n  /**\n   * Schedules a reconnection attempt against the EventSource endpoint.\n   *\n   * @param message - The error causing the connection to fail\n   * @param code - The HTTP status code, if available\n   * @internal\n   */\n  #scheduleReconnect(message?: string, code?: number) {\n    // [spec] If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === this.CLOSED) {\n      return\n    }\n\n    // [spec] Set the readyState attribute to CONNECTING.\n    this.#readyState = this.CONNECTING\n\n    // [spec] Fire an event named `error` at the EventSource object.\n    const errorEvent = new ErrorEvent('error', {code, message})\n    this.#onError?.(errorEvent)\n    this.dispatchEvent(errorEvent)\n\n    // [spec] Wait a delay equal to the reconnection time of the event source.\n    this.#reconnectTimer = setTimeout(this.#reconnect, this.#reconnectInterval)\n  }\n\n  /**\n   * Reconnects to the EventSource endpoint after a disconnect/failure\n   *\n   * @internal\n   */\n  #reconnect = () => {\n    this.#reconnectTimer = undefined\n\n    // [spec] If the EventSource's readyState attribute is not set to CONNECTING, then return.\n    if (this.#readyState !== this.CONNECTING) {\n      return\n    }\n\n    this.#connect()\n  }\n}\n\n/**\n * According to spec, when constructing a URL:\n * > 1. Let baseURL be environment's base URL, if environment is a Document object\n * > 2. Return the result of applying the URL parser to url, with baseURL.\n *\n * Thus we should use `document.baseURI` if available, since it can be set through a base tag.\n *\n * @returns The base URL, if available - otherwise `undefined`\n * @internal\n */\nfunction getBaseURL(): string | undefined {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const doc = 'document' in globalThis ? (globalThis as any).document : undefined\n  return doc && typeof doc === 'object' && 'baseURI' in doc && typeof doc.baseURI === 'string'\n    ? doc.baseURI\n    : undefined\n}\n", null, "var util;\n(function (util) {\n    util.assertEqual = (val) => val;\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n            .join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then &&\n                typeof data.then === \"function\" &&\n                data.catch &&\n                typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\n\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === errorMap ? undefined : errorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" &&\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nconst OK = (value) => ({ status: \"valid\", value });\nconst isAborted = (x) => x.status === \"aborted\";\nconst isDirty = (x) => x.status === \"dirty\";\nconst isValid = (x) => x.status === \"valid\";\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\n\nvar _ZodEnum_cache, _ZodNativeEnum_cache;\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        var _a, _b;\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        var _a, _b;\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult)\n            ? maybeAsyncResult\n            : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\"\n                    ? refinementData(val, ctx)\n                    : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&\u2019*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nfunction datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (!decoded.typ || !decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        var _a, _b;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" ||\n                ch.kind === \"int\" ||\n                ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch (_a) {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return (this._cached = { shape, keys });\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever &&\n            this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        var _a, _b, _c, _d;\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key) => {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util\n            .objectKeys(a)\n            .filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date &&\n        bType === ZodParsedType.date &&\n        +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args\n                    .parseAsync(args, params)\n                    .catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args\n                ? args\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    constructor() {\n        super(...arguments);\n        _ZodEnum_cache.set(this, void 0);\n    }\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\n_ZodEnum_cache = new WeakMap();\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    constructor() {\n        super(...arguments);\n        _ZodNativeEnum_cache.set(this, void 0);\n    }\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string &&\n            ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\n_ZodNativeEnum_cache = new WeakMap();\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise &&\n            ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise\n            ? ctx.data\n            : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((base) => {\n                    if (!isValid(base))\n                        return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result)\n            ? result.then((data) => freeze(data))\n            : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\"\n        ? params(data)\n        : typeof params === \"string\"\n            ? { message: params }\n            : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nfunction custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            var _a, _b;\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    var _a, _b;\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nconst late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nconst coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nconst NEVER = INVALID;\n\nvar z = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () { return util; },\n    get objectUtil () { return objectUtil; },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    datetimeRegex: datetimeRegex,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    ZodReadonly: ZodReadonly,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    'enum': enumType,\n    'function': functionType,\n    'instanceof': instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    'null': nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    'undefined': undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    'void': voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\nexport { BRAND, DIRTY, EMPTY_PATH, INVALID, NEVER, OK, ParseStatus, ZodType as Schema, ZodAny, ZodArray, ZodBigInt, ZodBoolean, ZodBranded, ZodCatch, ZodDate, ZodDefault, ZodDiscriminatedUnion, ZodEffects, ZodEnum, ZodError, ZodFirstPartyTypeKind, ZodFunction, ZodIntersection, ZodIssueCode, ZodLazy, ZodLiteral, ZodMap, ZodNaN, ZodNativeEnum, ZodNever, ZodNull, ZodNullable, ZodNumber, ZodObject, ZodOptional, ZodParsedType, ZodPipeline, ZodPromise, ZodReadonly, ZodRecord, ZodType as ZodSchema, ZodSet, ZodString, ZodSymbol, ZodEffects as ZodTransformer, ZodTuple, ZodType, ZodUndefined, ZodUnion, ZodUnknown, ZodVoid, addIssueToContext, anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, coerce, custom, dateType as date, datetimeRegex, z as default, errorMap as defaultErrorMap, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, getErrorMap, getParsedType, instanceOfType as instanceof, intersectionType as intersection, isAborted, isAsync, isDirty, isValid, late, lazyType as lazy, literalType as literal, makeIssue, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, objectUtil, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, quotelessJson, recordType as record, setType as set, setErrorMap, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, util, voidType as void, z };\n", null, "let crypto;\ncrypto = globalThis.crypto; // web browsers\n/**\n * Creates an array of length `size` of random bytes\n * @param size\n * @returns Array of random ints (0 to 255)\n */\nasync function getRandomValues(size) {\n    return (await crypto).getRandomValues(new Uint8Array(size));\n}\n/** Generate cryptographically strong random string\n * @param size The desired length of the string\n * @returns The random string\n */\nasync function random(size) {\n    const mask = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~\";\n    let result = \"\";\n    const randomUints = await getRandomValues(size);\n    for (let i = 0; i < size; i++) {\n        // cap the value of the randomIndex to mask.length - 1\n        const randomIndex = randomUints[i] % mask.length;\n        result += mask[randomIndex];\n    }\n    return result;\n}\n/** Generate a PKCE challenge verifier\n * @param length Length of the verifier\n * @returns A random verifier `length` characters long\n */\nasync function generateVerifier(length) {\n    return await random(length);\n}\n/** Generate a PKCE code challenge from a code verifier\n * @param code_verifier\n * @returns The base64 url encoded code challenge\n */\nexport async function generateChallenge(code_verifier) {\n    const buffer = await (await crypto).subtle.digest(\"SHA-256\", new TextEncoder().encode(code_verifier));\n    // Generate base64url string\n    // btoa is deprecated in Node.js but is used here for web browser compatibility\n    // (which has no good replacement yet, see also https://github.com/whatwg/html/issues/6811)\n    return btoa(String.fromCharCode(...new Uint8Array(buffer)))\n        .replace(/\\//g, '_')\n        .replace(/\\+/g, '-')\n        .replace(/=/g, '');\n}\n/** Generate a PKCE challenge pair\n * @param length Length of the verifer (between 43-128). Defaults to 43.\n * @returns PKCE challenge pair\n */\nexport default async function pkceChallenge(length) {\n    if (!length)\n        length = 43;\n    if (length < 43 || length > 128) {\n        throw `Expected a length between 43 and 128. Received ${length}.`;\n    }\n    const verifier = await generateVerifier(length);\n    const challenge = await generateChallenge(verifier);\n    return {\n        code_verifier: verifier,\n        code_challenge: challenge,\n    };\n}\n/** Verify that a code_verifier produces the expected code challenge\n * @param code_verifier\n * @param expectedChallenge The code challenge to verify\n * @returns True if challenges are equal. False otherwise.\n */\nexport async function verifyChallenge(code_verifier, expectedChallenge) {\n    const actualChallenge = await generateChallenge(code_verifier);\n    return actualChallenge === expectedChallenge;\n}\n", null, null, null, "/**\n * Symbol used for identifying AI SDK Error instances.\n * Enables checking if an error is an instance of AISDKError across package versions.\n */\nconst marker = 'vercel.ai.error';\nconst symbol = Symbol.for(marker);\n\n/**\n * Custom error class for AI SDK related errors.\n * @extends Error\n */\nexport class AISDKError extends Error {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n   * The underlying cause of the error, if any.\n   */\n  readonly cause?: unknown;\n\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name,\n    message,\n    cause,\n  }: {\n    name: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super(message);\n\n    this.name = name;\n    this.cause = cause;\n  }\n\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error: unknown): error is AISDKError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  protected static hasMarker(error: unknown, marker: string): boolean {\n    const markerSymbol = Symbol.for(marker);\n    return (\n      error != null &&\n      typeof error === 'object' &&\n      markerSymbol in error &&\n      typeof error[markerSymbol] === 'boolean' &&\n      error[markerSymbol] === true\n    );\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_APICallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class APICallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly requestBodyValues: unknown;\n  readonly statusCode?: number;\n\n  readonly responseHeaders?: Record<string, string>;\n  readonly responseBody?: string;\n\n  readonly isRetryable: boolean;\n  readonly data?: unknown;\n\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null &&\n      (statusCode === 408 || // request timeout\n        statusCode === 409 || // conflict\n        statusCode === 429 || // too many requests\n        statusCode >= 500), // server error\n    data,\n  }: {\n    message: string;\n    url: string;\n    requestBodyValues: unknown;\n    statusCode?: number;\n    responseHeaders?: Record<string, string>;\n    responseBody?: string;\n    cause?: unknown;\n    isRetryable?: boolean;\n    data?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is APICallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_EmptyResponseBodyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class EmptyResponseBodyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'Empty response body' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is EmptyResponseBodyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A function argument is invalid.\n */\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly argument: string;\n\n  constructor({\n    message,\n    cause,\n    argument,\n  }: {\n    argument: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.argument = argument;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidPromptError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * A prompt is invalid. This error should be thrown by providers when they cannot\n * process a prompt.\n */\nexport class InvalidPromptError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly prompt: unknown;\n\n  constructor({\n    prompt,\n    message,\n    cause,\n  }: {\n    prompt: unknown;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message: `Invalid prompt: ${message}`, cause });\n\n    this.prompt = prompt;\n  }\n\n  static isInstance(error: unknown): error is InvalidPromptError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_InvalidResponseDataError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * Server returned a response with invalid data content.\n * This should be thrown by providers when they cannot parse the response from the API.\n */\nexport class InvalidResponseDataError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly data: unknown;\n\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`,\n  }: {\n    data: unknown;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.data = data;\n  }\n\n  static isInstance(error: unknown): error is InvalidResponseDataError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_JSONParseError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n// TODO v5: rename to ParseError\nexport class JSONParseError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly text: string;\n\n  constructor({ text, cause }: { text: string; cause: unknown }) {\n    super({\n      name,\n      message:\n        `JSON parsing failed: ` +\n        `Text: ${text}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.text = text;\n  }\n\n  static isInstance(error: unknown): error is JSONParseError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadAPIKeyError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadAPIKeyError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadAPIKeyError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_LoadSettingError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class LoadSettingError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message }: { message: string }) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is LoadSettingError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoContentGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when the AI provider fails to generate any content.\n */\nexport class NoContentGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No content generated.',\n  }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoContentGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_NoSuchModelError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchModelError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly modelId: string;\n  readonly modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n\n  constructor({\n    errorName = name,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`,\n  }: {\n    errorName?: string;\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel';\n    message?: string;\n  }) {\n    super({ name: errorName, message });\n\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n\n  static isInstance(error: unknown): error is NoSuchModelError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_TooManyEmbeddingValuesForCallError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TooManyEmbeddingValuesForCallError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly provider: string;\n  readonly modelId: string;\n  readonly maxEmbeddingsPerCall: number;\n  readonly values: Array<unknown>;\n\n  constructor(options: {\n    provider: string;\n    modelId: string;\n    maxEmbeddingsPerCall: number;\n    values: Array<unknown>;\n  }) {\n    super({\n      name,\n      message:\n        `Too many values for a single embedding call. ` +\n        `The ${options.provider} model \"${options.modelId}\" can only embed up to ` +\n        `${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`,\n    });\n\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n\n  static isInstance(\n    error: unknown,\n  ): error is TooManyEmbeddingValuesForCallError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\nimport { getErrorMessage } from './get-error-message';\n\nconst name = 'AI_TypeValidationError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class TypeValidationError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly value: unknown;\n\n  constructor({ value, cause }: { value: unknown; cause: unknown }) {\n    super({\n      name,\n      message:\n        `Type validation failed: ` +\n        `Value: ${JSON.stringify(value)}.\\n` +\n        `Error message: ${getErrorMessage(cause)}`,\n      cause,\n    });\n\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is TypeValidationError {\n    return AISDKError.hasMarker(error, marker);\n  }\n\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause,\n  }: {\n    value: unknown;\n    cause: unknown;\n  }): TypeValidationError {\n    return TypeValidationError.isInstance(cause) && cause.value === value\n      ? cause\n      : new TypeValidationError({ value, cause });\n  }\n}\n", "import { AISDKError } from './ai-sdk-error';\n\nconst name = 'AI_UnsupportedFunctionalityError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class UnsupportedFunctionalityError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly functionality: string;\n\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`,\n  }: {\n    functionality: string;\n    message?: string;\n  }) {\n    super({ name, message });\n    this.functionality = functionality;\n  }\n\n  static isInstance(error: unknown): error is UnsupportedFunctionalityError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { JSONArray, JSONObject, JSONValue } from './json-value';\n\nexport function isJSONValue(value: unknown): value is JSONValue {\n  if (\n    value === null ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n\n  if (typeof value === 'object') {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    );\n  }\n\n  return false;\n}\n\nexport function isJSONArray(value: unknown): value is JSONArray {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\n\nexport function isJSONObject(value: unknown): value is JSONObject {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Object.entries(value).every(\n      ([key, val]) => typeof key === 'string' && isJSONValue(val),\n    )\n  );\n}\n", "let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n", "export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n", "/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n", "/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n", "export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n      if (chunk[i] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n", "/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n", "import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n", "export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { FetchFunction } from './fetch-function';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\nimport { isAbortError } from './is-abort-error';\nimport { extractResponseHeaders } from './extract-response-headers';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {},\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n", "/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n", "export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n", "import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n", "/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n", "import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n", "import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n", "import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n", "import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n", "import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postFormDataToApi = async <T>({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  formData: FormData;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers,\n    body: {\n      content: formData,\n      values: Object.fromEntries((formData as any).entries()),\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n", "export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n", "import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n", "// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n", "export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n", "export * from \"./Options.js\";\nexport * from \"./Refs.js\";\nexport * from \"./errorMessages.js\";\nexport * from \"./parseDef.js\";\nexport * from \"./parseTypes.js\";\nexport * from \"./parsers/any.js\";\nexport * from \"./parsers/array.js\";\nexport * from \"./parsers/bigint.js\";\nexport * from \"./parsers/boolean.js\";\nexport * from \"./parsers/branded.js\";\nexport * from \"./parsers/catch.js\";\nexport * from \"./parsers/date.js\";\nexport * from \"./parsers/default.js\";\nexport * from \"./parsers/effects.js\";\nexport * from \"./parsers/enum.js\";\nexport * from \"./parsers/intersection.js\";\nexport * from \"./parsers/literal.js\";\nexport * from \"./parsers/map.js\";\nexport * from \"./parsers/nativeEnum.js\";\nexport * from \"./parsers/never.js\";\nexport * from \"./parsers/null.js\";\nexport * from \"./parsers/nullable.js\";\nexport * from \"./parsers/number.js\";\nexport * from \"./parsers/object.js\";\nexport * from \"./parsers/optional.js\";\nexport * from \"./parsers/pipeline.js\";\nexport * from \"./parsers/promise.js\";\nexport * from \"./parsers/readonly.js\";\nexport * from \"./parsers/record.js\";\nexport * from \"./parsers/set.js\";\nexport * from \"./parsers/string.js\";\nexport * from \"./parsers/tuple.js\";\nexport * from \"./parsers/undefined.js\";\nexport * from \"./parsers/union.js\";\nexport * from \"./parsers/unknown.js\";\nexport * from \"./selectParser.js\";\nexport * from \"./zodToJsonSchema.js\";\nimport { zodToJsonSchema } from \"./zodToJsonSchema.js\";\nexport default zodToJsonSchema;\n", "export const ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nexport const jsonDescription = (jsonSchema, def) => {\n    if (def.description) {\n        try {\n            return {\n                ...jsonSchema,\n                ...JSON.parse(def.description),\n            };\n        }\n        catch { }\n    }\n    return jsonSchema;\n};\nexport const defaultOptions = {\n    name: undefined,\n    $refStrategy: \"root\",\n    basePath: [\"#\"],\n    effectStrategy: \"input\",\n    pipeStrategy: \"all\",\n    dateStrategy: \"format:date-time\",\n    mapStrategy: \"entries\",\n    removeAdditionalStrategy: \"passthrough\",\n    allowedAdditionalProperties: true,\n    rejectedAdditionalProperties: false,\n    definitionPath: \"definitions\",\n    target: \"jsonSchema7\",\n    strictUnions: false,\n    definitions: {},\n    errorMessages: false,\n    markdownDescription: false,\n    patternStrategy: \"escape\",\n    applyRegexFlags: false,\n    emailStrategy: \"format:email\",\n    base64Strategy: \"contentEncoding:base64\",\n    nameStrategy: \"ref\",\n};\nexport const getDefaultOptions = (options) => (typeof options === \"string\"\n    ? {\n        ...defaultOptions,\n        name: options,\n    }\n    : {\n        ...defaultOptions,\n        ...options,\n    });\n", "import { getDefaultOptions } from \"./Options.js\";\nexport const getRefs = (options) => {\n    const _options = getDefaultOptions(options);\n    const currentPath = _options.name !== undefined\n        ? [..._options.basePath, _options.definitionPath, _options.name]\n        : _options.basePath;\n    return {\n        ..._options,\n        currentPath: currentPath,\n        propertyPath: undefined,\n        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n            def._def,\n            {\n                def: def._def,\n                path: [..._options.basePath, _options.definitionPath, name],\n                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                jsonSchema: undefined,\n            },\n        ])),\n    };\n};\n", "export function addErrorMessage(res, key, errorMessage, refs) {\n    if (!refs?.errorMessages)\n        return;\n    if (errorMessage) {\n        res.errorMessage = {\n            ...res.errorMessage,\n            [key]: errorMessage,\n        };\n    }\n}\nexport function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n    res[key] = value;\n    addErrorMessage(res, key, errorMessage, refs);\n}\n", "import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n    const jsonSchema = typeof jsonSchemaOrGetter === \"function\"\n        ? parseDef(jsonSchemaOrGetter(), refs)\n        : jsonSchemaOrGetter;\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    if (refs.postProcess) {\n        const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n        newItem.jsonSchema = jsonSchema;\n        return postProcessResult;\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return {};\n            }\n            return refs.$refStrategy === \"seen\" ? {} : undefined;\n        }\n    }\n};\nconst getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n", "import { ZodFirstPartyTypeKind } from \"zod\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nexport const selectParser = (def, typeName, refs) => {\n    switch (typeName) {\n        case ZodFirstPartyTypeKind.ZodString:\n            return parseStringDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNumber:\n            return parseNumberDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodObject:\n            return parseObjectDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBigInt:\n            return parseBigintDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBoolean:\n            return parseBooleanDef();\n        case ZodFirstPartyTypeKind.ZodDate:\n            return parseDateDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUndefined:\n            return parseUndefinedDef();\n        case ZodFirstPartyTypeKind.ZodNull:\n            return parseNullDef(refs);\n        case ZodFirstPartyTypeKind.ZodArray:\n            return parseArrayDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUnion:\n        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n            return parseUnionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodIntersection:\n            return parseIntersectionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodTuple:\n            return parseTupleDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodRecord:\n            return parseRecordDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLiteral:\n            return parseLiteralDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodEnum:\n            return parseEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNativeEnum:\n            return parseNativeEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNullable:\n            return parseNullableDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodOptional:\n            return parseOptionalDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodMap:\n            return parseMapDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodSet:\n            return parseSetDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLazy:\n            return () => def.getter()._def;\n        case ZodFirstPartyTypeKind.ZodPromise:\n            return parsePromiseDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNaN:\n        case ZodFirstPartyTypeKind.ZodNever:\n            return parseNeverDef();\n        case ZodFirstPartyTypeKind.ZodEffects:\n            return parseEffectsDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodAny:\n            return parseAnyDef();\n        case ZodFirstPartyTypeKind.ZodUnknown:\n            return parseUnknownDef();\n        case ZodFirstPartyTypeKind.ZodDefault:\n            return parseDefaultDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBranded:\n            return parseBrandedDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodReadonly:\n            return parseReadonlyDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodCatch:\n            return parseCatchDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodPipeline:\n            return parsePipelineDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodFunction:\n        case ZodFirstPartyTypeKind.ZodVoid:\n        case ZodFirstPartyTypeKind.ZodSymbol:\n            return undefined;\n        default:\n            /* c8 ignore next */\n            return ((_) => undefined)(typeName);\n    }\n};\n", "export function parseAnyDef() {\n    return {};\n}\n", "import { ZodFirstPartyTypeKind } from \"zod\";\nimport { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseArrayDef(def, refs) {\n    const res = {\n        type: \"array\",\n    };\n    if (def.type?._def &&\n        def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n        res.items = parseDef(def.type._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\"],\n        });\n    }\n    if (def.minLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n    }\n    if (def.maxLength) {\n        setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n    }\n    if (def.exactLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n        setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n    }\n    return res;\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseBigintDef(def, refs) {\n    const res = {\n        type: \"integer\",\n        format: \"int64\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n", "export function parseBooleanDef() {\n    return {\n        type: \"boolean\",\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseBrandedDef(_def, refs) {\n    return parseDef(_def.type._def, refs);\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const parseCatchDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseDateDef(def, refs, overrideDateStrategy) {\n    const strategy = overrideDateStrategy ?? refs.dateStrategy;\n    if (Array.isArray(strategy)) {\n        return {\n            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n        };\n    }\n    switch (strategy) {\n        case \"string\":\n        case \"format:date-time\":\n            return {\n                type: \"string\",\n                format: \"date-time\",\n            };\n        case \"format:date\":\n            return {\n                type: \"string\",\n                format: \"date\",\n            };\n        case \"integer\":\n            return integerDateParser(def, refs);\n    }\n}\nconst integerDateParser = (def, refs) => {\n    const res = {\n        type: \"integer\",\n        format: \"unix-time\",\n    };\n    if (refs.target === \"openApi3\") {\n        return res;\n    }\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                setResponseValueAndErrors(res, \"minimum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n            case \"max\":\n                setResponseValueAndErrors(res, \"maximum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n        }\n    }\n    return res;\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseDefaultDef(_def, refs) {\n    return {\n        ...parseDef(_def.innerType._def, refs),\n        default: _def.defaultValue(),\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseEffectsDef(_def, refs) {\n    return refs.effectStrategy === \"input\"\n        ? parseDef(_def.schema._def, refs)\n        : {};\n}\n", "export function parseEnumDef(def) {\n    return {\n        type: \"string\",\n        enum: Array.from(def.values),\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n", "export function parseLiteralDef(def, refs) {\n    const parsedType = typeof def.value;\n    if (parsedType !== \"bigint\" &&\n        parsedType !== \"number\" &&\n        parsedType !== \"boolean\" &&\n        parsedType !== \"string\") {\n        return {\n            type: Array.isArray(def.value) ? \"array\" : \"object\",\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        return {\n            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n            enum: [def.value],\n        };\n    }\n    return {\n        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n        const: def.value,\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { parseRecordDef } from \"./record.js\";\nexport function parseMapDef(def, refs) {\n    if (refs.mapStrategy === \"record\") {\n        return parseRecordDef(def, refs);\n    }\n    const keys = parseDef(def.keyType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n    }) || {};\n    const values = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n    }) || {};\n    return {\n        type: \"array\",\n        maxItems: 125,\n        items: {\n            type: \"array\",\n            items: [keys, values],\n            minItems: 2,\n            maxItems: 2,\n        },\n    };\n}\n", "import { ZodFirstPartyTypeKind, } from \"zod\";\nimport { parseDef } from \"../parseDef.js\";\nimport { parseStringDef } from \"./string.js\";\nimport { parseBrandedDef } from \"./branded.js\";\nexport function parseRecordDef(def, refs) {\n    if (refs.target === \"openAi\") {\n        console.warn(\"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\");\n    }\n    if (refs.target === \"openApi3\" &&\n        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            type: \"object\",\n            required: def.keyType._def.values,\n            properties: def.keyType._def.values.reduce((acc, key) => ({\n                ...acc,\n                [key]: parseDef(def.valueType._def, {\n                    ...refs,\n                    currentPath: [...refs.currentPath, \"properties\", key],\n                }) ?? {},\n            }), {}),\n            additionalProperties: refs.rejectedAdditionalProperties,\n        };\n    }\n    const schema = {\n        type: \"object\",\n        additionalProperties: parseDef(def.valueType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        }) ?? refs.allowedAdditionalProperties,\n    };\n    if (refs.target === \"openApi3\") {\n        return schema;\n    }\n    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.checks?.length) {\n        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            ...schema,\n            propertyNames: {\n                enum: def.keyType._def.values,\n            },\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n        def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.type._def.checks?.length) {\n        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    return schema;\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n    jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"base64url\":\n                    addPattern(res, zodPatterns.base64url, check.message, refs);\n                    break;\n                case \"jwt\":\n                    addPattern(res, zodPatterns.jwt, check.message, refs);\n                    break;\n                case \"cidr\": {\n                    if (check.version !== \"v6\") {\n                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji(), check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    /* c8 ignore next */\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n    return refs.patternStrategy === \"escape\"\n        ? escapeNonAlphaNumeric(literal)\n        : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n    let result = \"\";\n    for (let i = 0; i < source.length; i++) {\n        if (!ALPHA_NUMERIC.has(source[i])) {\n            result += \"\\\\\";\n        }\n        result += source[i];\n    }\n    return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: stringifyRegExpWithFlags(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n    }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n    if (!refs.applyRegexFlags || !regex.flags) {\n        return regex.source;\n    }\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n}\n", "export function parseNativeEnumDef(def) {\n    const object = def.values;\n    const actualKeys = Object.keys(def.values).filter((key) => {\n        return typeof object[object[key]] !== \"number\";\n    });\n    const actualValues = actualKeys.map((key) => object[key]);\n    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n    return {\n        type: parsedTypes.length === 1\n            ? parsedTypes[0] === \"string\"\n                ? \"string\"\n                : \"number\"\n            : [\"string\", \"number\"],\n        enum: actualValues,\n    };\n}\n", "export function parseNeverDef() {\n    return {\n        not: {},\n    };\n}\n", "export function parseNullDef(refs) {\n    return refs.target === \"openApi3\"\n        ? {\n            enum: [\"null\"],\n            nullable: true,\n        }\n        : {\n            type: \"null\",\n        };\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { primitiveMappings } from \"./union.js\";\nexport function parseNullableDef(def, refs) {\n    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n        if (refs.target === \"openApi3\") {\n            return {\n                type: primitiveMappings[def.innerType._def.typeName],\n                nullable: true,\n            };\n        }\n        return {\n            type: [\n                primitiveMappings[def.innerType._def.typeName],\n                \"null\",\n            ],\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        const base = parseDef(def.innerType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath],\n        });\n        if (base && \"$ref\" in base)\n            return { allOf: [base], nullable: true };\n        return base && { ...base, nullable: true };\n    }\n    const base = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n    });\n    return base && { anyOf: [base, { type: \"null\" }] };\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n", "import { addErrorMessage, setResponseValueAndErrors, } from \"../errorMessages.js\";\nexport function parseNumberDef(def, refs) {\n    const res = {\n        type: \"number\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"int\":\n                res.type = \"integer\";\n                addErrorMessage(res, \"type\", check.message, refs);\n                break;\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n", "import { ZodOptional } from \"zod\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseObjectDef(def, refs) {\n    const forceOptionalIntoNullable = refs.target === \"openAi\";\n    const result = {\n        type: \"object\",\n        properties: {},\n    };\n    const required = [];\n    const shape = def.shape();\n    for (const propName in shape) {\n        let propDef = shape[propName];\n        if (propDef === undefined || propDef._def === undefined) {\n            continue;\n        }\n        let propOptional = safeIsOptional(propDef);\n        if (propOptional && forceOptionalIntoNullable) {\n            if (propDef instanceof ZodOptional) {\n                propDef = propDef._def.innerType;\n            }\n            if (!propDef.isNullable()) {\n                propDef = propDef.nullable();\n            }\n            propOptional = false;\n        }\n        const parsedDef = parseDef(propDef._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"properties\", propName],\n            propertyPath: [...refs.currentPath, \"properties\", propName],\n        });\n        if (parsedDef === undefined) {\n            continue;\n        }\n        result.properties[propName] = parsedDef;\n        if (!propOptional) {\n            required.push(propName);\n        }\n    }\n    if (required.length) {\n        result.required = required;\n    }\n    const additionalProperties = decideAdditionalProperties(def, refs);\n    if (additionalProperties !== undefined) {\n        result.additionalProperties = additionalProperties;\n    }\n    return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n    if (def.catchall._def.typeName !== \"ZodNever\") {\n        return parseDef(def.catchall._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        });\n    }\n    switch (def.unknownKeys) {\n        case \"passthrough\":\n            return refs.allowedAdditionalProperties;\n        case \"strict\":\n            return refs.rejectedAdditionalProperties;\n        case \"strip\":\n            return refs.removeAdditionalStrategy === \"strict\"\n                ? refs.allowedAdditionalProperties\n                : refs.rejectedAdditionalProperties;\n    }\n}\nfunction safeIsOptional(schema) {\n    try {\n        return schema.isOptional();\n    }\n    catch {\n        return true;\n    }\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const parseOptionalDef = (def, refs) => {\n    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n        return parseDef(def.innerType._def, refs);\n    }\n    const innerSchema = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n    });\n    return innerSchema\n        ? {\n            anyOf: [\n                {\n                    not: {},\n                },\n                innerSchema,\n            ],\n        }\n        : {};\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport const parsePipelineDef = (def, refs) => {\n    if (refs.pipeStrategy === \"input\") {\n        return parseDef(def.in._def, refs);\n    }\n    else if (refs.pipeStrategy === \"output\") {\n        return parseDef(def.out._def, refs);\n    }\n    const a = parseDef(def.in._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    });\n    const b = parseDef(def.out._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n    });\n    return {\n        allOf: [a, b].filter((x) => x !== undefined),\n    };\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport function parsePromiseDef(def, refs) {\n    return parseDef(def.type._def, refs);\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseSetDef(def, refs) {\n    const items = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\"],\n    });\n    const schema = {\n        type: \"array\",\n        uniqueItems: true,\n        items,\n    };\n    if (def.minSize) {\n        setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n    }\n    if (def.maxSize) {\n        setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n    }\n    return schema;\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseTupleDef(def, refs) {\n    if (def.rest) {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n            additionalItems: parseDef(def.rest._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalItems\"],\n            }),\n        };\n    }\n    else {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            maxItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n        };\n    }\n}\n", "export function parseUndefinedDef() {\n    return {\n        not: {},\n    };\n}\n", "export function parseUnknownDef() {\n    return {};\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const parseReadonlyDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n", "export {};\n", "import { parseDef } from \"./parseDef.js\";\nimport { getRefs } from \"./Refs.js\";\nconst zodToJsonSchema = (schema, options) => {\n    const refs = getRefs(options);\n    const definitions = typeof options === \"object\" && options.definitions\n        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n            ...acc,\n            [name]: parseDef(schema._def, {\n                ...refs,\n                currentPath: [...refs.basePath, refs.definitionPath, name],\n            }, true) ?? {},\n        }), {})\n        : undefined;\n    const name = typeof options === \"string\"\n        ? options\n        : options?.nameStrategy === \"title\"\n            ? undefined\n            : options?.name;\n    const main = parseDef(schema._def, name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n        }, false) ?? {};\n    const title = typeof options === \"object\" &&\n        options.name !== undefined &&\n        options.nameStrategy === \"title\"\n        ? options.name\n        : undefined;\n    if (title !== undefined) {\n        main.title = title;\n    }\n    const combined = name === undefined\n        ? definitions\n            ? {\n                ...main,\n                [refs.definitionPath]: definitions,\n            }\n            : main\n        : {\n            $ref: [\n                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n                refs.definitionPath,\n                name,\n            ].join(\"/\"),\n            [refs.definitionPath]: {\n                ...definitions,\n                [name]: main,\n            },\n        };\n    if (refs.target === \"jsonSchema7\") {\n        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n    }\n    if (refs.target === \"openAi\" &&\n        (\"anyOf\" in combined ||\n            \"oneOf\" in combined ||\n            \"allOf\" in combined ||\n            (\"type\" in combined && Array.isArray(combined.type)))) {\n        console.warn(\"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\");\n    }\n    return combined;\n};\nexport { zodToJsonSchema };\n", "export * from './types';\n\nexport { generateId } from '@ai-sdk/provider-utils';\n\n// Export stream data utilities for custom stream implementations,\n// both on the client and server side.\n// NOTE: this is experimental / internal and may change without notice\nexport {\n  formatAssistantStreamPart,\n  parseAssistantStreamPart,\n} from './assistant-stream-parts';\nexport type {\n  AssistantStreamPart,\n  AssistantStreamString,\n} from './assistant-stream-parts';\nexport { callChatApi } from './call-chat-api';\nexport { callCompletionApi } from './call-completion-api';\nexport { formatDataStreamPart, parseDataStreamPart } from './data-stream-parts';\nexport type { DataStreamPart, DataStreamString } from './data-stream-parts';\nexport { getTextFromDataUrl } from './data-url';\nexport type { DeepPartial } from './deep-partial';\nexport { extractMaxToolInvocationStep } from './extract-max-tool-invocation-step';\nexport { fillMessageParts } from './fill-message-parts';\nexport { getMessageParts } from './get-message-parts';\nexport { isDeepEqualData } from './is-deep-equal-data';\nexport { parsePartialJson } from './parse-partial-json';\nexport { prepareAttachmentsForRequest } from './prepare-attachments-for-request';\nexport { processAssistantStream } from './process-assistant-stream';\nexport { processDataStream } from './process-data-stream';\nexport { processTextStream } from './process-text-stream';\nexport { asSchema, jsonSchema } from './schema';\nexport type { Schema } from './schema';\nexport {\n  isAssistantMessageWithCompletedToolCalls,\n  shouldResubmitMessages,\n} from './should-resubmit-messages';\nexport { updateToolCallResult } from './update-tool-call-result';\nexport { zodSchema } from './zod-schema';\n", "import { AssistantMessage, DataMessage, JSONValue } from './types';\n\nexport type AssistantStreamString =\n  `${(typeof StreamStringPrefixes)[keyof typeof StreamStringPrefixes]}:${string}\\n`;\n\nexport interface AssistantStreamPart<\n  CODE extends string,\n  NAME extends string,\n  TYPE,\n> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: AssistantStreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst errorStreamPart: AssistantStreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst assistantMessageStreamPart: AssistantStreamPart<\n  '4',\n  'assistant_message',\n  AssistantMessage\n> = {\n  code: '4',\n  name: 'assistant_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('id' in value) ||\n      !('role' in value) ||\n      !('content' in value) ||\n      typeof value.id !== 'string' ||\n      typeof value.role !== 'string' ||\n      value.role !== 'assistant' ||\n      !Array.isArray(value.content) ||\n      !value.content.every(\n        item =>\n          item != null &&\n          typeof item === 'object' &&\n          'type' in item &&\n          item.type === 'text' &&\n          'text' in item &&\n          item.text != null &&\n          typeof item.text === 'object' &&\n          'value' in item.text &&\n          typeof item.text.value === 'string',\n      )\n    ) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_message',\n      value: value as AssistantMessage,\n    };\n  },\n};\n\nconst assistantControlDataStreamPart: AssistantStreamPart<\n  '5',\n  'assistant_control_data',\n  {\n    threadId: string;\n    messageId: string;\n  }\n> = {\n  code: '5',\n  name: 'assistant_control_data',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('threadId' in value) ||\n      !('messageId' in value) ||\n      typeof value.threadId !== 'string' ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.',\n      );\n    }\n\n    return {\n      type: 'assistant_control_data',\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst dataMessageStreamPart: AssistantStreamPart<\n  '6',\n  'data_message',\n  DataMessage\n> = {\n  code: '6',\n  name: 'data_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('role' in value) ||\n      !('data' in value) ||\n      typeof value.role !== 'string' ||\n      value.role !== 'data'\n    ) {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.',\n      );\n    }\n\n    return {\n      type: 'data_message',\n      value: value as DataMessage,\n    };\n  },\n};\n\nconst assistantStreamParts = [\n  textStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n] as const;\n\ntype AssistantStreamParts =\n  | typeof textStreamPart\n  | typeof errorStreamPart\n  | typeof assistantMessageStreamPart\n  | typeof assistantControlDataStreamPart\n  | typeof dataMessageStreamPart;\n\ntype AssistantStreamPartValueType = {\n  [P in AssistantStreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type AssistantStreamPartType =\n  | ReturnType<typeof textStreamPart.parse>\n  | ReturnType<typeof errorStreamPart.parse>\n  | ReturnType<typeof assistantMessageStreamPart.parse>\n  | ReturnType<typeof assistantControlDataStreamPart.parse>\n  | ReturnType<typeof dataMessageStreamPart.parse>;\n\nexport const assistantStreamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n} as const;\n\nexport const StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n} as const;\n\nexport const validCodes = assistantStreamParts.map(part => part.code);\n\nexport const parseAssistantStreamPart = (\n  line: string,\n): AssistantStreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof assistantStreamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof assistantStreamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return assistantStreamPartsByCode[code].parse(jsonValue);\n};\n\nexport function formatAssistantStreamPart<\n  T extends keyof AssistantStreamPartValueType,\n>(type: T, value: AssistantStreamPartValueType[T]): AssistantStreamString {\n  const streamPart = assistantStreamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n", "import { LanguageModelV1FinishReason } from '@ai-sdk/provider';\nimport { generateId as generateIdFunction } from '@ai-sdk/provider-utils';\nimport {\n  calculateLanguageModelUsage,\n  LanguageModelUsage,\n} from './duplicated/usage';\nimport { parsePartialJson } from './parse-partial-json';\nimport { processDataStream } from './process-data-stream';\nimport type {\n  JSONValue,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolInvocation,\n  ToolInvocationUIPart,\n  UIMessage,\n  UseChatOptions,\n} from './types';\n\nexport async function processChatResponse({\n  stream,\n  update,\n  onToolCall,\n  onFinish,\n  generateId = generateIdFunction,\n  getCurrentDate = () => new Date(),\n  lastMessage,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  update: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onToolCall?: UseChatOptions['onToolCall'];\n  onFinish?: (options: {\n    message: UIMessage | undefined;\n    finishReason: LanguageModelV1FinishReason;\n    usage: LanguageModelUsage;\n  }) => void;\n  generateId?: () => string;\n  getCurrentDate?: () => Date;\n  lastMessage: UIMessage | undefined;\n}) {\n  const replaceLastMessage = lastMessage?.role === 'assistant';\n  let step = replaceLastMessage\n    ? 1 +\n      // find max step in existing tool invocations:\n      (lastMessage.toolInvocations?.reduce((max, toolInvocation) => {\n        return Math.max(max, toolInvocation.step ?? 0);\n      }, 0) ?? 0)\n    : 0;\n\n  const message: UIMessage = replaceLastMessage\n    ? structuredClone(lastMessage)\n    : {\n        id: generateId(),\n        createdAt: getCurrentDate(),\n        role: 'assistant',\n        content: '',\n        parts: [],\n      };\n\n  let currentTextPart: TextUIPart | undefined = undefined;\n  let currentReasoningPart: ReasoningUIPart | undefined = undefined;\n  let currentReasoningTextDetail:\n    | { type: 'text'; text: string; signature?: string }\n    | undefined = undefined;\n\n  function updateToolInvocationPart(\n    toolCallId: string,\n    invocation: ToolInvocation,\n  ) {\n    const part = message.parts.find(\n      part =>\n        part.type === 'tool-invocation' &&\n        part.toolInvocation.toolCallId === toolCallId,\n    ) as ToolInvocationUIPart | undefined;\n\n    if (part != null) {\n      part.toolInvocation = invocation;\n    } else {\n      message.parts.push({\n        type: 'tool-invocation',\n        toolInvocation: invocation,\n      });\n    }\n  }\n\n  const data: JSONValue[] = [];\n\n  // keep list of current message annotations for message\n  let messageAnnotations: JSONValue[] | undefined = replaceLastMessage\n    ? lastMessage?.annotations\n    : undefined;\n\n  // keep track of partial tool calls\n  const partialToolCalls: Record<\n    string,\n    { text: string; step: number; index: number; toolName: string }\n  > = {};\n\n  let usage: LanguageModelUsage = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN,\n  };\n  let finishReason: LanguageModelV1FinishReason = 'unknown';\n\n  function execUpdate() {\n    // make a copy of the data array to ensure UI is updated (SWR)\n    const copiedData = [...data];\n\n    // keeps the currentMessage up to date with the latest annotations,\n    // even if annotations preceded the message creation\n    if (messageAnnotations?.length) {\n      message.annotations = messageAnnotations;\n    }\n\n    const copiedMessage = {\n      // deep copy the message to ensure that deep changes (msg attachments) are updated\n      // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n      ...structuredClone(message),\n      // add a revision id to ensure that the message is updated with SWR. SWR uses a\n      // hashing approach by default to detect changes, but it only works for shallow\n      // changes. This is why we need to add a revision id to ensure that the message\n      // is updated with SWR (without it, the changes get stuck in SWR and are not\n      // forwarded to rendering):\n      revisionId: generateId(),\n    } as UIMessage;\n\n    update({\n      message: copiedMessage,\n      data: copiedData,\n      replaceLastMessage,\n    });\n  }\n\n  await processDataStream({\n    stream,\n    onTextPart(value) {\n      if (currentTextPart == null) {\n        currentTextPart = {\n          type: 'text',\n          text: value,\n        };\n        message.parts.push(currentTextPart);\n      } else {\n        currentTextPart.text += value;\n      }\n\n      message.content += value;\n      execUpdate();\n    },\n    onReasoningPart(value) {\n      if (currentReasoningTextDetail == null) {\n        currentReasoningTextDetail = { type: 'text', text: value };\n        if (currentReasoningPart != null) {\n          currentReasoningPart.details.push(currentReasoningTextDetail);\n        }\n      } else {\n        currentReasoningTextDetail.text += value;\n      }\n\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: 'reasoning',\n          reasoning: value,\n          details: [currentReasoningTextDetail],\n        };\n        message.parts.push(currentReasoningPart);\n      } else {\n        currentReasoningPart.reasoning += value;\n      }\n\n      message.reasoning = (message.reasoning ?? '') + value;\n\n      execUpdate();\n    },\n    onReasoningSignaturePart(value) {\n      if (currentReasoningTextDetail != null) {\n        currentReasoningTextDetail.signature = value.signature;\n      }\n    },\n    onRedactedReasoningPart(value) {\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: 'reasoning',\n          reasoning: '',\n          details: [],\n        };\n        message.parts.push(currentReasoningPart);\n      }\n\n      currentReasoningPart.details.push({\n        type: 'redacted',\n        data: value.data,\n      });\n\n      currentReasoningTextDetail = undefined;\n\n      execUpdate();\n    },\n    onFilePart(value) {\n      message.parts.push({\n        type: 'file',\n        mimeType: value.mimeType,\n        data: value.data,\n      });\n\n      execUpdate();\n    },\n    onSourcePart(value) {\n      message.parts.push({\n        type: 'source',\n        source: value,\n      });\n\n      execUpdate();\n    },\n    onToolCallStreamingStartPart(value) {\n      if (message.toolInvocations == null) {\n        message.toolInvocations = [];\n      }\n\n      // add the partial tool call to the map\n      partialToolCalls[value.toolCallId] = {\n        text: '',\n        step,\n        toolName: value.toolName,\n        index: message.toolInvocations.length,\n      };\n\n      const invocation = {\n        state: 'partial-call',\n        step,\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: undefined,\n      } as const;\n\n      message.toolInvocations.push(invocation);\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    onToolCallDeltaPart(value) {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n\n      partialToolCall.text += value.argsTextDelta;\n\n      const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n\n      const invocation = {\n        state: 'partial-call',\n        step: partialToolCall.step,\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs,\n      } as const;\n\n      message.toolInvocations![partialToolCall.index] = invocation;\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    async onToolCallPart(value) {\n      const invocation = {\n        state: 'call',\n        step,\n        ...value,\n      } as const;\n\n      if (partialToolCalls[value.toolCallId] != null) {\n        // change the partial tool call to a full tool call\n        message.toolInvocations![partialToolCalls[value.toolCallId].index] =\n          invocation;\n      } else {\n        if (message.toolInvocations == null) {\n          message.toolInvocations = [];\n        }\n\n        message.toolInvocations.push(invocation);\n      }\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n\n      // invoke the onToolCall callback if it exists. This is blocking.\n      // In the future we should make this non-blocking, which\n      // requires additional state management for error handling etc.\n      if (onToolCall) {\n        const result = await onToolCall({ toolCall: value });\n        if (result != null) {\n          const invocation = {\n            state: 'result',\n            step,\n            ...value,\n            result,\n          } as const;\n\n          // store the result in the tool invocation\n          message.toolInvocations![message.toolInvocations!.length - 1] =\n            invocation;\n\n          updateToolInvocationPart(value.toolCallId, invocation);\n\n          execUpdate();\n        }\n      }\n    },\n    onToolResultPart(value) {\n      const toolInvocations = message.toolInvocations;\n\n      if (toolInvocations == null) {\n        throw new Error('tool_result must be preceded by a tool_call');\n      }\n\n      // find if there is any tool invocation with the same toolCallId\n      // and replace it with the result\n      const toolInvocationIndex = toolInvocations.findIndex(\n        invocation => invocation.toolCallId === value.toolCallId,\n      );\n\n      if (toolInvocationIndex === -1) {\n        throw new Error(\n          'tool_result must be preceded by a tool_call with the same toolCallId',\n        );\n      }\n\n      const invocation = {\n        ...toolInvocations[toolInvocationIndex],\n        state: 'result' as const,\n        ...value,\n      } as const;\n\n      toolInvocations[toolInvocationIndex] = invocation;\n\n      updateToolInvocationPart(value.toolCallId, invocation);\n\n      execUpdate();\n    },\n    onDataPart(value) {\n      data.push(...value);\n      execUpdate();\n    },\n    onMessageAnnotationsPart(value) {\n      if (messageAnnotations == null) {\n        messageAnnotations = [...value];\n      } else {\n        messageAnnotations.push(...value);\n      }\n\n      execUpdate();\n    },\n    onFinishStepPart(value) {\n      step += 1;\n\n      // reset the current text and reasoning parts\n      currentTextPart = value.isContinued ? currentTextPart : undefined;\n      currentReasoningPart = undefined;\n      currentReasoningTextDetail = undefined;\n    },\n    onStartStepPart(value) {\n      // keep message id stable when we are updating an existing message:\n      if (!replaceLastMessage) {\n        message.id = value.messageId;\n      }\n\n      // add a step boundary part to the message\n      message.parts.push({ type: 'step-start' });\n      execUpdate();\n    },\n    onFinishMessagePart(value) {\n      finishReason = value.finishReason;\n      if (value.usage != null) {\n        usage = calculateLanguageModelUsage(value.usage);\n      }\n    },\n    onErrorPart(error) {\n      throw new Error(error);\n    },\n  });\n\n  onFinish?.({ message, finishReason, usage });\n}\n", "/**\nRepresents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\nThe number of tokens used in the prompt.\n   */\n  promptTokens: number;\n\n  /**\nThe number of tokens used in the completion.\n */\n  completionTokens: number;\n\n  /**\nThe total number of tokens used (promptTokens + completionTokens).\n   */\n  totalTokens: number;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens,\n}: {\n  promptTokens: number;\n  completionTokens: number;\n}): LanguageModelUsage {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens,\n  };\n}\n", "import { JSONValue } from '@ai-sdk/provider';\nimport { safeParseJSON } from '@ai-sdk/provider-utils';\nimport { fixJson } from './fix-json';\n\nexport function parsePartialJson(jsonText: string | undefined): {\n  value: JSONValue | undefined;\n  state:\n    | 'undefined-input'\n    | 'successful-parse'\n    | 'repaired-parse'\n    | 'failed-parse';\n} {\n  if (jsonText === undefined) {\n    return { value: undefined, state: 'undefined-input' };\n  }\n\n  let result = safeParseJSON({ text: jsonText });\n\n  if (result.success) {\n    return { value: result.value, state: 'successful-parse' };\n  }\n\n  result = safeParseJSON({ text: fixJson(jsonText) });\n\n  if (result.success) {\n    return { value: result.value, state: 'repaired-parse' };\n  }\n\n  return { value: undefined, state: 'failed-parse' };\n}\n", "type State =\n  | 'ROOT'\n  | 'FINISH'\n  | 'INSIDE_STRING'\n  | 'INSIDE_STRING_ESCAPE'\n  | 'INSIDE_LITERAL'\n  | 'INSIDE_NUMBER'\n  | 'INSIDE_OBJECT_START'\n  | 'INSIDE_OBJECT_KEY'\n  | 'INSIDE_OBJECT_AFTER_KEY'\n  | 'INSIDE_OBJECT_BEFORE_VALUE'\n  | 'INSIDE_OBJECT_AFTER_VALUE'\n  | 'INSIDE_OBJECT_AFTER_COMMA'\n  | 'INSIDE_ARRAY_START'\n  | 'INSIDE_ARRAY_AFTER_VALUE'\n  | 'INSIDE_ARRAY_AFTER_COMMA';\n\n// Implemented as a scanner with additional fixing\n// that performs a single linear time scan pass over the partial JSON.\n//\n// The states should ideally match relevant states from the JSON spec:\n// https://www.json.org/json-en.html\n//\n// Please note that invalid JSON is not considered/covered, because it\n// is assumed that the resulting JSON will be processed by a standard\n// JSON parser that will detect any invalid JSON.\nexport function fixJson(input: string): string {\n  const stack: State[] = ['ROOT'];\n  let lastValidIndex = -1;\n  let literalStart: number | null = null;\n\n  function processValueStart(char: string, i: number, swapState: State) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_STRING');\n          break;\n        }\n\n        case 'f':\n        case 't':\n        case 'n': {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_LITERAL');\n          break;\n        }\n\n        case '-': {\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n\n        case '{': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_OBJECT_START');\n          break;\n        }\n\n        case '[': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_ARRAY_START');\n          break;\n        }\n      }\n    }\n  }\n\n  function processAfterObjectValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_OBJECT_AFTER_COMMA');\n        break;\n      }\n      case '}': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  function processAfterArrayValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_ARRAY_AFTER_COMMA');\n        break;\n      }\n      case ']': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n\n    switch (currentState) {\n      case 'ROOT':\n        processValueStart(char, i, 'FINISH');\n        break;\n\n      case 'INSIDE_OBJECT_START': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n          case '}': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_COMMA': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_AFTER_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_KEY': {\n        switch (char) {\n          case ':': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_BEFORE_VALUE');\n\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_BEFORE_VALUE': {\n        processValueStart(char, i, 'INSIDE_OBJECT_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        processAfterObjectValue(char, i);\n        break;\n      }\n\n      case 'INSIDE_STRING': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n\n          case '\\\\': {\n            stack.push('INSIDE_STRING_ESCAPE');\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START': {\n        switch (char) {\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        switch (char) {\n          case ',': {\n            stack.pop();\n            stack.push('INSIDE_ARRAY_AFTER_COMMA');\n            break;\n          }\n\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_COMMA': {\n        processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_STRING_ESCAPE': {\n        stack.pop();\n        lastValidIndex = i;\n\n        break;\n      }\n\n      case 'INSIDE_NUMBER': {\n        switch (char) {\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9': {\n            lastValidIndex = i;\n            break;\n          }\n\n          case 'e':\n          case 'E':\n          case '-':\n          case '.': {\n            break;\n          }\n\n          case ',': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case '}': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case ']': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            break;\n          }\n\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, i + 1);\n\n        if (\n          !'false'.startsWith(partialLiteral) &&\n          !'true'.startsWith(partialLiteral) &&\n          !'null'.startsWith(partialLiteral)\n        ) {\n          stack.pop();\n\n          if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n\n        break;\n      }\n    }\n  }\n\n  let result = input.slice(0, lastValidIndex + 1);\n\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n\n    switch (state) {\n      case 'INSIDE_STRING': {\n        result += '\"';\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY':\n      case 'INSIDE_OBJECT_AFTER_KEY':\n      case 'INSIDE_OBJECT_AFTER_COMMA':\n      case 'INSIDE_OBJECT_START':\n      case 'INSIDE_OBJECT_BEFORE_VALUE':\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        result += '}';\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START':\n      case 'INSIDE_ARRAY_AFTER_COMMA':\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        result += ']';\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, input.length);\n\n        if ('true'.startsWith(partialLiteral)) {\n          result += 'true'.slice(partialLiteral.length);\n        } else if ('false'.startsWith(partialLiteral)) {\n          result += 'false'.slice(partialLiteral.length);\n        } else if ('null'.startsWith(partialLiteral)) {\n          result += 'null'.slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n", "import {\n  LanguageModelV1FinishReason,\n  LanguageModelV1Source,\n} from '@ai-sdk/provider';\nimport { ToolCall, ToolResult } from '@ai-sdk/provider-utils';\nimport { JSONValue } from './types';\n\nexport type DataStreamString =\n  `${(typeof DataStreamStringPrefixes)[keyof typeof DataStreamStringPrefixes]}:${string}\\n`;\n\nexport interface DataStreamPart<\n  CODE extends string,\n  NAME extends string,\n  TYPE,\n> {\n  code: CODE;\n  name: NAME;\n  parse: (value: JSONValue) => { type: NAME; value: TYPE };\n}\n\nconst textStreamPart: DataStreamPart<'0', 'text', string> = {\n  code: '0',\n  name: 'text',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: 'text', value };\n  },\n};\n\nconst dataStreamPart: DataStreamPart<'2', 'data', Array<JSONValue>> = {\n  code: '2',\n  name: 'data',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n\n    return { type: 'data', value };\n  },\n};\n\nconst errorStreamPart: DataStreamPart<'3', 'error', string> = {\n  code: '3',\n  name: 'error',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: 'error', value };\n  },\n};\n\nconst messageAnnotationsStreamPart: DataStreamPart<\n  '8',\n  'message_annotations',\n  Array<JSONValue>\n> = {\n  code: '8',\n  name: 'message_annotations',\n  parse: (value: JSONValue) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n\n    return { type: 'message_annotations', value };\n  },\n};\n\nconst toolCallStreamPart: DataStreamPart<\n  '9',\n  'tool_call',\n  ToolCall<string, any>\n> = {\n  code: '9',\n  name: 'tool_call',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string' ||\n      !('args' in value) ||\n      typeof value.args !== 'object'\n    ) {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call',\n      value: value as unknown as ToolCall<string, any>,\n    };\n  },\n};\n\nconst toolResultStreamPart: DataStreamPart<\n  'a',\n  'tool_result',\n  Omit<ToolResult<string, any, any>, 'args' | 'toolName'>\n> = {\n  code: 'a',\n  name: 'tool_result',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('result' in value)\n    ) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_result',\n      value: value as unknown as Omit<\n        ToolResult<string, any, any>,\n        'args' | 'toolName'\n      >,\n    };\n  },\n};\n\nconst toolCallStreamingStartStreamPart: DataStreamPart<\n  'b',\n  'tool_call_streaming_start',\n  { toolCallId: string; toolName: string }\n> = {\n  code: 'b',\n  name: 'tool_call_streaming_start',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('toolName' in value) ||\n      typeof value.toolName !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_streaming_start',\n      value: value as unknown as { toolCallId: string; toolName: string },\n    };\n  },\n};\n\nconst toolCallDeltaStreamPart: DataStreamPart<\n  'c',\n  'tool_call_delta',\n  { toolCallId: string; argsTextDelta: string }\n> = {\n  code: 'c',\n  name: 'tool_call_delta',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('toolCallId' in value) ||\n      typeof value.toolCallId !== 'string' ||\n      !('argsTextDelta' in value) ||\n      typeof value.argsTextDelta !== 'string'\n    ) {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.',\n      );\n    }\n\n    return {\n      type: 'tool_call_delta',\n      value: value as unknown as {\n        toolCallId: string;\n        argsTextDelta: string;\n      },\n    };\n  },\n};\n\nconst finishMessageStreamPart: DataStreamPart<\n  'd',\n  'finish_message',\n  {\n    finishReason: LanguageModelV1FinishReason;\n    // TODO v5 remove usage from finish event (only on step-finish)\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'd',\n  name: 'finish_message',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    return {\n      type: 'finish_message',\n      value: result,\n    };\n  },\n};\n\nconst finishStepStreamPart: DataStreamPart<\n  'e',\n  'finish_step',\n  {\n    isContinued: boolean;\n    finishReason: LanguageModelV1FinishReason;\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n    };\n  }\n> = {\n  code: 'e',\n  name: 'finish_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('finishReason' in value) ||\n      typeof value.finishReason !== 'string'\n    ) {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.',\n      );\n    }\n\n    const result: {\n      isContinued: boolean;\n      finishReason: LanguageModelV1FinishReason;\n      usage?: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n    } = {\n      finishReason: value.finishReason as LanguageModelV1FinishReason,\n      isContinued: false,\n    };\n\n    if (\n      'usage' in value &&\n      value.usage != null &&\n      typeof value.usage === 'object' &&\n      'promptTokens' in value.usage &&\n      'completionTokens' in value.usage\n    ) {\n      result.usage = {\n        promptTokens:\n          typeof value.usage.promptTokens === 'number'\n            ? value.usage.promptTokens\n            : Number.NaN,\n        completionTokens:\n          typeof value.usage.completionTokens === 'number'\n            ? value.usage.completionTokens\n            : Number.NaN,\n      };\n    }\n\n    if ('isContinued' in value && typeof value.isContinued === 'boolean') {\n      result.isContinued = value.isContinued;\n    }\n\n    return {\n      type: 'finish_step',\n      value: result,\n    };\n  },\n};\n\nconst startStepStreamPart: DataStreamPart<\n  'f',\n  'start_step',\n  {\n    messageId: string;\n  }\n> = {\n  code: 'f',\n  name: 'start_step',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('messageId' in value) ||\n      typeof value.messageId !== 'string'\n    ) {\n      throw new Error(\n        '\"start_step\" parts expect an object with an \"id\" property.',\n      );\n    }\n\n    return {\n      type: 'start_step',\n      value: {\n        messageId: value.messageId,\n      },\n    };\n  },\n};\n\nconst reasoningStreamPart: DataStreamPart<'g', 'reasoning', string> = {\n  code: 'g',\n  name: 'reasoning',\n  parse: (value: JSONValue) => {\n    if (typeof value !== 'string') {\n      throw new Error('\"reasoning\" parts expect a string value.');\n    }\n    return { type: 'reasoning', value };\n  },\n};\n\nconst sourcePart: DataStreamPart<'h', 'source', LanguageModelV1Source> = {\n  code: 'h',\n  name: 'source',\n  parse: (value: JSONValue) => {\n    if (value == null || typeof value !== 'object') {\n      throw new Error('\"source\" parts expect a Source object.');\n    }\n\n    return {\n      type: 'source',\n      value: value as LanguageModelV1Source,\n    };\n  },\n};\n\nconst redactedReasoningStreamPart: DataStreamPart<\n  'i',\n  'redacted_reasoning',\n  { data: string }\n> = {\n  code: 'i',\n  name: 'redacted_reasoning',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('data' in value) ||\n      typeof value.data !== 'string'\n    ) {\n      throw new Error(\n        '\"redacted_reasoning\" parts expect an object with a \"data\" property.',\n      );\n    }\n    return { type: 'redacted_reasoning', value: { data: value.data } };\n  },\n};\n\nconst reasoningSignatureStreamPart: DataStreamPart<\n  'j',\n  'reasoning_signature',\n  { signature: string }\n> = {\n  code: 'j',\n  name: 'reasoning_signature',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('signature' in value) ||\n      typeof value.signature !== 'string'\n    ) {\n      throw new Error(\n        '\"reasoning_signature\" parts expect an object with a \"signature\" property.',\n      );\n    }\n    return {\n      type: 'reasoning_signature',\n      value: { signature: value.signature },\n    };\n  },\n};\n\nconst fileStreamPart: DataStreamPart<\n  'k',\n  'file',\n  {\n    data: string; // base64 encoded data\n    mimeType: string;\n  }\n> = {\n  code: 'k',\n  name: 'file',\n  parse: (value: JSONValue) => {\n    if (\n      value == null ||\n      typeof value !== 'object' ||\n      !('data' in value) ||\n      typeof value.data !== 'string' ||\n      !('mimeType' in value) ||\n      typeof value.mimeType !== 'string'\n    ) {\n      throw new Error(\n        '\"file\" parts expect an object with a \"data\" and \"mimeType\" property.',\n      );\n    }\n    return { type: 'file', value: value as { data: string; mimeType: string } };\n  },\n};\n\nconst dataStreamParts = [\n  textStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart,\n  startStepStreamPart,\n  reasoningStreamPart,\n  sourcePart,\n  redactedReasoningStreamPart,\n  reasoningSignatureStreamPart,\n  fileStreamPart,\n] as const;\n\nexport const dataStreamPartsByCode = Object.fromEntries(\n  dataStreamParts.map(part => [part.code, part]),\n) as {\n  [K in (typeof dataStreamParts)[number]['code']]: (typeof dataStreamParts)[number];\n};\n\ntype DataStreamParts = (typeof dataStreamParts)[number];\n\n/**\n * Maps the type of a stream part to its value type.\n */\ntype DataStreamPartValueType = {\n  [P in DataStreamParts as P['name']]: ReturnType<P['parse']>['value'];\n};\n\nexport type DataStreamPartType = ReturnType<DataStreamParts['parse']>;\n\n/**\n * The map of prefixes for data in the stream\n *\n * - 0: Text from the LLM response\n * - 1: (OpenAI) function_call responses\n * - 2: custom JSON added by the user using `Data`\n * - 6: (OpenAI) tool_call responses\n *\n * Example:\n * ```\n * 0:Vercel\n * 0:'s\n * 0: AI\n * 0: AI\n * 0: SDK\n * 0: is great\n * 0:!\n * 2: { \"someJson\": \"value\" }\n * 1: {\"function_call\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}\n * 6: {\"tool_call\": {\"id\": \"tool_0\", \"type\": \"function\", \"function\": {\"name\": \"get_current_weather\", \"arguments\": \"{\\\\n\\\\\"location\\\\\": \\\\\"Charlottesville, Virginia\\\\\",\\\\n\\\\\"format\\\\\": \\\\\"celsius\\\\\"\\\\n}\"}}}\n *```\n */\nexport const DataStreamStringPrefixes = Object.fromEntries(\n  dataStreamParts.map(part => [part.name, part.code]),\n) as {\n  [K in DataStreamParts['name']]: (typeof dataStreamParts)[number]['code'];\n};\n\nexport const validCodes = dataStreamParts.map(part => part.code);\n\n/**\nParses a stream part from a string.\n\n@param line The string to parse.\n@returns The parsed stream part.\n@throws An error if the string cannot be parsed.\n */\nexport const parseDataStreamPart = (line: string): DataStreamPartType => {\n  const firstSeparatorIndex = line.indexOf(':');\n\n  if (firstSeparatorIndex === -1) {\n    throw new Error('Failed to parse stream string. No separator found.');\n  }\n\n  const prefix = line.slice(0, firstSeparatorIndex);\n\n  if (!validCodes.includes(prefix as keyof typeof dataStreamPartsByCode)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n\n  const code = prefix as keyof typeof dataStreamPartsByCode;\n\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue: JSONValue = JSON.parse(textValue);\n\n  return dataStreamPartsByCode[code].parse(jsonValue);\n};\n\n/**\nPrepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it,\nand appends a new line.\n\nIt ensures type-safety for the part type and value.\n */\nexport function formatDataStreamPart<T extends keyof DataStreamPartValueType>(\n  type: T,\n  value: DataStreamPartValueType[T],\n): DataStreamString {\n  const streamPart = dataStreamParts.find(part => part.name === type);\n\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n\n  return `${streamPart.code}:${JSON.stringify(value)}\\n`;\n}\n", "import { DataStreamPartType, parseDataStreamPart } from './data-stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\nexport async function processDataStream({\n  stream,\n  onTextPart,\n  onReasoningPart,\n  onReasoningSignaturePart,\n  onRedactedReasoningPart,\n  onSourcePart,\n  onFilePart,\n  onDataPart,\n  onErrorPart,\n  onToolCallStreamingStartPart,\n  onToolCallDeltaPart,\n  onToolCallPart,\n  onToolResultPart,\n  onMessageAnnotationsPart,\n  onFinishMessagePart,\n  onFinishStepPart,\n  onStartStepPart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart?: (\n    streamPart: (DataStreamPartType & { type: 'text' })['value'],\n  ) => Promise<void> | void;\n  onReasoningPart?: (\n    streamPart: (DataStreamPartType & { type: 'reasoning' })['value'],\n  ) => Promise<void> | void;\n  onReasoningSignaturePart?: (\n    streamPart: (DataStreamPartType & { type: 'reasoning_signature' })['value'],\n  ) => Promise<void> | void;\n  onRedactedReasoningPart?: (\n    streamPart: (DataStreamPartType & { type: 'redacted_reasoning' })['value'],\n  ) => Promise<void> | void;\n  onFilePart?: (\n    streamPart: (DataStreamPartType & { type: 'file' })['value'],\n  ) => Promise<void> | void;\n  onSourcePart?: (\n    streamPart: (DataStreamPartType & { type: 'source' })['value'],\n  ) => Promise<void> | void;\n  onDataPart?: (\n    streamPart: (DataStreamPartType & { type: 'data' })['value'],\n  ) => Promise<void> | void;\n  onErrorPart?: (\n    streamPart: (DataStreamPartType & { type: 'error' })['value'],\n  ) => Promise<void> | void;\n  onToolCallStreamingStartPart?: (\n    streamPart: (DataStreamPartType & {\n      type: 'tool_call_streaming_start';\n    })['value'],\n  ) => Promise<void> | void;\n  onToolCallDeltaPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_call_delta' })['value'],\n  ) => Promise<void> | void;\n  onToolCallPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_call' })['value'],\n  ) => Promise<void> | void;\n  onToolResultPart?: (\n    streamPart: (DataStreamPartType & { type: 'tool_result' })['value'],\n  ) => Promise<void> | void;\n  onMessageAnnotationsPart?: (\n    streamPart: (DataStreamPartType & {\n      type: 'message_annotations';\n    })['value'],\n  ) => Promise<void> | void;\n  onFinishMessagePart?: (\n    streamPart: (DataStreamPartType & { type: 'finish_message' })['value'],\n  ) => Promise<void> | void;\n  onFinishStepPart?: (\n    streamPart: (DataStreamPartType & { type: 'finish_step' })['value'],\n  ) => Promise<void> | void;\n  onStartStepPart?: (\n    streamPart: (DataStreamPartType & { type: 'start_step' })['value'],\n  ) => Promise<void> | void;\n}): Promise<void> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '') // splitting leaves an empty string at the end\n      .map(parseDataStreamPart);\n\n    for (const { type, value } of streamParts) {\n      switch (type) {\n        case 'text':\n          await onTextPart?.(value);\n          break;\n        case 'reasoning':\n          await onReasoningPart?.(value);\n          break;\n        case 'reasoning_signature':\n          await onReasoningSignaturePart?.(value);\n          break;\n        case 'redacted_reasoning':\n          await onRedactedReasoningPart?.(value);\n          break;\n        case 'file':\n          await onFilePart?.(value);\n          break;\n        case 'source':\n          await onSourcePart?.(value);\n          break;\n        case 'data':\n          await onDataPart?.(value);\n          break;\n        case 'error':\n          await onErrorPart?.(value);\n          break;\n        case 'message_annotations':\n          await onMessageAnnotationsPart?.(value);\n          break;\n        case 'tool_call_streaming_start':\n          await onToolCallStreamingStartPart?.(value);\n          break;\n        case 'tool_call_delta':\n          await onToolCallDeltaPart?.(value);\n          break;\n        case 'tool_call':\n          await onToolCallPart?.(value);\n          break;\n        case 'tool_result':\n          await onToolResultPart?.(value);\n          break;\n        case 'finish_message':\n          await onFinishMessagePart?.(value);\n          break;\n        case 'finish_step':\n          await onFinishStepPart?.(value);\n          break;\n        case 'start_step':\n          await onStartStepPart?.(value);\n          break;\n        default: {\n          const exhaustiveCheck: never = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n", "import { JSONValue } from '@ai-sdk/provider';\nimport { generateId as generateIdFunction } from '@ai-sdk/provider-utils';\nimport { processTextStream } from './process-text-stream';\nimport { TextUIPart, UIMessage, UseChatOptions } from './types';\n\nexport async function processChatTextResponse({\n  stream,\n  update,\n  onFinish,\n  getCurrentDate = () => new Date(),\n  generateId = generateIdFunction,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  update: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onFinish: UseChatOptions['onFinish'];\n  getCurrentDate?: () => Date;\n  generateId?: () => string;\n}) {\n  const textPart: TextUIPart = { type: 'text', text: '' };\n\n  const resultMessage: UIMessage = {\n    id: generateId(),\n    createdAt: getCurrentDate(),\n    role: 'assistant' as const,\n    content: '',\n    parts: [textPart],\n  };\n\n  await processTextStream({\n    stream,\n    onTextPart: chunk => {\n      resultMessage.content += chunk;\n      textPart.text += chunk;\n\n      // note: creating a new message object is required for Solid.js streaming\n      update({\n        message: { ...resultMessage },\n        data: [],\n        replaceLastMessage: false,\n      });\n    },\n  });\n\n  // in text mode, we don't have usage information or finish reason:\n  onFinish?.(resultMessage, {\n    usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },\n    finishReason: 'unknown',\n  });\n}\n", "export async function processTextStream({\n  stream,\n  onTextPart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart: (chunk: string) => Promise<void> | void;\n}): Promise<void> {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n", "import { processChatResponse } from './process-chat-response';\nimport { processChatTextResponse } from './process-chat-text-response';\nimport { IdGenerator, JSONValue, UIMessage, UseChatOptions } from './types';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callChatApi({\n  api,\n  body,\n  streamProtocol = 'data',\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId,\n  fetch = getOriginalFetch(),\n  lastMessage,\n  requestType = 'generate',\n}: {\n  api: string;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  abortController: (() => AbortController | null) | undefined;\n  restoreMessagesOnFailure: () => void;\n  onResponse: ((response: Response) => void | Promise<void>) | undefined;\n  onUpdate: (options: {\n    message: UIMessage;\n    data: JSONValue[] | undefined;\n    replaceLastMessage: boolean;\n  }) => void;\n  onFinish: UseChatOptions['onFinish'];\n  onToolCall: UseChatOptions['onToolCall'];\n  generateId: IdGenerator;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n  lastMessage: UIMessage | undefined;\n  requestType?: 'generate' | 'resume';\n}) {\n  const request =\n    requestType === 'resume'\n      ? fetch(`${api}?chatId=${body.id}`, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n            ...headers,\n          },\n          signal: abortController?.()?.signal,\n          credentials,\n        })\n      : fetch(api, {\n          method: 'POST',\n          body: JSON.stringify(body),\n          headers: {\n            'Content-Type': 'application/json',\n            ...headers,\n          },\n          signal: abortController?.()?.signal,\n          credentials,\n        });\n\n  const response = await request.catch(err => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (await response.text()) ?? 'Failed to fetch the chat response.',\n    );\n  }\n\n  if (!response.body) {\n    throw new Error('The response body is empty.');\n  }\n\n  switch (streamProtocol) {\n    case 'text': {\n      await processChatTextResponse({\n        stream: response.body,\n        update: onUpdate,\n        onFinish,\n        generateId,\n      });\n      return;\n    }\n\n    case 'data': {\n      await processChatResponse({\n        stream: response.body,\n        update: onUpdate,\n        lastMessage,\n        onToolCall,\n        onFinish({ message, finishReason, usage }) {\n          if (onFinish && message != null) {\n            onFinish(message, { usage, finishReason });\n          }\n        },\n        generateId,\n      });\n      return;\n    }\n\n    default: {\n      const exhaustiveCheck: never = streamProtocol;\n      throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n    }\n  }\n}\n", "import { processTextStream } from './process-text-stream';\nimport { processDataStream } from './process-data-stream';\nimport { JSONValue } from './types';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = 'data',\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch = getOriginalFetch(),\n}: {\n  api: string;\n  prompt: string;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  setCompletion: (completion: string) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: Error | undefined) => void;\n  setAbortController: (abortController: AbortController | null) => void;\n  onResponse: ((response: Response) => void | Promise<void>) | undefined;\n  onFinish: ((prompt: string, completion: string) => void) | undefined;\n  onError: ((error: Error) => void) | undefined;\n  onData: ((data: JSONValue[]) => void) | undefined;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n}) {\n  try {\n    setLoading(true);\n    setError(undefined);\n\n    const abortController = new AbortController();\n    setAbortController(abortController);\n\n    // Empty the completion immediately.\n    setCompletion('');\n\n    const response = await fetch(api, {\n      method: 'POST',\n      body: JSON.stringify({\n        prompt,\n        ...body,\n      }),\n      credentials,\n      headers: {\n        'Content-Type': 'application/json',\n        ...headers,\n      },\n      signal: abortController.signal,\n    }).catch(err => {\n      throw err;\n    });\n\n    if (onResponse) {\n      try {\n        await onResponse(response);\n      } catch (err) {\n        throw err;\n      }\n    }\n\n    if (!response.ok) {\n      throw new Error(\n        (await response.text()) ?? 'Failed to fetch the chat response.',\n      );\n    }\n\n    if (!response.body) {\n      throw new Error('The response body is empty.');\n    }\n\n    let result = '';\n\n    switch (streamProtocol) {\n      case 'text': {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: chunk => {\n            result += chunk;\n            setCompletion(result);\n          },\n        });\n        break;\n      }\n      case 'data': {\n        await processDataStream({\n          stream: response.body,\n          onTextPart(value) {\n            result += value;\n            setCompletion(result);\n          },\n          onDataPart(value) {\n            onData?.(value);\n          },\n          onErrorPart(value) {\n            throw new Error(value);\n          },\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck: never = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    // Ignore abort errors as they are expected.\n    if ((err as any).name === 'AbortError') {\n      setAbortController(null);\n      return null;\n    }\n\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n\n    setError(err as Error);\n  } finally {\n    setLoading(false);\n  }\n}\n", "/**\n * Converts a data URL of type text/* to a text string.\n */\nexport function getTextFromDataUrl(dataUrl: string): string {\n  const [header, base64Content] = dataUrl.split(',');\n  const mimeType = header.split(';')[0].split(':')[1];\n\n  if (mimeType == null || base64Content == null) {\n    throw new Error('Invalid data URL format');\n  }\n\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n", "import { ToolInvocation } from './types';\n\nexport function extractMaxToolInvocationStep(\n  toolInvocations: ToolInvocation[] | undefined,\n): number | undefined {\n  return toolInvocations?.reduce((max, toolInvocation) => {\n    return Math.max(max, toolInvocation.step ?? 0);\n  }, 0);\n}\n", "import {\n  CreateMessage,\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  SourceUIPart,\n  StepStartUIPart,\n  TextUIPart,\n  ToolInvocationUIPart,\n  UIMessage,\n} from './types';\n\nexport function getMessageParts(\n  message: Message | CreateMessage | UIMessage,\n): (\n  | TextUIPart\n  | ReasoningUIPart\n  | ToolInvocationUIPart\n  | SourceUIPart\n  | FileUIPart\n  | StepStartUIPart\n)[] {\n  return (\n    message.parts ?? [\n      ...(message.toolInvocations\n        ? message.toolInvocations.map(toolInvocation => ({\n            type: 'tool-invocation' as const,\n            toolInvocation,\n          }))\n        : []),\n      ...(message.reasoning\n        ? [\n            {\n              type: 'reasoning' as const,\n              reasoning: message.reasoning,\n              details: [{ type: 'text' as const, text: message.reasoning }],\n            },\n          ]\n        : []),\n      ...(message.content\n        ? [{ type: 'text' as const, text: message.content }]\n        : []),\n    ]\n  );\n}\n", "import { getMessageParts } from './get-message-parts';\nimport { Message, UIMessage } from './types';\n\nexport function fillMessageParts(messages: Message[]): UIMessage[] {\n  return messages.map(message => ({\n    ...message,\n    parts: getMessageParts(message),\n  }));\n}\n", "/**\n * Performs a deep-equal comparison of two parsed JSON objects.\n *\n * @param {any} obj1 - The first object to compare.\n * @param {any} obj2 - The second object to compare.\n * @returns {boolean} - Returns true if the two objects are deeply equal, false otherwise.\n */\nexport function isDeepEqualData(obj1: any, obj2: any): boolean {\n  // Check for strict equality first\n  if (obj1 === obj2) return true;\n\n  // Check if either is null or undefined\n  if (obj1 == null || obj2 == null) return false;\n\n  // Check if both are objects\n  if (typeof obj1 !== 'object' && typeof obj2 !== 'object')\n    return obj1 === obj2;\n\n  // If they are not strictly equal, they both need to be Objects\n  if (obj1.constructor !== obj2.constructor) return false;\n\n  // Special handling for Date objects\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n\n  // Handle arrays: compare length and then perform a recursive deep comparison on each item\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length) return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n    }\n    return true; // All array elements matched\n  }\n\n  // Compare the set of keys in each object\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) return false;\n\n  // Check each key-value pair recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key)) return false;\n    if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n  }\n\n  return true; // All keys and values matched\n}\n", "import { Attachment } from './types';\n\nexport async function prepareAttachmentsForRequest(\n  attachmentsFromOptions: FileList | Array<Attachment> | undefined,\n) {\n  if (!attachmentsFromOptions) {\n    return [];\n  }\n\n  // https://github.com/vercel/ai/pull/6045\n  // React-native doesn't have a FileList\n  // global variable, so we need to check for it\n  if (\n    globalThis.FileList &&\n    attachmentsFromOptions instanceof globalThis.FileList\n  ) {\n    return Promise.all(\n      Array.from(attachmentsFromOptions).map(async attachment => {\n        const { name, type } = attachment;\n\n        const dataUrl = await new Promise<string>((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = readerEvent => {\n            resolve(readerEvent.target?.result as string);\n          };\n          reader.onerror = error => reject(error);\n          reader.readAsDataURL(attachment);\n        });\n\n        return {\n          name,\n          contentType: type,\n          url: dataUrl,\n        };\n      }),\n    );\n  }\n\n  if (Array.isArray(attachmentsFromOptions)) {\n    return attachmentsFromOptions;\n  }\n\n  throw new Error('Invalid attachments type');\n}\n", "import {\n  AssistantStreamPartType,\n  parseAssistantStreamPart,\n} from './assistant-stream-parts';\n\nconst NEWLINE = '\\n'.charCodeAt(0);\n\n// concatenates all the chunks into a single Uint8Array\nfunction concatChunks(chunks: Uint8Array[], totalLength: number) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n\n  return concatenatedChunks;\n}\n\nexport async function processAssistantStream({\n  stream,\n  onTextPart,\n  onErrorPart,\n  onAssistantMessagePart,\n  onAssistantControlDataPart,\n  onDataMessagePart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart?: (\n    streamPart: (AssistantStreamPartType & { type: 'text' })['value'],\n  ) => Promise<void> | void;\n  onErrorPart?: (\n    streamPart: (AssistantStreamPartType & { type: 'error' })['value'],\n  ) => Promise<void> | void;\n  onAssistantMessagePart?: (\n    streamPart: (AssistantStreamPartType & {\n      type: 'assistant_message';\n    })['value'],\n  ) => Promise<void> | void;\n  onAssistantControlDataPart?: (\n    streamPart: (AssistantStreamPartType & {\n      type: 'assistant_control_data';\n    })['value'],\n  ) => Promise<void> | void;\n  onDataMessagePart?: (\n    streamPart: (AssistantStreamPartType & { type: 'data_message' })['value'],\n  ) => Promise<void> | void;\n}): Promise<void> {\n  // implementation note: this slightly more complex algorithm is required\n  // to pass the tests in the edge environment.\n\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n\n  while (true) {\n    const { value } = await reader.read();\n\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        // if the last character is not a newline, we have not read the whole JSON value\n        continue;\n      }\n    }\n\n    if (chunks.length === 0) {\n      break; // we have reached the end of the stream\n    }\n\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n\n    const streamParts = decoder\n      .decode(concatenatedChunks, { stream: true })\n      .split('\\n')\n      .filter(line => line !== '')\n      .map(parseAssistantStreamPart);\n\n    for (const { type, value } of streamParts) {\n      switch (type) {\n        case 'text':\n          await onTextPart?.(value);\n          break;\n        case 'error':\n          await onErrorPart?.(value);\n          break;\n        case 'assistant_message':\n          await onAssistantMessagePart?.(value);\n          break;\n        case 'assistant_control_data':\n          await onAssistantControlDataPart?.(value);\n          break;\n        case 'data_message':\n          await onDataMessagePart?.(value);\n          break;\n        default: {\n          const exhaustiveCheck: never = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n", "import { Validator, validatorSymbol } from '@ai-sdk/provider-utils';\nimport { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport { zodSchema } from './zod-schema';\n\n/**\n * Used to mark schemas so we can support both Zod and custom schemas.\n */\nconst schemaSymbol = Symbol.for('vercel.ai.schema');\n\nexport type Schema<OBJECT = unknown> = Validator<OBJECT> & {\n  /**\n   * Used to mark schemas so we can support both Zod and custom schemas.\n   */\n  [schemaSymbol]: true;\n\n  /**\n   * Schema type for inference.\n   */\n  _type: OBJECT;\n\n  /**\n   * The JSON Schema for the schema. It is passed to the providers.\n   */\n  readonly jsonSchema: JSONSchema7;\n};\n\n/**\n * Create a schema using a JSON Schema.\n *\n * @param jsonSchema The JSON Schema for the schema.\n * @param options.validate Optional. A validation function for the schema.\n */\nexport function jsonSchema<OBJECT = unknown>(\n  jsonSchema: JSONSchema7,\n  {\n    validate,\n  }: {\n    validate?: (\n      value: unknown,\n    ) => { success: true; value: OBJECT } | { success: false; error: Error };\n  } = {},\n): Schema<OBJECT> {\n  return {\n    [schemaSymbol]: true,\n    _type: undefined as OBJECT, // should never be used directly\n    [validatorSymbol]: true,\n    jsonSchema,\n    validate,\n  };\n}\n\nfunction isSchema(value: unknown): value is Schema {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    schemaSymbol in value &&\n    value[schemaSymbol] === true &&\n    'jsonSchema' in value &&\n    'validate' in value\n  );\n}\n\nexport function asSchema<OBJECT>(\n  schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>,\n): Schema<OBJECT> {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\n", "import { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\nimport { jsonSchema, Schema } from './schema';\n\nexport function zodSchema<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n  options?: {\n    /**\n     * Enables support for references in the schema.\n     * This is required for recursive schemas, e.g. with `z.lazy`.\n     * However, not all language models and providers support such references.\n     * Defaults to `false`.\n     */\n    useReferences?: boolean;\n  },\n): Schema<OBJECT> {\n  // default to no references (to support openapi conversion for google)\n  const useReferences = options?.useReferences ?? false;\n\n  return jsonSchema(\n    zodToJsonSchema(zodSchema, {\n      $refStrategy: useReferences ? 'root' : 'none',\n      target: 'jsonSchema7', // note: openai mode breaks various gemini conversions\n    }) as JSONSchema7,\n    {\n      validate: value => {\n        const result = zodSchema.safeParse(value);\n        return result.success\n          ? { success: true, value: result.data }\n          : { success: false, error: result.error };\n      },\n    },\n  );\n}\n", "import { extractMaxToolInvocationStep } from './extract-max-tool-invocation-step';\nimport { UIMessage } from './types';\n\nexport function shouldResubmitMessages({\n  originalMaxToolInvocationStep,\n  originalMessageCount,\n  maxSteps,\n  messages,\n}: {\n  originalMaxToolInvocationStep: number | undefined;\n  originalMessageCount: number;\n  maxSteps: number;\n  messages: UIMessage[];\n}) {\n  const lastMessage = messages[messages.length - 1];\n  return (\n    // check if the feature is enabled:\n    maxSteps > 1 &&\n    // ensure there is a last message:\n    lastMessage != null &&\n    // ensure we actually have new steps (to prevent infinite loops in case of errors):\n    (messages.length > originalMessageCount ||\n      extractMaxToolInvocationStep(lastMessage.toolInvocations) !==\n        originalMaxToolInvocationStep) &&\n    // check that next step is possible:\n    isAssistantMessageWithCompletedToolCalls(lastMessage) &&\n    // limit the number of automatic steps:\n    (extractMaxToolInvocationStep(lastMessage.toolInvocations) ?? 0) < maxSteps\n  );\n}\n\n/**\nCheck if the message is an assistant message with completed tool calls.\nThe last step of the message must have at least one tool invocation and\nall tool invocations must have a result.\n */\nexport function isAssistantMessageWithCompletedToolCalls(\n  message: UIMessage,\n): message is UIMessage & {\n  role: 'assistant';\n} {\n  if (message.role !== 'assistant') {\n    return false;\n  }\n\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === 'step-start' ? index : lastIndex;\n  }, -1);\n\n  const lastStepToolInvocations = message.parts\n    .slice(lastStepStartIndex + 1)\n    .filter(part => part.type === 'tool-invocation');\n\n  return (\n    lastStepToolInvocations.length > 0 &&\n    lastStepToolInvocations.every(part => 'result' in part.toolInvocation)\n  );\n}\n", "import { ToolInvocationUIPart, UIMessage } from './types';\n\n/**\n * Updates the result of a specific tool invocation in the last message of the given messages array.\n *\n * @param {object} params - The parameters object.\n * @param {UIMessage[]} params.messages - An array of messages, from which the last one is updated.\n * @param {string} params.toolCallId - The unique identifier for the tool invocation to update.\n * @param {unknown} params.toolResult - The result object to attach to the tool invocation.\n * @returns {void} This function does not return anything.\n */\nexport function updateToolCallResult({\n  messages,\n  toolCallId,\n  toolResult: result,\n}: {\n  messages: UIMessage[];\n  toolCallId: string;\n  toolResult: unknown;\n}) {\n  const lastMessage = messages[messages.length - 1];\n\n  const invocationPart = lastMessage.parts.find(\n    (part): part is ToolInvocationUIPart =>\n      part.type === 'tool-invocation' &&\n      part.toolInvocation.toolCallId === toolCallId,\n  );\n\n  if (invocationPart == null) {\n    return;\n  }\n\n  const toolResult = {\n    ...invocationPart.toolInvocation,\n    state: 'result' as const,\n    result,\n  };\n\n  invocationPart.toolInvocation = toolResult;\n\n  lastMessage.toolInvocations = lastMessage.toolInvocations?.map(\n    toolInvocation =>\n      toolInvocation.toolCallId === toolCallId ? toolResult : toolInvocation,\n  );\n}\n", "// re-exports:\nexport { createIdGenerator, generateId } from '@ai-sdk/provider-utils';\nexport type { IDGenerator } from '@ai-sdk/provider-utils';\nexport {\n  formatAssistantStreamPart,\n  formatDataStreamPart,\n  jsonSchema,\n  parseAssistantStreamPart,\n  parseDataStreamPart,\n  processDataStream,\n  processTextStream,\n  zodSchema,\n} from '@ai-sdk/ui-utils';\nexport type {\n  AssistantMessage,\n  AssistantStatus,\n  Attachment,\n  ChatRequest,\n  ChatRequestOptions,\n  CreateMessage,\n  DataMessage,\n  DataStreamPart,\n  DeepPartial,\n  IdGenerator,\n  JSONValue,\n  Message,\n  UIMessage,\n  RequestOptions,\n  Schema,\n  ToolInvocation,\n  UseAssistantOptions,\n} from '@ai-sdk/ui-utils';\n\n// directory exports:\nexport * from './data-stream';\nexport * from './embed';\nexport * from './generate-image';\nexport * from './generate-object';\nexport * from './generate-text';\nexport * from './generate-speech';\nexport * from './transcribe';\nexport * from './middleware';\nexport * from './prompt';\nexport * from './registry';\nexport * from './tool';\nexport * from './types';\n\n// telemetry types:\nexport type { TelemetrySettings } from './telemetry/telemetry-settings';\n\n// util exports:\nexport { cosineSimilarity } from './util/cosine-similarity';\nexport { simulateReadableStream } from './util/simulate-readable-stream';\n", "import { DataStreamString, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function createDataStream({\n  execute,\n  onError = () => 'An error occurred.', // mask error messages for safety by default\n}: {\n  execute: (dataStream: DataStreamWriter) => Promise<void> | void;\n  onError?: (error: unknown) => string;\n}): ReadableStream<DataStreamString> {\n  let controller!: ReadableStreamDefaultController<string>;\n\n  const ongoingStreamPromises: Promise<void>[] = [];\n\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    },\n  });\n\n  function safeEnqueue(data: DataStreamString) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n      // suppress errors when the stream has been closed\n    }\n  }\n\n  try {\n    const result = execute({\n      write(data: DataStreamString) {\n        safeEnqueue(data);\n      },\n      writeData(data) {\n        safeEnqueue(formatDataStreamPart('data', [data]));\n      },\n      writeMessageAnnotation(annotation) {\n        safeEnqueue(formatDataStreamPart('message_annotations', [annotation]));\n      },\n      writeSource(source) {\n        safeEnqueue(formatDataStreamPart('source', source));\n      },\n      merge(streamArg) {\n        ongoingStreamPromises.push(\n          (async () => {\n            const reader = streamArg.getReader();\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              safeEnqueue(value);\n            }\n          })().catch(error => {\n            safeEnqueue(formatDataStreamPart('error', onError(error)));\n          }),\n        );\n      },\n      onError,\n    });\n\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch(error => {\n          safeEnqueue(formatDataStreamPart('error', onError(error)));\n        }),\n      );\n    }\n  } catch (error) {\n    safeEnqueue(formatDataStreamPart('error', onError(error)));\n  }\n\n  // Wait until all ongoing streams are done. This approach enables merging\n  // streams even after execute has returned, as long as there is still an\n  // open merged stream. This is important to e.g. forward new streams and\n  // from callbacks.\n  const waitForStreams: Promise<void> = new Promise(async resolve => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve();\n  });\n\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n      // suppress errors when the stream has been closed\n    }\n  });\n\n  return stream;\n}\n", "export function prepareResponseHeaders(\n  headers: HeadersInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const responseHeaders = new Headers(headers ?? {});\n\n  if (!responseHeaders.has('Content-Type')) {\n    responseHeaders.set('Content-Type', contentType);\n  }\n\n  if (dataStreamVersion !== undefined) {\n    responseHeaders.set('X-Vercel-AI-Data-Stream', dataStreamVersion);\n  }\n\n  return responseHeaders;\n}\n", "import { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { createDataStream } from './create-data-stream';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function createDataStreamResponse({\n  status,\n  statusText,\n  headers,\n  execute,\n  onError,\n}: ResponseInit & {\n  execute: (dataStream: DataStreamWriter) => Promise<void> | void;\n  onError?: (error: unknown) => string;\n}): Response {\n  return new Response(\n    createDataStream({ execute, onError }).pipeThrough(new TextEncoderStream()),\n    {\n      status,\n      statusText,\n      headers: prepareResponseHeaders(headers, {\n        contentType: 'text/plain; charset=utf-8',\n        dataStreamVersion: 'v1',\n      }),\n    },\n  );\n}\n", "export function prepareOutgoingHttpHeaders(\n  headers: HeadersInit | undefined,\n  {\n    contentType,\n    dataStreamVersion,\n  }: { contentType: string; dataStreamVersion?: 'v1' | undefined },\n) {\n  const outgoingHeaders: Record<string, string | number | string[]> = {};\n\n  if (headers != null) {\n    for (const [key, value] of Object.entries(headers)) {\n      outgoingHeaders[key] = value;\n    }\n  }\n\n  if (outgoingHeaders['Content-Type'] == null) {\n    outgoingHeaders['Content-Type'] = contentType;\n  }\n\n  if (dataStreamVersion !== undefined) {\n    outgoingHeaders['X-Vercel-AI-Data-Stream'] = dataStreamVersion;\n  }\n\n  return outgoingHeaders;\n}\n", "import { ServerResponse } from 'node:http';\n\n/**\n * Writes the content of a stream to a server response.\n */\nexport function writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n}: {\n  response: ServerResponse;\n  status?: number;\n  statusText?: string;\n  headers?: Record<string, string | number | string[]>;\n  stream: ReadableStream<Uint8Array>;\n}): void {\n  response.writeHead(status ?? 200, statusText, headers);\n\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        response.write(value);\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n\n  read();\n}\n", "import { ServerResponse } from 'node:http';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { createDataStream } from './create-data-stream';\nimport { DataStreamWriter } from './data-stream-writer';\n\nexport function pipeDataStreamToResponse(\n  response: ServerResponse,\n  {\n    status,\n    statusText,\n    headers,\n    execute,\n    onError,\n  }: ResponseInit & {\n    execute: (writer: DataStreamWriter) => Promise<void> | void;\n    onError?: (error: unknown) => string;\n  },\n): void {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: prepareOutgoingHttpHeaders(headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n    stream: createDataStream({ execute, onError }).pipeThrough(\n      new TextEncoderStream(),\n    ),\n  });\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly parameter: string;\n  readonly value: unknown;\n\n  constructor({\n    parameter,\n    value,\n    message,\n  }: {\n    parameter: string;\n    value: unknown;\n    message: string;\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`,\n    });\n\n    this.parameter = parameter;\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { APICallError } from '@ai-sdk/provider';\nimport { delay, getErrorMessage, isAbortError } from '@ai-sdk/provider-utils';\nimport { RetryError } from './retry-error';\n\nexport type RetryFunction = <OUTPUT>(\n  fn: () => PromiseLike<OUTPUT>,\n) => PromiseLike<OUTPUT>;\n\n/**\nThe `retryWithExponentialBackoff` strategy retries a failed API call with an exponential backoff.\nYou can configure the maximum number of retries, the initial delay, and the backoff factor.\n */\nexport const retryWithExponentialBackoff =\n  ({\n    maxRetries = 2,\n    initialDelayInMs = 2000,\n    backoffFactor = 2,\n  } = {}): RetryFunction =>\n  async <OUTPUT>(f: () => PromiseLike<OUTPUT>) =>\n    _retryWithExponentialBackoff(f, {\n      maxRetries,\n      delayInMs: initialDelayInMs,\n      backoffFactor,\n    });\n\nasync function _retryWithExponentialBackoff<OUTPUT>(\n  f: () => PromiseLike<OUTPUT>,\n  {\n    maxRetries,\n    delayInMs,\n    backoffFactor,\n  }: { maxRetries: number; delayInMs: number; backoffFactor: number },\n  errors: unknown[] = [],\n): Promise<OUTPUT> {\n  try {\n    return await f();\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error; // don't retry when the request was aborted\n    }\n\n    if (maxRetries === 0) {\n      throw error; // don't wrap the error when retries are disabled\n    }\n\n    const errorMessage = getErrorMessage(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: 'maxRetriesExceeded',\n        errors: newErrors,\n      });\n    }\n\n    if (\n      error instanceof Error &&\n      APICallError.isInstance(error) &&\n      error.isRetryable === true &&\n      tryNumber <= maxRetries\n    ) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors,\n      );\n    }\n\n    if (tryNumber === 1) {\n      throw error; // don't wrap the error when a non-retryable error occurs on the first try\n    }\n\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: 'errorNotRetryable',\n      errors: newErrors,\n    });\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_RetryError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport type RetryErrorReason =\n  | 'maxRetriesExceeded'\n  | 'errorNotRetryable'\n  | 'abort';\n\nexport class RetryError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  // note: property order determines debugging output\n  readonly reason: RetryErrorReason;\n  readonly lastError: unknown;\n  readonly errors: Array<unknown>;\n\n  constructor({\n    message,\n    reason,\n    errors,\n  }: {\n    message: string;\n    reason: RetryErrorReason;\n    errors: Array<unknown>;\n  }) {\n    super({ name, message });\n\n    this.reason = reason;\n    this.errors = errors;\n\n    // separate our last error to make debugging via log easier:\n    this.lastError = errors[errors.length - 1];\n  }\n\n  static isInstance(error: unknown): error is RetryError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport {\n  RetryFunction,\n  retryWithExponentialBackoff,\n} from '../../util/retry-with-exponential-backoff';\n\n/**\n * Validate and prepare retries.\n */\nexport function prepareRetries({\n  maxRetries,\n}: {\n  maxRetries: number | undefined;\n}): {\n  maxRetries: number;\n  retry: RetryFunction;\n} {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be an integer',\n      });\n    }\n\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be >= 0',\n      });\n    }\n  }\n\n  const maxRetriesResult = maxRetries ?? 2;\n\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult }),\n  };\n}\n", "import { TelemetrySettings } from './telemetry-settings';\n\nexport function assembleOperationName({\n  operationId,\n  telemetry,\n}: {\n  operationId: string;\n  telemetry?: TelemetrySettings;\n}) {\n  return {\n    // standardized operation and resource name:\n    'operation.name': `${operationId}${\n      telemetry?.functionId != null ? ` ${telemetry.functionId}` : ''\n    }`,\n    'resource.name': telemetry?.functionId,\n\n    // detailed, AI SDK specific data:\n    'ai.operationId': operationId,\n    'ai.telemetry.functionId': telemetry?.functionId,\n  };\n}\n", "import { Attributes } from '@opentelemetry/api';\nimport { CallSettings } from '../prompt/call-settings';\nimport { TelemetrySettings } from './telemetry-settings';\n\nexport function getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers,\n}: {\n  model: { modelId: string; provider: string };\n  settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n  telemetry: TelemetrySettings | undefined;\n  headers: Record<string, string | undefined> | undefined;\n}): Attributes {\n  return {\n    'ai.model.provider': model.provider,\n    'ai.model.id': model.modelId,\n\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {} as Attributes),\n\n    // add metadata as attributes:\n    ...Object.entries(telemetry?.metadata ?? {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {} as Attributes,\n    ),\n\n    // request headers\n    ...Object.entries(headers ?? {}).reduce((attributes, [key, value]) => {\n      if (value !== undefined) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {} as Attributes),\n  };\n}\n", "import { Tracer, trace } from '@opentelemetry/api';\nimport { noopTracer } from './noop-tracer';\n\nexport function getTracer({\n  isEnabled = false,\n  tracer,\n}: {\n  isEnabled?: boolean;\n  tracer?: Tracer;\n} = {}): Tracer {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n\n  if (tracer) {\n    return tracer;\n  }\n\n  return trace.getTracer('ai');\n}\n", "import { Span, SpanContext, Tracer } from '@opentelemetry/api';\n\n/**\n * Tracer implementation that does nothing (null object).\n */\nexport const noopTracer: Tracer = {\n  startSpan(): Span {\n    return noopSpan;\n  },\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: unknown,\n    arg1: unknown,\n    arg2?: unknown,\n    arg3?: F,\n  ): ReturnType<any> {\n    if (typeof arg1 === 'function') {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === 'function') {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === 'function') {\n      return arg3(noopSpan);\n    }\n  },\n};\n\nconst noopSpan: Span = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  },\n};\n\nconst noopSpanContext: SpanContext = {\n  traceId: '',\n  spanId: '',\n  traceFlags: 0,\n};\n", "import { Attributes, Span, Tracer, SpanStatusCode } from '@opentelemetry/api';\n\nexport function recordSpan<T>({\n  name,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true,\n}: {\n  name: string;\n  tracer: Tracer;\n  attributes: Attributes;\n  fn: (span: Span) => Promise<T>;\n  endWhenDone?: boolean;\n}) {\n  return tracer.startActiveSpan(name, { attributes }, async span => {\n    try {\n      const result = await fn(span);\n\n      if (endWhenDone) {\n        span.end();\n      }\n\n      return result;\n    } catch (error) {\n      try {\n        if (error instanceof Error) {\n          span.recordException({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          });\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: error.message,\n          });\n        } else {\n          span.setStatus({ code: SpanStatusCode.ERROR });\n        }\n      } finally {\n        // always stop the span when there is an error:\n        span.end();\n      }\n\n      throw error;\n    }\n  });\n}\n", "import type { Attributes, AttributeValue } from '@opentelemetry/api';\nimport type { TelemetrySettings } from './telemetry-settings';\n\nexport function selectTelemetryAttributes({\n  telemetry,\n  attributes,\n}: {\n  telemetry?: TelemetrySettings;\n  attributes: {\n    [attributeKey: string]:\n      | AttributeValue\n      | { input: () => AttributeValue | undefined }\n      | { output: () => AttributeValue | undefined }\n      | undefined;\n  };\n}): Attributes {\n  // when telemetry is disabled, return an empty object to avoid serialization overhead:\n  if (telemetry?.isEnabled !== true) {\n    return {};\n  }\n\n  return Object.entries(attributes).reduce((attributes, [key, value]) => {\n    if (value === undefined) {\n      return attributes;\n    }\n\n    // input value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'input' in value &&\n      typeof value.input === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordInputs === false) {\n        return attributes;\n      }\n\n      const result = value.input();\n\n      return result === undefined\n        ? attributes\n        : { ...attributes, [key]: result };\n    }\n\n    // output value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'output' in value &&\n      typeof value.output === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordOutputs === false) {\n        return attributes;\n      }\n\n      const result = value.output();\n\n      return result === undefined\n        ? attributes\n        : { ...attributes, [key]: result };\n    }\n\n    // value is an attribute value already:\n    return { ...attributes, [key]: value };\n  }, {});\n}\n", "import { prepareRetries } from '../prompt/prepare-retries';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { EmbeddingModel } from '../types';\nimport { EmbedResult } from './embed-result';\n\n/**\nEmbed a value using an embedding model. The type of the value is defined by the embedding model.\n\n@param model - The embedding model to use.\n@param value - The value that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embedding, the value, and additional information.\n */\nexport async function embed<VALUE>({\n  model,\n  value,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel<VALUE>;\n\n  /**\nThe value that should be embedded.\n   */\n  value: VALUE;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedResult<VALUE>> {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embed',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embed', telemetry }),\n        ...baseTelemetryAttributes,\n        'ai.value': { input: () => JSON.stringify(value) },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const { embedding, usage, rawResponse } = await retry(() =>\n        // nested spans to align with the embedMany telemetry data:\n        recordSpan({\n          name: 'ai.embed.doEmbed',\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: 'ai.embed.doEmbed',\n                telemetry,\n              }),\n              ...baseTelemetryAttributes,\n              // specific settings that only make sense on the outer level:\n              'ai.values': { input: () => [JSON.stringify(value)] },\n            },\n          }),\n          tracer,\n          fn: async doEmbedSpan => {\n            const modelResponse = await model.doEmbed({\n              values: [value],\n              abortSignal,\n              headers,\n            });\n\n            const embedding = modelResponse.embeddings[0];\n            const usage = modelResponse.usage ?? { tokens: NaN };\n\n            doEmbedSpan.setAttributes(\n              selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  'ai.embeddings': {\n                    output: () =>\n                      modelResponse.embeddings.map(embedding =>\n                        JSON.stringify(embedding),\n                      ),\n                  },\n                  'ai.usage.tokens': usage.tokens,\n                },\n              }),\n            );\n\n            return {\n              embedding,\n              usage,\n              rawResponse: modelResponse.rawResponse,\n            };\n          },\n        }),\n      );\n\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embedding': { output: () => JSON.stringify(embedding) },\n            'ai.usage.tokens': usage.tokens,\n          },\n        }),\n      );\n\n      return new DefaultEmbedResult({ value, embedding, usage, rawResponse });\n    },\n  });\n}\n\nclass DefaultEmbedResult<VALUE> implements EmbedResult<VALUE> {\n  readonly value: EmbedResult<VALUE>['value'];\n  readonly embedding: EmbedResult<VALUE>['embedding'];\n  readonly usage: EmbedResult<VALUE>['usage'];\n  readonly rawResponse: EmbedResult<VALUE>['rawResponse'];\n\n  constructor(options: {\n    value: EmbedResult<VALUE>['value'];\n    embedding: EmbedResult<VALUE>['embedding'];\n    usage: EmbedResult<VALUE>['usage'];\n    rawResponse?: EmbedResult<VALUE>['rawResponse'];\n  }) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.rawResponse = options.rawResponse;\n  }\n}\n", "/**\n * Splits an array into chunks of a specified size.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to split.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {T[][]} - A new array containing the chunks.\n */\nexport function splitArray<T>(array: T[], chunkSize: number): T[][] {\n  if (chunkSize <= 0) {\n    throw new Error('chunkSize must be greater than 0');\n  }\n\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n\n  return result;\n}\n", "import { prepareRetries } from '../prompt/prepare-retries';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { Embedding, EmbeddingModel } from '../types';\nimport { splitArray } from '../util/split-array';\nimport { EmbedManyResult } from './embed-many-result';\n\n/**\nEmbed several values using an embedding model. The type of the value is defined\nby the embedding model.\n\n`embedMany` automatically splits large requests into smaller chunks if the model\nhas a limit on how many embeddings can be generated in a single call.\n\n@param model - The embedding model to use.\n@param values - The values that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embeddings, the value, and additional information.\n */\nexport async function embedMany<VALUE>({\n  model,\n  values,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel<VALUE>;\n\n  /**\nThe values that should be embedded.\n   */\n  values: Array<VALUE>;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedManyResult<VALUE>> {\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embedMany',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embedMany', telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.values': {\n          input: () => values.map(value => JSON.stringify(value)),\n        },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n\n      // the model has not specified limits on\n      // how many embeddings can be generated in a single call\n      if (maxEmbeddingsPerCall == null) {\n        const { embeddings, usage } = await retry(() => {\n          // nested spans to align with the embedMany telemetry data:\n          return recordSpan({\n            name: 'ai.embedMany.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embedMany.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': {\n                  input: () => values.map(value => JSON.stringify(value)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers,\n              });\n\n              const embeddings = modelResponse.embeddings;\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        embeddings.map(embedding => JSON.stringify(embedding)),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return { embeddings, usage };\n            },\n          });\n        });\n\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              'ai.embeddings': {\n                output: () =>\n                  embeddings.map(embedding => JSON.stringify(embedding)),\n              },\n              'ai.usage.tokens': usage.tokens,\n            },\n          }),\n        );\n\n        return new DefaultEmbedManyResult({ values, embeddings, usage });\n      }\n\n      // split the values into chunks that are small enough for the model:\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n\n      // serially embed the chunks:\n      const embeddings: Array<Embedding> = [];\n      let tokens = 0;\n\n      for (const chunk of valueChunks) {\n        const { embeddings: responseEmbeddings, usage } = await retry(() => {\n          // nested spans to align with the embedMany telemetry data:\n          return recordSpan({\n            name: 'ai.embedMany.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embedMany.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': {\n                  input: () => chunk.map(value => JSON.stringify(value)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values: chunk,\n                abortSignal,\n                headers,\n              });\n\n              const embeddings = modelResponse.embeddings;\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        embeddings.map(embedding => JSON.stringify(embedding)),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return { embeddings, usage };\n            },\n          });\n        });\n\n        embeddings.push(...responseEmbeddings);\n        tokens += usage.tokens;\n      }\n\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embeddings': {\n              output: () =>\n                embeddings.map(embedding => JSON.stringify(embedding)),\n            },\n            'ai.usage.tokens': tokens,\n          },\n        }),\n      );\n\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n      });\n    },\n  });\n}\n\nclass DefaultEmbedManyResult<VALUE> implements EmbedManyResult<VALUE> {\n  readonly values: EmbedManyResult<VALUE>['values'];\n  readonly embeddings: EmbedManyResult<VALUE>['embeddings'];\n  readonly usage: EmbedManyResult<VALUE>['usage'];\n\n  constructor(options: {\n    values: EmbedManyResult<VALUE>['values'];\n    embeddings: EmbedManyResult<VALUE>['embeddings'];\n    usage: EmbedManyResult<VALUE>['usage'];\n  }) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { ImageModelResponseMetadata } from '../core/types/image-model-response-metadata';\n\nconst name = 'AI_NoImageGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no image could be generated. This can have multiple causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n */\nexport class NoImageGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\nThe response metadata for each call.\n   */\n  readonly responses: Array<ImageModelResponseMetadata> | undefined;\n\n  constructor({\n    message = 'No image generated.',\n    cause,\n    responses,\n  }: {\n    message?: string;\n    cause?: Error;\n    responses?: Array<ImageModelResponseMetadata>;\n  }) {\n    super({ name, message, cause });\n\n    this.responses = responses;\n  }\n\n  static isInstance(error: unknown): error is NoImageGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\n\n/**\n * A generated file.\n */\nexport interface GeneratedFile {\n  /**\nFile as a base64 encoded string.\n     */\n  readonly base64: string;\n\n  /**\nFile as a Uint8Array.\n     */\n  readonly uint8Array: Uint8Array;\n\n  /**\nMIME type of the file\n   */\n  readonly mimeType: string;\n}\n\nexport class DefaultGeneratedFile implements GeneratedFile {\n  private base64Data: string | undefined;\n  private uint8ArrayData: Uint8Array | undefined;\n\n  readonly mimeType: string;\n\n  constructor({\n    data,\n    mimeType,\n  }: {\n    data: string | Uint8Array;\n    mimeType: string;\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? undefined : data;\n    this.uint8ArrayData = isUint8Array ? data : undefined;\n    this.mimeType = mimeType;\n  }\n\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData!);\n    }\n    return this.base64Data;\n  }\n\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data!);\n    }\n    return this.uint8ArrayData;\n  }\n}\n\nexport class DefaultGeneratedFileWithType extends DefaultGeneratedFile {\n  readonly type = 'file';\n\n  constructor(options: { data: string | Uint8Array; mimeType: string }) {\n    super(options);\n  }\n}\n", "import { convertBase64ToUint8Array } from '@ai-sdk/provider-utils';\n\nexport const imageMimeTypeSignatures = [\n  {\n    mimeType: 'image/gif' as const,\n    bytesPrefix: [0x47, 0x49, 0x46],\n    base64Prefix: 'R0lG',\n  },\n  {\n    mimeType: 'image/png' as const,\n    bytesPrefix: [0x89, 0x50, 0x4e, 0x47],\n    base64Prefix: 'iVBORw',\n  },\n  {\n    mimeType: 'image/jpeg' as const,\n    bytesPrefix: [0xff, 0xd8],\n    base64Prefix: '/9j/',\n  },\n  {\n    mimeType: 'image/webp' as const,\n    bytesPrefix: [0x52, 0x49, 0x46, 0x46],\n    base64Prefix: 'UklGRg',\n  },\n  {\n    mimeType: 'image/bmp' as const,\n    bytesPrefix: [0x42, 0x4d],\n    base64Prefix: 'Qk',\n  },\n  {\n    mimeType: 'image/tiff' as const,\n    bytesPrefix: [0x49, 0x49, 0x2a, 0x00],\n    base64Prefix: 'SUkqAA',\n  },\n  {\n    mimeType: 'image/tiff' as const,\n    bytesPrefix: [0x4d, 0x4d, 0x00, 0x2a],\n    base64Prefix: 'TU0AKg',\n  },\n  {\n    mimeType: 'image/avif' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66,\n    ],\n    base64Prefix: 'AAAAIGZ0eXBhdmlm',\n  },\n  {\n    mimeType: 'image/heic' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63,\n    ],\n    base64Prefix: 'AAAAIGZ0eXBoZWlj',\n  },\n] as const;\n\nexport const audioMimeTypeSignatures = [\n  {\n    mimeType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xfb],\n    base64Prefix: '//s=',\n  },\n  {\n    mimeType: 'audio/wav' as const,\n    bytesPrefix: [0x52, 0x49, 0x46, 0x46],\n    base64Prefix: 'UklGR',\n  },\n  {\n    mimeType: 'audio/ogg' as const,\n    bytesPrefix: [0x4f, 0x67, 0x67, 0x53],\n    base64Prefix: 'T2dnUw',\n  },\n  {\n    mimeType: 'audio/flac' as const,\n    bytesPrefix: [0x66, 0x4c, 0x61, 0x43],\n    base64Prefix: 'ZkxhQw',\n  },\n  {\n    mimeType: 'audio/aac' as const,\n    bytesPrefix: [0x40, 0x15, 0x00, 0x00],\n    base64Prefix: 'QBUA',\n  },\n  {\n    mimeType: 'audio/mp4' as const,\n    bytesPrefix: [0x66, 0x74, 0x79, 0x70],\n    base64Prefix: 'ZnR5cA',\n  },\n] as const;\n\nconst stripID3 = (data: Uint8Array | string) => {\n  const bytes =\n    typeof data === 'string' ? convertBase64ToUint8Array(data) : data;\n  const id3Size =\n    ((bytes[6] & 0x7f) << 21) |\n    ((bytes[7] & 0x7f) << 14) |\n    ((bytes[8] & 0x7f) << 7) |\n    (bytes[9] & 0x7f);\n\n  // The raw MP3 starts here\n  return bytes.slice(id3Size + 10);\n};\n\nfunction stripID3TagsIfPresent(data: Uint8Array | string): Uint8Array | string {\n  const hasId3 =\n    (typeof data === 'string' && data.startsWith('SUQz')) ||\n    (typeof data !== 'string' &&\n      data.length > 10 &&\n      data[0] === 0x49 && // 'I'\n      data[1] === 0x44 && // 'D'\n      data[2] === 0x33); // '3'\n\n  return hasId3 ? stripID3(data) : data;\n}\n\nexport function detectMimeType({\n  data,\n  signatures,\n}: {\n  data: Uint8Array | string;\n  signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;\n}): (typeof signatures)[number]['mimeType'] | undefined {\n  const processedData = stripID3TagsIfPresent(data);\n\n  for (const signature of signatures) {\n    if (\n      typeof processedData === 'string'\n        ? processedData.startsWith(signature.base64Prefix)\n        : processedData.length >= signature.bytesPrefix.length &&\n          signature.bytesPrefix.every(\n            (byte, index) => processedData[index] === byte,\n          )\n    ) {\n      return signature.mimeType;\n    }\n  }\n\n  return undefined;\n}\n", "import { AISDKError, ImageModelV1, JSONValue } from '@ai-sdk/provider';\nimport { NoImageGeneratedError } from '../../errors/no-image-generated-error';\nimport {\n  DefaultGeneratedFile,\n  GeneratedFile,\n} from '../generate-text/generated-file';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ImageGenerationWarning } from '../types/image-model';\nimport { ImageModelResponseMetadata } from '../types/image-model-response-metadata';\nimport { GenerateImageResult } from './generate-image-result';\nimport {\n  detectMimeType,\n  imageMimeTypeSignatures,\n} from '../util/detect-mimetype';\n\n/**\nGenerates images using an image model.\n\n@param model - The image model to use.\n@param prompt - The prompt that should be used to generate the image.\n@param n - Number of images to generate. Default: 1.\n@param size - Size of the images to generate. Must have the format `{width}x{height}`.\n@param aspectRatio - Aspect ratio of the images to generate. Must have the format `{width}:{height}`.\n@param seed - Seed for the image generation.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated images.\n */\nexport async function generateImage({\n  model,\n  prompt,\n  n = 1,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe image model to use.\n     */\n  model: ImageModelV1;\n\n  /**\nThe prompt that should be used to generate the image.\n   */\n  prompt: string;\n\n  /**\nNumber of images to generate.\n   */\n  n?: number;\n\n  /**\nSize of the images to generate. Must have the format `{width}x{height}`. If not provided, the default size will be used.\n   */\n  size?: `${number}x${number}`;\n\n  /**\nAspect ratio of the images to generate. Must have the format `{width}:{height}`. If not provided, the default aspect ratio will be used.\n   */\n  aspectRatio?: `${number}:${number}`;\n\n  /**\nSeed for the image generation. If not provided, the default seed will be used.\n   */\n  seed?: number;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {\n    \"style\": \"vivid\"\n  }\n}\n```\n     */\n  providerOptions?: Record<string, Record<string, JSONValue>>;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<GenerateImageResult> {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  // default to 1 if the model has not specified limits on\n  // how many images can be generated in a single call\n  const maxImagesPerCall = model.maxImagesPerCall ?? 1;\n\n  // parallelize calls to the model:\n  const callCount = Math.ceil(n / maxImagesPerCall);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCall;\n    }\n\n    const remainder = n % maxImagesPerCall;\n    return remainder === 0 ? maxImagesPerCall : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(async callImageCount =>\n      retry(() =>\n        model.doGenerate({\n          prompt,\n          n: callImageCount,\n          abortSignal,\n          headers,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions ?? {},\n        }),\n      ),\n    ),\n  );\n\n  // collect result images, warnings, and response metadata\n  const images: Array<DefaultGeneratedFile> = [];\n  const warnings: Array<ImageGenerationWarning> = [];\n  const responses: Array<ImageModelResponseMetadata> = [];\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        image =>\n          new DefaultGeneratedFile({\n            data: image,\n            mimeType:\n              detectMimeType({\n                data: image,\n                signatures: imageMimeTypeSignatures,\n              }) ?? 'image/png',\n          }),\n      ),\n    );\n    warnings.push(...result.warnings);\n    responses.push(result.response);\n  }\n\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n\n  return new DefaultGenerateImageResult({ images, warnings, responses });\n}\n\nclass DefaultGenerateImageResult implements GenerateImageResult {\n  readonly images: Array<GeneratedFile>;\n  readonly warnings: Array<ImageGenerationWarning>;\n  readonly responses: Array<ImageModelResponseMetadata>;\n\n  constructor(options: {\n    images: Array<GeneratedFile>;\n    warnings: Array<ImageGenerationWarning>;\n    responses: Array<ImageModelResponseMetadata>;\n  }) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n  }\n\n  get image() {\n    return this.images[0];\n  }\n}\n", "import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport { createIdGenerator, safeParseJSON } from '@ai-sdk/provider-utils';\nimport { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { GenerateObjectResult } from './generate-object-result';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { getOutputStrategy } from './output-strategy';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n\nShould return the repaired text or null if the text cannot be repaired.\n     */\nexport type RepairTextFunction = (options: {\n  text: string;\n  error: JSONParseError | TypeValidationError;\n}) => Promise<string | null>;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n     */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n     */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<OBJECT>>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@return\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<Array<ELEMENT>>>;\n/**\nGenerate a value from an enum (limited list of string values) using a language model.\n\nThis function does not stream the output.\n\n@return\nA result object that contains the generated value, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject<ENUM extends string>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'enum';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe enum values that the model should use.\n     */\n      enum: Array<ENUM>;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<ENUM>>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n */\nexport async function generateObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nA function that attempts to repair the raw output of the mode\nto enable JSON parsing.\n     */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<JSONValue>>;\nexport async function generateObject<SCHEMA, RESULT>({\n  model,\n  enum: enumValues, // rename bc enum is reserved by typescript\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_repairText: repairText,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'enum' | 'no-schema';\n\n    model: LanguageModel;\n    enum?: Array<SCHEMA>;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_repairText?: RepairTextFunction;\n    experimental_telemetry?: TelemetrySettings;\n    experimental_providerMetadata?: ProviderMetadata;\n    providerOptions?: ProviderOptions;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateObjectResult<RESULT>> {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues,\n  });\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues,\n  });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateObject',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateObject',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.schema':\n          outputStrategy.jsonSchema != null\n            ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n            : undefined,\n        'ai.schema.name': schemaName,\n        'ai.schema.description': schemaDescription,\n        'ai.settings.output': outputStrategy.type,\n        'ai.settings.mode': mode,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      // use the default provider mode when the mode is set to 'auto' or unspecified\n      if (mode === 'auto' || mode == null) {\n        mode = model.defaultObjectGenerationMode;\n      }\n\n      let result: string;\n      let finishReason: FinishReason;\n      let usage: Parameters<typeof calculateLanguageModelUsage>[0];\n      let warnings: CallWarning[] | undefined;\n      let rawResponse:\n        | { headers?: Record<string, string>; body?: unknown }\n        | undefined;\n      let response: LanguageModelResponseMetadata;\n      let request: LanguageModelRequestMetadata;\n      let logprobs: LogProbs | undefined;\n      let resultProviderMetadata: ProviderMetadata | undefined;\n\n      switch (mode) {\n        case 'json': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: {\n              system:\n                outputStrategy.jsonSchema == null\n                  ? injectJsonInstruction({ prompt: system })\n                  : model.supportsStructuredOutputs\n                    ? system\n                    : injectJsonInstruction({\n                        prompt: system,\n                        schema: outputStrategy.jsonSchema,\n                      }),\n              prompt,\n              messages,\n            },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n          });\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => standardizedPrompt.type,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => JSON.stringify(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-json',\n                    schema: outputStrategy.jsonSchema,\n                    name: schemaName,\n                    description: schemaDescription,\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat: standardizedPrompt.type,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                });\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                if (result.text === undefined) {\n                  throw new NoObjectGeneratedError({\n                    message:\n                      'No object generated: the model did not return a response.',\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result.usage),\n                    finishReason: result.finishReason,\n                  });\n                }\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => result.text },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.prompt_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.completion_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText: result.text, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case 'tool': {\n          const standardizedPrompt = standardizePrompt({\n            prompt: { system, prompt, messages },\n            tools: undefined,\n          });\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context,\n          });\n          const inputFormat = standardizedPrompt.type;\n\n          const generateResult = await retry(() =>\n            recordSpan({\n              name: 'ai.generateObject.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateObject.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => inputFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.settings.mode': mode,\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const result = await model.doGenerate({\n                  mode: {\n                    type: 'object-tool',\n                    tool: {\n                      type: 'function',\n                      name: schemaName ?? 'json',\n                      description:\n                        schemaDescription ?? 'Respond with a JSON object.',\n                      parameters: outputStrategy.jsonSchema!,\n                    },\n                  },\n                  ...prepareCallSettings(settings),\n                  inputFormat,\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                });\n\n                const objectText = result.toolCalls?.[0]?.args;\n\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? model.modelId,\n                };\n\n                if (objectText === undefined) {\n                  throw new NoObjectGeneratedError({\n                    message: 'No object generated: the tool was not called.',\n                    response: responseData,\n                    usage: calculateLanguageModelUsage(result.usage),\n                    finishReason: result.finishReason,\n                  });\n                }\n\n                // Add response information to the span:\n                span.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason,\n                      'ai.response.object': { output: () => objectText },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n\n                      'ai.usage.promptTokens': result.usage.promptTokens,\n                      'ai.usage.completionTokens':\n                        result.usage.completionTokens,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [result.finishReason],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                      'gen_ai.usage.output_tokens':\n                        result.usage.completionTokens,\n                    },\n                  }),\n                );\n\n                return { ...result, objectText, responseData };\n              },\n            }),\n          );\n\n          result = generateResult.objectText;\n          finishReason = generateResult.finishReason;\n          usage = generateResult.usage;\n          warnings = generateResult.warnings;\n          rawResponse = generateResult.rawResponse;\n          logprobs = generateResult.logprobs;\n          resultProviderMetadata = generateResult.providerMetadata;\n          request = generateResult.request ?? {};\n          response = generateResult.responseData;\n\n          break;\n        }\n\n        case undefined: {\n          throw new Error(\n            'Model does not have a default object generation mode.',\n          );\n        }\n\n        default: {\n          const _exhaustiveCheck: never = mode;\n          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n        }\n      }\n\n      function processResult(result: string): RESULT {\n        const parseResult = safeParseJSON({ text: result });\n\n        if (!parseResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: could not parse the response.',\n            cause: parseResult.error,\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason: finishReason,\n          });\n        }\n\n        const validationResult = outputStrategy.validateFinalResult(\n          parseResult.value,\n          {\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n          },\n        );\n\n        if (!validationResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            cause: validationResult.error,\n            text: result,\n            response,\n            usage: calculateLanguageModelUsage(usage),\n            finishReason: finishReason,\n          });\n        }\n\n        return validationResult.value;\n      }\n\n      let object: RESULT;\n      try {\n        object = processResult(result);\n      } catch (error) {\n        if (\n          repairText != null &&\n          NoObjectGeneratedError.isInstance(error) &&\n          (JSONParseError.isInstance(error.cause) ||\n            TypeValidationError.isInstance(error.cause))\n        ) {\n          const repairedText = await repairText({\n            text: result,\n            error: error.cause,\n          });\n\n          if (repairedText === null) {\n            throw error;\n          }\n\n          object = processResult(repairedText);\n        } else {\n          throw error;\n        }\n      }\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': finishReason,\n            'ai.response.object': {\n              output: () => JSON.stringify(object),\n            },\n\n            'ai.usage.promptTokens': usage.promptTokens,\n            'ai.usage.completionTokens': usage.completionTokens,\n          },\n        }),\n      );\n\n      return new DefaultGenerateObjectResult({\n        object,\n        finishReason,\n        usage: calculateLanguageModelUsage(usage),\n        warnings,\n        request,\n        response: {\n          ...response,\n          headers: rawResponse?.headers,\n          body: rawResponse?.body,\n        },\n        logprobs,\n        providerMetadata: resultProviderMetadata,\n      });\n    },\n  });\n}\n\nclass DefaultGenerateObjectResult<T> implements GenerateObjectResult<T> {\n  readonly object: GenerateObjectResult<T>['object'];\n  readonly finishReason: GenerateObjectResult<T>['finishReason'];\n  readonly usage: GenerateObjectResult<T>['usage'];\n  readonly warnings: GenerateObjectResult<T>['warnings'];\n  readonly logprobs: GenerateObjectResult<T>['logprobs'];\n  readonly experimental_providerMetadata: GenerateObjectResult<T>['experimental_providerMetadata'];\n  readonly providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n  readonly response: GenerateObjectResult<T>['response'];\n  readonly request: GenerateObjectResult<T>['request'];\n\n  constructor(options: {\n    object: GenerateObjectResult<T>['object'];\n    finishReason: GenerateObjectResult<T>['finishReason'];\n    usage: GenerateObjectResult<T>['usage'];\n    warnings: GenerateObjectResult<T>['warnings'];\n    logprobs: GenerateObjectResult<T>['logprobs'];\n    providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n    response: GenerateObjectResult<T>['response'];\n    request: GenerateObjectResult<T>['request'];\n  }) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.logprobs = options.logprobs;\n  }\n\n  toJsonResponse(init?: ResponseInit): Response {\n    return new Response(JSON.stringify(this.object), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'application/json; charset=utf-8',\n      }),\n    });\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { LanguageModelResponseMetadata } from '../core/types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../core/types/usage';\nimport { FinishReason } from '../core';\n\nconst name = 'AI_NoObjectGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no object could be generated. This can have several causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n- The model generated a response that could not be validated against the schema.\n\nThe error contains the following properties:\n\n- `text`: The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n */\nexport class NoObjectGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n  The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n   */\n  readonly text: string | undefined;\n\n  /**\n  The response metadata.\n   */\n  readonly response: LanguageModelResponseMetadata | undefined;\n\n  /**\n  The usage of the model.\n   */\n  readonly usage: LanguageModelUsage | undefined;\n\n  /**\n  Reason why the model finished generating a response.\n   */\n  readonly finishReason: FinishReason | undefined;\n\n  constructor({\n    message = 'No object generated.',\n    cause,\n    text,\n    response,\n    usage,\n    finishReason,\n  }: {\n    message?: string;\n    cause?: Error;\n    text?: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  }) {\n    super({ name, message, cause });\n\n    this.text = text;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n\n  static isInstance(error: unknown): error is NoObjectGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n\nexport function verifyNoObjectGeneratedError(\n  error: unknown,\n  expected: {\n    message: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  },\n) {\n  expect(NoObjectGeneratedError.isInstance(error)).toBeTruthy();\n  const noObjectGeneratedError = error as NoObjectGeneratedError;\n  expect(noObjectGeneratedError.message).toStrictEqual(expected.message);\n  expect(noObjectGeneratedError.response).toStrictEqual(expected.response);\n  expect(noObjectGeneratedError.usage).toStrictEqual(expected.usage);\n  expect(noObjectGeneratedError.finishReason).toStrictEqual(\n    expected.finishReason,\n  );\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_DownloadError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class DownloadError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly url: string;\n  readonly statusCode?: number;\n  readonly statusText?: string;\n\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null\n      ? `Failed to download ${url}: ${statusCode} ${statusText}`\n      : `Failed to download ${url}: ${cause}`,\n  }: {\n    url: string;\n    statusCode?: number;\n    statusText?: string;\n    message?: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n\n  static isInstance(error: unknown): error is DownloadError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { DownloadError } from './download-error';\n\nexport async function download({ url }: { url: URL }): Promise<{\n  data: Uint8Array;\n  mimeType: string | undefined;\n}> {\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText);\n\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText,\n      });\n    }\n\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mimeType: response.headers.get('content-type') ?? undefined,\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n}\n", "import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\nimport { InvalidDataContentError } from './invalid-data-content-error';\nimport { z } from 'zod';\n\n/**\nData content. Can either be a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer.\n */\nexport type DataContent = string | Uint8Array | ArrayBuffer | Buffer;\n\n/**\n@internal\n */\nexport const dataContentSchema: z.ZodType<DataContent> = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value: unknown): value is Buffer =>\n      globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: 'Must be a Buffer' },\n  ),\n]);\n\n/**\nConverts data content to a base64-encoded string.\n\n@param content - Data content to convert.\n@returns Base64-encoded string.\n*/\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return convertUint8ArrayToBase64(content);\n}\n\n/**\nConverts data content to a Uint8Array.\n\n@param content - Data content to convert.\n@returns Uint8Array.\n */\nexport function convertDataContentToUint8Array(\n  content: DataContent,\n): Uint8Array {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n\n  if (typeof content === 'string') {\n    try {\n      return convertBase64ToUint8Array(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message:\n          'Invalid data content. Content string is not a base64-encoded media.',\n        content,\n        cause: error,\n      });\n    }\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n\n  throw new InvalidDataContentError({ content });\n}\n\n/**\n * Converts a Uint8Array to a string of text.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The converted string.\n */\nexport function convertUint8ArrayToText(uint8Array: Uint8Array): string {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error('Error decoding Uint8Array to text');\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidDataContentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidDataContentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly content: unknown;\n\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`,\n  }: {\n    content: unknown;\n    cause?: unknown;\n    message?: string;\n  }) {\n    super({ name, message, cause });\n\n    this.content = content;\n  }\n\n  static isInstance(error: unknown): error is InvalidDataContentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidMessageRoleError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidMessageRoleError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly role: string;\n\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`,\n  }: {\n    role: string;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.role = role;\n  }\n\n  static isInstance(error: unknown): error is InvalidMessageRoleError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "export function splitDataUrl(dataUrl: string): {\n  mimeType: string | undefined;\n  base64Content: string | undefined;\n} {\n  try {\n    const [header, base64Content] = dataUrl.split(',');\n    return {\n      mimeType: header.split(';')[0].split(':')[1],\n      base64Content,\n    };\n  } catch (error) {\n    return {\n      mimeType: undefined,\n      base64Content: undefined,\n    };\n  }\n}\n", "import {\n  LanguageModelV1FilePart,\n  LanguageModelV1ImagePart,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1TextPart,\n} from '@ai-sdk/provider';\nimport { download } from '../../util/download';\nimport { CoreMessage } from '../prompt/message';\nimport {\n  detectMimeType,\n  imageMimeTypeSignatures,\n} from '../util/detect-mimetype';\nimport { FilePart, ImagePart, TextPart } from './content-part';\nimport {\n  convertDataContentToBase64String,\n  convertDataContentToUint8Array,\n  DataContent,\n} from './data-content';\nimport { InvalidMessageRoleError } from './invalid-message-role-error';\nimport { splitDataUrl } from './split-data-url';\nimport { StandardizedPrompt } from './standardize-prompt';\n\nexport async function convertToLanguageModelPrompt({\n  prompt,\n  modelSupportsImageUrls = true,\n  modelSupportsUrl = () => false,\n  downloadImplementation = download,\n}: {\n  prompt: StandardizedPrompt;\n  modelSupportsImageUrls: boolean | undefined;\n  modelSupportsUrl: undefined | ((url: URL) => boolean);\n  downloadImplementation?: typeof download;\n}): Promise<LanguageModelV1Prompt> {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    downloadImplementation,\n    modelSupportsImageUrls,\n    modelSupportsUrl,\n  );\n\n  return [\n    ...(prompt.system != null\n      ? [{ role: 'system' as const, content: prompt.system }]\n      : []),\n    ...prompt.messages.map(message =>\n      convertToLanguageModelMessage(message, downloadedAssets),\n    ),\n  ];\n}\n\n/**\n * Convert a CoreMessage to a LanguageModelV1Message.\n *\n * @param message The CoreMessage to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *   available if the model does not support URLs, null otherwise.\n */\nexport function convertToLanguageModelMessage(\n  message: CoreMessage,\n  downloadedAssets: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  >,\n): LanguageModelV1Message {\n  const role = message.role;\n  switch (role) {\n    case 'system': {\n      return {\n        role: 'system',\n        content: message.content,\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'user': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'user',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata:\n            message.providerOptions ?? message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'user',\n        content: message.content\n          .map(part => convertPartToLanguageModelPart(part, downloadedAssets))\n          // remove empty text parts:\n          .filter(part => part.type !== 'text' || part.text !== ''),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'assistant': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'assistant',\n          content: [{ type: 'text', text: message.content }],\n          providerMetadata:\n            message.providerOptions ?? message.experimental_providerMetadata,\n        };\n      }\n\n      return {\n        role: 'assistant',\n        content: message.content\n          .filter(\n            // remove empty text parts:\n            part => part.type !== 'text' || part.text !== '',\n          )\n          .map(part => {\n            const providerOptions =\n              part.providerOptions ?? part.experimental_providerMetadata;\n\n            switch (part.type) {\n              case 'file': {\n                return {\n                  type: 'file',\n                  data:\n                    part.data instanceof URL\n                      ? part.data\n                      : convertDataContentToBase64String(part.data),\n                  filename: part.filename,\n                  mimeType: part.mimeType,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'reasoning': {\n                return {\n                  type: 'reasoning',\n                  text: part.text,\n                  signature: part.signature,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'redacted-reasoning': {\n                return {\n                  type: 'redacted-reasoning',\n                  data: part.data,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'text': {\n                return {\n                  type: 'text' as const,\n                  text: part.text,\n                  providerMetadata: providerOptions,\n                };\n              }\n              case 'tool-call': {\n                return {\n                  type: 'tool-call' as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  args: part.args,\n                  providerMetadata: providerOptions,\n                };\n              }\n            }\n          }),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    case 'tool': {\n      return {\n        role: 'tool',\n        content: message.content.map(part => ({\n          type: 'tool-result',\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          result: part.result,\n          content: part.experimental_content,\n          isError: part.isError,\n          providerMetadata:\n            part.providerOptions ?? part.experimental_providerMetadata,\n        })),\n        providerMetadata:\n          message.providerOptions ?? message.experimental_providerMetadata,\n      };\n    }\n\n    default: {\n      const _exhaustiveCheck: never = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\n\n/**\n * Downloads images and files from URLs in the messages.\n */\nasync function downloadAssets(\n  messages: CoreMessage[],\n  downloadImplementation: typeof download,\n  modelSupportsImageUrls: boolean | undefined,\n  modelSupportsUrl: (url: URL) => boolean,\n): Promise<Record<string, { mimeType: string | undefined; data: Uint8Array }>> {\n  const urls = messages\n    .filter(message => message.role === 'user')\n    .map(message => message.content)\n    .filter((content): content is Array<TextPart | ImagePart | FilePart> =>\n      Array.isArray(content),\n    )\n    .flat()\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        part.type === 'image' || part.type === 'file',\n    )\n    /**\n     * Filter out image parts if the model supports image URLs, before letting it\n     * decide if it supports a particular URL.\n     */\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        !(part.type === 'image' && modelSupportsImageUrls === true),\n    )\n    .map(part => (part.type === 'image' ? part.image : part.data))\n    .map(part =>\n      // support string urls:\n      typeof part === 'string' &&\n      (part.startsWith('http:') || part.startsWith('https:'))\n        ? new URL(part)\n        : part,\n    )\n    .filter((image): image is URL => image instanceof URL)\n    /**\n     * Filter out URLs that the model supports natively, so we don't download them.\n     */\n    .filter(url => !modelSupportsUrl(url));\n\n  // download in parallel:\n  const downloadedImages = await Promise.all(\n    urls.map(async url => ({\n      url,\n      data: await downloadImplementation({ url }),\n    })),\n  );\n\n  return Object.fromEntries(\n    downloadedImages.map(({ url, data }) => [url.toString(), data]),\n  );\n}\n\n/**\n * Convert part of a message to a LanguageModelV1Part.\n * @param part The part to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *  available if the model does not support URLs, null otherwise.\n *\n * @returns The converted part.\n */\nfunction convertPartToLanguageModelPart(\n  part: TextPart | ImagePart | FilePart,\n  downloadedAssets: Record<\n    string,\n    { mimeType: string | undefined; data: Uint8Array }\n  >,\n):\n  | LanguageModelV1TextPart\n  | LanguageModelV1ImagePart\n  | LanguageModelV1FilePart {\n  if (part.type === 'text') {\n    return {\n      type: 'text',\n      text: part.text,\n      providerMetadata:\n        part.providerOptions ?? part.experimental_providerMetadata,\n    };\n  }\n\n  let mimeType: string | undefined = part.mimeType;\n  let data: DataContent | URL;\n  let content: URL | ArrayBuffer | string;\n  let normalizedData: Uint8Array | URL;\n\n  const type = part.type;\n  switch (type) {\n    case 'image':\n      data = part.image;\n      break;\n    case 'file':\n      data = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n\n  // Attempt to create a URL from the data. If it fails, we can assume the data\n  // is not a URL and likely some other sort of data.\n  try {\n    content = typeof data === 'string' ? new URL(data) : data;\n  } catch (error) {\n    content = data;\n  }\n\n  // If we successfully created a URL, we can use that to normalize the data\n  // either by passing it through or converting normalizing the base64 content\n  // to a Uint8Array.\n  if (content instanceof URL) {\n    // If the content is a data URL, we want to convert that to a Uint8Array\n    if (content.protocol === 'data:') {\n      const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(\n        content.toString(),\n      );\n\n      if (dataUrlMimeType == null || base64Content == null) {\n        throw new Error(`Invalid data URL format in part ${type}`);\n      }\n\n      mimeType = dataUrlMimeType;\n      normalizedData = convertDataContentToUint8Array(base64Content);\n    } else {\n      /**\n       * If the content is a URL, we should first see if it was downloaded. And if not,\n       * we can let the model decide if it wants to support the URL. This also allows\n       * for non-HTTP URLs to be passed through (e.g. gs://).\n       */\n      const downloadedFile = downloadedAssets[content.toString()];\n      if (downloadedFile) {\n        normalizedData = downloadedFile.data;\n        mimeType ??= downloadedFile.mimeType;\n      } else {\n        normalizedData = content;\n      }\n    }\n  } else {\n    // Since we know now the content is not a URL, we can attempt to normalize\n    // the data assuming it is some sort of data.\n    normalizedData = convertDataContentToUint8Array(content);\n  }\n\n  // Now that we have the normalized data either as a URL or a Uint8Array,\n  // we can create the LanguageModelV1Part.\n  switch (type) {\n    case 'image': {\n      // When possible, try to detect the mimetype automatically\n      // to deal with incorrect mimetype inputs.\n      // When detection fails, use provided mimetype.\n\n      if (normalizedData instanceof Uint8Array) {\n        mimeType =\n          detectMimeType({\n            data: normalizedData,\n            signatures: imageMimeTypeSignatures,\n          }) ?? mimeType;\n      }\n      return {\n        type: 'image',\n        image: normalizedData,\n        mimeType,\n        providerMetadata:\n          part.providerOptions ?? part.experimental_providerMetadata,\n      };\n    }\n\n    case 'file': {\n      // We should have a mimeType at this point, if not, throw an error.\n      if (mimeType == null) {\n        throw new Error(`Mime type is missing for file part`);\n      }\n\n      return {\n        type: 'file',\n        data:\n          normalizedData instanceof Uint8Array\n            ? convertDataContentToBase64String(normalizedData)\n            : normalizedData,\n        filename: part.filename,\n        mimeType,\n        providerMetadata:\n          part.providerOptions ?? part.experimental_providerMetadata,\n      };\n    }\n  }\n}\n", "import { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { CallSettings } from './call-settings';\n\n/**\n * Validates call settings and sets default values.\n */\nexport function prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  stopSequences,\n  seed,\n}: Omit<CallSettings, 'abortSignal' | 'headers' | 'maxRetries'>): Omit<\n  CallSettings,\n  'abortSignal' | 'headers' | 'maxRetries'\n> {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be an integer',\n      });\n    }\n\n    if (maxTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxTokens',\n        value: maxTokens,\n        message: 'maxTokens must be >= 1',\n      });\n    }\n  }\n\n  if (temperature != null) {\n    if (typeof temperature !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'temperature',\n        value: temperature,\n        message: 'temperature must be a number',\n      });\n    }\n  }\n\n  if (topP != null) {\n    if (typeof topP !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topP',\n        value: topP,\n        message: 'topP must be a number',\n      });\n    }\n  }\n\n  if (topK != null) {\n    if (typeof topK !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topK',\n        value: topK,\n        message: 'topK must be a number',\n      });\n    }\n  }\n\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'presencePenalty',\n        value: presencePenalty,\n        message: 'presencePenalty must be a number',\n      });\n    }\n  }\n\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'frequencyPenalty',\n        value: frequencyPenalty,\n        message: 'frequencyPenalty must be a number',\n      });\n    }\n  }\n\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: 'seed',\n        value: seed,\n        message: 'seed must be an integer',\n      });\n    }\n  }\n\n  return {\n    maxTokens,\n    // TODO v5 remove default 0 for temperature\n    temperature: temperature ?? 0,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences:\n      stopSequences != null && stopSequences.length > 0\n        ? stopSequences\n        : undefined,\n    seed,\n  };\n}\n", "import { InvalidPromptError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { Message } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { ToolSet } from '../generate-text/tool-set';\nimport { convertToCoreMessages } from './convert-to-core-messages';\nimport { CoreMessage, coreMessageSchema } from './message';\nimport { Prompt } from './prompt';\n\nexport type StandardizedPrompt = {\n  /**\n   * Original prompt type. This is forwarded to the providers and can be used\n   * to write send raw text to providers that support it.\n   */\n  type: 'prompt' | 'messages';\n\n  /**\n   * System message.\n   */\n  system?: string;\n\n  /**\n   * Messages.\n   */\n  messages: CoreMessage[];\n};\n\nexport function standardizePrompt<TOOLS extends ToolSet>({\n  prompt,\n  tools,\n}: {\n  prompt: Prompt;\n  tools: undefined | TOOLS;\n}): StandardizedPrompt {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt or messages must be defined',\n    });\n  }\n\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt and messages cannot be defined at the same time',\n    });\n  }\n\n  // validate that system is a string\n  if (prompt.system != null && typeof prompt.system !== 'string') {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'system must be a string',\n    });\n  }\n\n  // type: prompt\n  if (prompt.prompt != null) {\n    // validate that prompt is a string\n    if (typeof prompt.prompt !== 'string') {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'prompt must be a string',\n      });\n    }\n\n    return {\n      type: 'prompt',\n      system: prompt.system,\n      messages: [\n        {\n          role: 'user',\n          content: prompt.prompt,\n        },\n      ],\n    };\n  }\n\n  // type: messages\n  if (prompt.messages != null) {\n    const promptType = detectPromptType(prompt.messages);\n\n    const messages: CoreMessage[] =\n      promptType === 'ui-messages'\n        ? convertToCoreMessages(prompt.messages as Omit<Message, 'id'>[], {\n            tools,\n          })\n        : (prompt.messages as CoreMessage[]);\n\n    if (messages.length === 0) {\n      throw new InvalidPromptError({\n        prompt,\n        message: 'messages must not be empty',\n      });\n    }\n\n    const validationResult = safeValidateTypes({\n      value: messages,\n      schema: z.array(coreMessageSchema),\n    });\n\n    if (!validationResult.success) {\n      throw new InvalidPromptError({\n        prompt,\n        message: [\n          'message must be a CoreMessage or a UI message',\n          `Validation error: ${validationResult.error.message}`,\n        ].join('\\n'),\n        cause: validationResult.error,\n      });\n    }\n\n    return {\n      type: 'messages',\n      messages,\n      system: prompt.system,\n    };\n  }\n\n  throw new Error('unreachable');\n}\n\nfunction detectPromptType(\n  prompt: Array<any>,\n): 'ui-messages' | 'messages' | 'other' {\n  if (!Array.isArray(prompt)) {\n    throw new InvalidPromptError({\n      prompt,\n      message: [\n        'messages must be an array of CoreMessage or UIMessage',\n        `Received non-array value: ${JSON.stringify(prompt)}`,\n      ].join('\\n'),\n      cause: prompt,\n    });\n  }\n\n  if (prompt.length === 0) {\n    return 'messages';\n  }\n\n  const characteristics = prompt.map(detectSingleMessageCharacteristics);\n\n  if (characteristics.some(c => c === 'has-ui-specific-parts')) {\n    return 'ui-messages';\n  }\n\n  const nonMessageIndex = characteristics.findIndex(\n    c => c !== 'has-core-specific-parts' && c !== 'message',\n  );\n\n  if (nonMessageIndex === -1) {\n    return 'messages';\n  }\n\n  throw new InvalidPromptError({\n    prompt,\n    message: [\n      'messages must be an array of CoreMessage or UIMessage',\n      `Received message of type: \"${characteristics[nonMessageIndex]}\" at index ${nonMessageIndex}`,\n      `messages[${nonMessageIndex}]: ${JSON.stringify(prompt[nonMessageIndex])}`,\n    ].join('\\n'),\n    cause: prompt,\n  });\n}\n\nfunction detectSingleMessageCharacteristics(\n  message: any,\n): 'has-ui-specific-parts' | 'has-core-specific-parts' | 'message' | 'other' {\n  if (\n    typeof message === 'object' &&\n    message !== null &&\n    (message.role === 'function' || // UI-only role\n      message.role === 'data' || // UI-only role\n      'toolInvocations' in message || // UI-specific field\n      'parts' in message || // UI-specific field\n      'experimental_attachments' in message)\n  ) {\n    return 'has-ui-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'content' in message &&\n    (Array.isArray(message.content) || // Core messages can have array content\n      'experimental_providerMetadata' in message ||\n      'providerOptions' in message)\n  ) {\n    return 'has-core-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'role' in message &&\n    'content' in message &&\n    typeof message.content === 'string' &&\n    ['system', 'user', 'assistant', 'tool'].includes(message.role)\n  ) {\n    return 'message';\n  } else {\n    return 'other';\n  }\n}\n", "import { Attachment } from '@ai-sdk/ui-utils';\nimport { FilePart, ImagePart, TextPart } from './content-part';\nimport {\n  convertDataContentToUint8Array,\n  convertUint8ArrayToText,\n} from './data-content';\n\ntype ContentPart = TextPart | ImagePart | FilePart;\n\n/**\n * Converts a list of attachments to a list of content parts\n * for consumption by `ai/core` functions.\n * Currently only supports images and text attachments.\n */\nexport function attachmentsToParts(attachments: Attachment[]): ContentPart[] {\n  const parts: ContentPart[] = [];\n\n  for (const attachment of attachments) {\n    let url;\n\n    try {\n      url = new URL(attachment.url);\n    } catch (error) {\n      throw new Error(`Invalid URL: ${attachment.url}`);\n    }\n\n    switch (url.protocol) {\n      case 'http:':\n      case 'https:': {\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({ type: 'image', image: url });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              'If the attachment is not an image, it must specify a content type',\n            );\n          }\n\n          parts.push({\n            type: 'file',\n            data: url,\n            mimeType: attachment.contentType,\n          });\n        }\n        break;\n      }\n\n      case 'data:': {\n        let header;\n        let base64Content;\n        let mimeType;\n\n        try {\n          [header, base64Content] = attachment.url.split(',');\n          mimeType = header.split(';')[0].split(':')[1];\n        } catch (error) {\n          throw new Error(`Error processing data URL: ${attachment.url}`);\n        }\n\n        if (mimeType == null || base64Content == null) {\n          throw new Error(`Invalid data URL format: ${attachment.url}`);\n        }\n\n        if (attachment.contentType?.startsWith('image/')) {\n          parts.push({\n            type: 'image',\n            image: convertDataContentToUint8Array(base64Content),\n          });\n        } else if (attachment.contentType?.startsWith('text/')) {\n          parts.push({\n            type: 'text',\n            text: convertUint8ArrayToText(\n              convertDataContentToUint8Array(base64Content),\n            ),\n          });\n        } else {\n          if (!attachment.contentType) {\n            throw new Error(\n              'If the attachment is not an image or text, it must specify a content type',\n            );\n          }\n\n          parts.push({\n            type: 'file',\n            data: base64Content,\n            mimeType: attachment.contentType,\n          });\n        }\n\n        break;\n      }\n\n      default: {\n        throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n      }\n    }\n  }\n\n  return parts;\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { Message } from '@ai-sdk/ui-utils';\n\nconst name = 'AI_MessageConversionError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class MessageConversionError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalMessage: Omit<Message, 'id'>;\n\n  constructor({\n    originalMessage,\n    message,\n  }: {\n    originalMessage: Omit<Message, 'id'>;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.originalMessage = originalMessage;\n  }\n\n  static isInstance(error: unknown): error is MessageConversionError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import {\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolInvocationUIPart,\n} from '@ai-sdk/ui-utils';\nimport { ToolSet } from '../generate-text/tool-set';\nimport {\n  AssistantContent,\n  CoreMessage,\n  ToolCallPart,\n  ToolResultPart,\n} from '../prompt';\nimport { attachmentsToParts } from './attachments-to-parts';\nimport { MessageConversionError } from './message-conversion-error';\n\n/**\nConverts an array of messages from useChat into an array of CoreMessages that can be used\nwith the AI core functions (e.g. `streamText`).\n */\nexport function convertToCoreMessages<TOOLS extends ToolSet = never>(\n  messages: Array<Omit<Message, 'id'>>,\n  options?: { tools?: TOOLS },\n) {\n  const tools = options?.tools ?? ({} as TOOLS);\n  const coreMessages: CoreMessage[] = [];\n\n  for (let i = 0; i < messages.length; i++) {\n    const message = messages[i];\n    const isLastMessage = i === messages.length - 1;\n    const { role, content, experimental_attachments } = message;\n\n    switch (role) {\n      case 'system': {\n        coreMessages.push({\n          role: 'system',\n          content,\n        });\n        break;\n      }\n\n      case 'user': {\n        if (message.parts == null) {\n          coreMessages.push({\n            role: 'user',\n            content: experimental_attachments\n              ? [\n                  { type: 'text', text: content },\n                  ...attachmentsToParts(experimental_attachments),\n                ]\n              : content,\n          });\n        } else {\n          const textParts = message.parts\n            .filter(part => part.type === 'text')\n            .map(part => ({\n              type: 'text' as const,\n              text: part.text,\n            }));\n\n          coreMessages.push({\n            role: 'user',\n            content: experimental_attachments\n              ? [...textParts, ...attachmentsToParts(experimental_attachments)]\n              : textParts,\n          });\n        }\n        break;\n      }\n\n      case 'assistant': {\n        if (message.parts != null) {\n          let currentStep = 0;\n          let blockHasToolInvocations = false;\n          let block: Array<\n            TextUIPart | ToolInvocationUIPart | ReasoningUIPart | FileUIPart\n          > = [];\n\n          function processBlock() {\n            const content: AssistantContent = [];\n\n            for (const part of block) {\n              switch (part.type) {\n                case 'file':\n                case 'text': {\n                  content.push(part);\n                  break;\n                }\n                case 'reasoning': {\n                  for (const detail of part.details) {\n                    switch (detail.type) {\n                      case 'text':\n                        content.push({\n                          type: 'reasoning' as const,\n                          text: detail.text,\n                          signature: detail.signature,\n                        });\n                        break;\n                      case 'redacted':\n                        content.push({\n                          type: 'redacted-reasoning' as const,\n                          data: detail.data,\n                        });\n                        break;\n                    }\n                  }\n                  break;\n                }\n                case 'tool-invocation':\n                  content.push({\n                    type: 'tool-call' as const,\n                    toolCallId: part.toolInvocation.toolCallId,\n                    toolName: part.toolInvocation.toolName,\n                    args: part.toolInvocation.args,\n                  });\n                  break;\n                default: {\n                  const _exhaustiveCheck: never = part;\n                  throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n                }\n              }\n            }\n\n            coreMessages.push({\n              role: 'assistant',\n              content,\n            });\n\n            // check if there are tool invocations with results in the block\n            const stepInvocations = block\n              .filter(\n                (\n                  part:\n                    | TextUIPart\n                    | ToolInvocationUIPart\n                    | ReasoningUIPart\n                    | FileUIPart,\n                ): part is ToolInvocationUIPart =>\n                  part.type === 'tool-invocation',\n              )\n              .map(part => part.toolInvocation);\n\n            // tool message with tool results\n            if (stepInvocations.length > 0) {\n              coreMessages.push({\n                role: 'tool',\n                content: stepInvocations.map(\n                  (toolInvocation): ToolResultPart => {\n                    if (!('result' in toolInvocation)) {\n                      throw new MessageConversionError({\n                        originalMessage: message,\n                        message:\n                          'ToolInvocation must have a result: ' +\n                          JSON.stringify(toolInvocation),\n                      });\n                    }\n\n                    const { toolCallId, toolName, result } = toolInvocation;\n\n                    const tool = tools[toolName];\n                    return tool?.experimental_toToolResultContent != null\n                      ? {\n                          type: 'tool-result',\n                          toolCallId,\n                          toolName,\n                          result: tool.experimental_toToolResultContent(result),\n                          experimental_content:\n                            tool.experimental_toToolResultContent(result),\n                        }\n                      : {\n                          type: 'tool-result',\n                          toolCallId,\n                          toolName,\n                          result,\n                        };\n                  },\n                ),\n              });\n            }\n\n            // updates for next block\n            block = [];\n            blockHasToolInvocations = false;\n            currentStep++;\n          }\n\n          for (const part of message.parts) {\n            switch (part.type) {\n              case 'text': {\n                if (blockHasToolInvocations) {\n                  processBlock(); // text must come before tool invocations\n                }\n                block.push(part);\n                break;\n              }\n              case 'file':\n              case 'reasoning': {\n                block.push(part);\n                break;\n              }\n              case 'tool-invocation': {\n                if ((part.toolInvocation.step ?? 0) !== currentStep) {\n                  processBlock();\n                }\n                block.push(part);\n                blockHasToolInvocations = true;\n                break;\n              }\n            }\n          }\n\n          processBlock();\n\n          break;\n        }\n\n        const toolInvocations = message.toolInvocations;\n\n        if (toolInvocations == null || toolInvocations.length === 0) {\n          coreMessages.push({ role: 'assistant', content });\n          break;\n        }\n\n        const maxStep = toolInvocations.reduce((max, toolInvocation) => {\n          return Math.max(max, toolInvocation.step ?? 0);\n        }, 0);\n\n        for (let i = 0; i <= maxStep; i++) {\n          const stepInvocations = toolInvocations.filter(\n            toolInvocation => (toolInvocation.step ?? 0) === i,\n          );\n\n          if (stepInvocations.length === 0) {\n            continue;\n          }\n\n          // assistant message with tool calls\n          coreMessages.push({\n            role: 'assistant',\n            content: [\n              ...(isLastMessage && content && i === 0\n                ? [{ type: 'text' as const, text: content }]\n                : []),\n              ...stepInvocations.map(\n                ({ toolCallId, toolName, args }): ToolCallPart => ({\n                  type: 'tool-call' as const,\n                  toolCallId,\n                  toolName,\n                  args,\n                }),\n              ),\n            ],\n          });\n\n          // tool message with tool results\n          coreMessages.push({\n            role: 'tool',\n            content: stepInvocations.map((toolInvocation): ToolResultPart => {\n              if (!('result' in toolInvocation)) {\n                throw new MessageConversionError({\n                  originalMessage: message,\n                  message:\n                    'ToolInvocation must have a result: ' +\n                    JSON.stringify(toolInvocation),\n                });\n              }\n\n              const { toolCallId, toolName, result } = toolInvocation;\n\n              const tool = tools[toolName];\n              return tool?.experimental_toToolResultContent != null\n                ? {\n                    type: 'tool-result',\n                    toolCallId,\n                    toolName,\n                    result: tool.experimental_toToolResultContent(result),\n                    experimental_content:\n                      tool.experimental_toToolResultContent(result),\n                  }\n                : {\n                    type: 'tool-result',\n                    toolCallId,\n                    toolName,\n                    result,\n                  };\n            }),\n          });\n        }\n\n        if (content && !isLastMessage) {\n          coreMessages.push({ role: 'assistant', content });\n        }\n\n        break;\n      }\n\n      case 'data': {\n        // ignore\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`,\n        });\n      }\n    }\n  }\n\n  return coreMessages;\n}\n", "import { z } from 'zod';\nimport { ProviderMetadata } from '../types';\nimport {\n  providerMetadataSchema,\n  ProviderOptions,\n} from '../types/provider-metadata';\nimport {\n  FilePart,\n  filePartSchema,\n  ImagePart,\n  imagePartSchema,\n  ReasoningPart,\n  reasoningPartSchema,\n  RedactedReasoningPart,\n  redactedReasoningPartSchema,\n  TextPart,\n  textPartSchema,\n  ToolCallPart,\n  toolCallPartSchema,\n  ToolResultPart,\n  toolResultPartSchema,\n} from './content-part';\n\n/**\n A system message. It can contain system information.\n\n Note: using the \"system\" part of the prompt is strongly preferred\n to increase the resilience against prompt injection attacks,\n and because not all providers support several system messages.\n */\nexport type CoreSystemMessage = {\n  role: 'system';\n  content: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreSystemMessageSchema: z.ZodType<CoreSystemMessage> = z.object({\n  role: z.literal('system'),\n  content: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nA user message. It can contain text or a combination of text and images.\n */\nexport type CoreUserMessage = {\n  role: 'user';\n  content: UserContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreUserMessageSchema: z.ZodType<CoreUserMessage> = z.object({\n  role: z.literal('user'),\n  content: z.union([\n    z.string(),\n    z.array(z.union([textPartSchema, imagePartSchema, filePartSchema])),\n  ]),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nContent of a user message. It can be a string or an array of text and image parts.\n */\nexport type UserContent = string | Array<TextPart | ImagePart | FilePart>;\n\n/**\nAn assistant message. It can contain text, tool calls, or a combination of text and tool calls.\n */\nexport type CoreAssistantMessage = {\n  role: 'assistant';\n  content: AssistantContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreAssistantMessageSchema: z.ZodType<CoreAssistantMessage> =\n  z.object({\n    role: z.literal('assistant'),\n    content: z.union([\n      z.string(),\n      z.array(\n        z.union([\n          textPartSchema,\n          filePartSchema,\n          reasoningPartSchema,\n          redactedReasoningPartSchema,\n          toolCallPartSchema,\n        ]),\n      ),\n    ]),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\nContent of an assistant message.\nIt can be a string or an array of text, image, reasoning, redacted reasoning, and tool call parts.\n */\nexport type AssistantContent =\n  | string\n  | Array<\n      TextPart | FilePart | ReasoningPart | RedactedReasoningPart | ToolCallPart\n    >;\n\n/**\nA tool message. It contains the result of one or more tool calls.\n */\nexport type CoreToolMessage = {\n  role: 'tool';\n  content: ToolContent;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n};\n\nexport const coreToolMessageSchema: z.ZodType<CoreToolMessage> = z.object({\n  role: z.literal('tool'),\n  content: z.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nContent of a tool message. It is an array of tool result parts.\n */\nexport type ToolContent = Array<ToolResultPart>;\n\n/**\nA message that can be used in the `messages` field of a prompt.\nIt can be a user message, an assistant message, or a tool message.\n */\nexport type CoreMessage =\n  | CoreSystemMessage\n  | CoreUserMessage\n  | CoreAssistantMessage\n  | CoreToolMessage;\n\nexport const coreMessageSchema: z.ZodType<CoreMessage> = z.union([\n  coreSystemMessageSchema,\n  coreUserMessageSchema,\n  coreAssistantMessageSchema,\n  coreToolMessageSchema,\n]);\n", "import { LanguageModelV1ProviderMetadata } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { jsonValueSchema } from './json-value';\n\n/**\nAdditional provider-specific metadata that is returned from the provider.\n\nThis is needed to enable provider-specific functionality that can be\nfully encapsulated in the provider.\n */\nexport type ProviderMetadata = LanguageModelV1ProviderMetadata;\n\n/**\nAdditional provider-specific options.\n\nThey are passed through to the provider from the AI SDK and enable\nprovider-specific functionality that can be fully encapsulated in the provider.\n */\n// TODO change to LanguageModelV2ProviderOptions in language model v2\nexport type ProviderOptions = LanguageModelV1ProviderMetadata;\n\nexport const providerMetadataSchema: z.ZodType<ProviderMetadata> = z.record(\n  z.string(),\n  z.record(z.string(), jsonValueSchema),\n);\n", "import { JSONValue } from '@ai-sdk/provider';\nimport { z } from 'zod';\n\nexport const jsonValueSchema: z.ZodType<JSONValue> = z.lazy(() =>\n  z.union([\n    z.null(),\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.record(z.string(), jsonValueSchema),\n    z.array(jsonValueSchema),\n  ]),\n);\n", "import { z } from 'zod';\nimport {\n  ProviderMetadata,\n  providerMetadataSchema,\n  ProviderOptions,\n} from '../types/provider-metadata';\nimport { DataContent, dataContentSchema } from './data-content';\nimport {\n  ToolResultContent,\n  toolResultContentSchema,\n} from './tool-result-content';\n\n/**\nText content part of a prompt. It contains a string of text.\n */\nexport interface TextPart {\n  type: 'text';\n\n  /**\nThe text content.\n   */\n  text: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const textPartSchema: z.ZodType<TextPart> = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nImage content part of a prompt. It contains an image.\n */\nexport interface ImagePart {\n  type: 'image';\n\n  /**\nImage data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  image: DataContent | URL;\n\n  /**\nOptional mime type of the image.\n   */\n  mimeType?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const imagePartSchema: z.ZodType<ImagePart> = z.object({\n  type: z.literal('image'),\n  image: z.union([dataContentSchema, z.instanceof(URL)]),\n  mimeType: z.string().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nFile content part of a prompt. It contains a file.\n */\nexport interface FilePart {\n  type: 'file';\n\n  /**\nFile data. Can either be:\n\n- data: a base64-encoded string, a Uint8Array, an ArrayBuffer, or a Buffer\n- URL: a URL that points to the image\n   */\n  data: DataContent | URL;\n\n  /**\nOptional filename of the file.\n   */\n  filename?: string;\n\n  /**\nMime type of the file.\n   */\n  mimeType: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const filePartSchema: z.ZodType<FilePart> = z.object({\n  type: z.literal('file'),\n  data: z.union([dataContentSchema, z.instanceof(URL)]),\n  filename: z.string().optional(),\n  mimeType: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\n * Reasoning content part of a prompt. It contains a reasoning.\n */\nexport interface ReasoningPart {\n  type: 'reasoning';\n\n  /**\nThe reasoning text.\n   */\n  text: string;\n\n  /**\nAn optional signature for verifying that the reasoning originated from the model.\n   */\n  signature?: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const reasoningPartSchema: z.ZodType<ReasoningPart> = z.object({\n  type: z.literal('reasoning'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n});\n\n/**\nRedacted reasoning content part of a prompt.\n */\nexport interface RedactedReasoningPart {\n  type: 'redacted-reasoning';\n\n  /**\nRedacted reasoning data.\n   */\n  data: string;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const redactedReasoningPartSchema: z.ZodType<RedactedReasoningPart> =\n  z.object({\n    type: z.literal('redacted-reasoning'),\n    data: z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional(),\n  });\n\n/**\nTool call content part of a prompt. It contains a tool call (usually generated by the AI model).\n */\nexport interface ToolCallPart {\n  type: 'tool-call';\n\n  /**\nID of the tool call. This ID is used to match the tool call with the tool result.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that is being called.\n */\n  toolName: string;\n\n  /**\nArguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.\n   */\n  args: unknown;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const toolCallPartSchema: z.ZodType<ToolCallPart> = z.object({\n  type: z.literal('tool-call'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  args: z.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolCallPart>; // necessary bc args is optional on Zod type\n\n/**\nTool result content part of a prompt. It contains the result of the tool call with the matching ID.\n */\nexport interface ToolResultPart {\n  type: 'tool-result';\n\n  /**\nID of the tool call that this result is associated with.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that generated this result.\n  */\n  toolName: string;\n\n  /**\nResult of the tool call. This is a JSON-serializable object.\n   */\n  result: unknown;\n\n  /**\nMulti-part content of the tool result. Only for tools that support multipart results.\n   */\n  experimental_content?: ToolResultContent;\n\n  /**\nOptional flag if the result is an error or an error message.\n   */\n  isError?: boolean;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n\n  /**\n@deprecated Use `providerOptions` instead.\n */\n  experimental_providerMetadata?: ProviderMetadata;\n}\n\n/**\n@internal\n */\nexport const toolResultPartSchema: z.ZodType<ToolResultPart> = z.object({\n  type: z.literal('tool-result'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  result: z.unknown(),\n  content: toolResultContentSchema.optional(),\n  isError: z.boolean().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n  experimental_providerMetadata: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolResultPart>; // necessary bc result is optional on Zod type\n", "import { z } from 'zod';\n\nexport type ToolResultContent = Array<\n  | {\n      type: 'text';\n      text: string;\n    }\n  | {\n      type: 'image';\n      data: string; // base64 encoded png image, e.g. screenshot\n      mimeType?: string; // e.g. 'image/png';\n    }\n>;\n\nexport const toolResultContentSchema: z.ZodType<ToolResultContent> = z.array(\n  z.union([\n    z.object({ type: z.literal('text'), text: z.string() }),\n    z.object({\n      type: z.literal('image'),\n      data: z.string(),\n      mimeType: z.string().optional(),\n    }),\n  ]),\n);\n\nexport function isToolResultContent(\n  value: unknown,\n): value is ToolResultContent {\n  if (!Array.isArray(value) || value.length === 0) {\n    return false;\n  }\n\n  return value.every(part => {\n    if (typeof part !== 'object' || part === null) {\n      return false;\n    }\n\n    if (part.type === 'text') {\n      return typeof part.text === 'string';\n    }\n\n    if (part.type === 'image') {\n      return (\n        typeof part.data === 'string' &&\n        (part.mimeType === undefined || typeof part.mimeType === 'string')\n      );\n    }\n\n    return false;\n  });\n}\n", "/**\nRepresents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\nThe number of tokens used in the prompt.\n   */\n  promptTokens: number;\n\n  /**\nThe number of tokens used in the completion.\n */\n  completionTokens: number;\n\n  /**\nThe total number of tokens used (promptTokens + completionTokens).\n   */\n  totalTokens: number;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens,\n}: {\n  promptTokens: number;\n  completionTokens: number;\n}): LanguageModelUsage {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens,\n  };\n}\n\nexport function addLanguageModelUsage(\n  usage1: LanguageModelUsage,\n  usage2: LanguageModelUsage,\n): LanguageModelUsage {\n  return {\n    promptTokens: usage1.promptTokens + usage2.promptTokens,\n    completionTokens: usage1.completionTokens + usage2.completionTokens,\n    totalTokens: usage1.totalTokens + usage2.totalTokens,\n  };\n}\n", "import { JSONSchema7 } from '@ai-sdk/provider';\n\nconst DEFAULT_SCHEMA_PREFIX = 'JSON schema:';\nconst DEFAULT_SCHEMA_SUFFIX =\n  'You MUST answer with a JSON object that matches the JSON schema above.';\nconst DEFAULT_GENERIC_SUFFIX = 'You MUST answer with JSON.';\n\nexport function injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : undefined,\n  schemaSuffix = schema != null\n    ? DEFAULT_SCHEMA_SUFFIX\n    : DEFAULT_GENERIC_SUFFIX,\n}: {\n  prompt?: string;\n  schema?: JSONSchema7;\n  schemaPrefix?: string;\n  schemaSuffix?: string;\n}): string {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : undefined,\n    prompt != null && prompt.length > 0 ? '' : undefined, // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : undefined,\n    schemaSuffix,\n  ]\n    .filter(line => line != null)\n    .join('\\n');\n}\n", "import {\n  isJSONArray,\n  isJSONObject,\n  JSONObject,\n  JSONSchema7,\n  JSONValue,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { safeValidateTypes, ValidationResult } from '@ai-sdk/provider-utils';\nimport { asSchema, DeepPartial, Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { ObjectStreamPart } from './stream-object-result';\nimport {\n  FinishReason,\n  LanguageModelResponseMetadata,\n  LanguageModelUsage,\n} from '../types';\n\nexport interface OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM> {\n  readonly type: 'object' | 'array' | 'enum' | 'no-schema';\n  readonly jsonSchema: JSONSchema7 | undefined;\n\n  validatePartialResult({\n    value,\n    textDelta,\n    isFinalDelta,\n  }: {\n    value: JSONValue;\n    textDelta: string;\n    isFirstDelta: boolean;\n    isFinalDelta: boolean;\n    latestObject: PARTIAL | undefined;\n  }): ValidationResult<{\n    partial: PARTIAL;\n    textDelta: string;\n  }>;\n  validateFinalResult(\n    value: JSONValue | undefined,\n    context: {\n      text: string;\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n    },\n  ): ValidationResult<RESULT>;\n\n  createElementStream(\n    originalStream: ReadableStream<ObjectStreamPart<PARTIAL>>,\n  ): ELEMENT_STREAM;\n}\n\nconst noSchemaOutputStrategy: OutputStrategy<JSONValue, JSONValue, never> = {\n  type: 'no-schema',\n  jsonSchema: undefined,\n\n  validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n\n  validateFinalResult(\n    value: JSONValue | undefined,\n    context: {\n      text: string;\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): ValidationResult<JSONValue> {\n    return value === undefined\n      ? {\n          success: false,\n          error: new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            text: context.text,\n            response: context.response,\n            usage: context.usage,\n            finishReason: context.finishReason,\n          }),\n        }\n      : { success: true, value };\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in no-schema mode',\n    });\n  },\n};\n\nconst objectOutputStrategy = <OBJECT>(\n  schema: Schema<OBJECT>,\n): OutputStrategy<DeepPartial<OBJECT>, OBJECT, never> => ({\n  type: 'object',\n  jsonSchema: schema.jsonSchema,\n\n  validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value as DeepPartial<OBJECT>,\n        textDelta,\n      },\n    };\n  },\n\n  validateFinalResult(value: JSONValue | undefined): ValidationResult<OBJECT> {\n    return safeValidateTypes({ value, schema });\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in object mode',\n    });\n  },\n});\n\nconst arrayOutputStrategy = <ELEMENT>(\n  schema: Schema<ELEMENT>,\n): OutputStrategy<ELEMENT[], ELEMENT[], AsyncIterableStream<ELEMENT>> => {\n  // remove $schema from schema.jsonSchema:\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n\n  return {\n    type: 'enum',\n\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        elements: { type: 'array', items: itemSchema },\n      },\n      required: ['elements'],\n      additionalProperties: false,\n    },\n\n    validatePartialResult({ value, latestObject, isFirstDelta, isFinalDelta }) {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n      const resultArray: Array<ELEMENT> = [];\n\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = safeValidateTypes({ value: element, schema });\n\n        // special treatment for last processed element:\n        // ignore parse or validation failures, since they indicate that the\n        // last element is incomplete and should not be included in the result,\n        // unless it is the final delta\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n\n        if (!result.success) {\n          return result;\n        }\n\n        resultArray.push(result.value);\n      }\n\n      // calculate delta:\n      const publishedElementCount = latestObject?.length ?? 0;\n\n      let textDelta = '';\n\n      if (isFirstDelta) {\n        textDelta += '[';\n      }\n\n      if (publishedElementCount > 0) {\n        textDelta += ',';\n      }\n\n      textDelta += resultArray\n        .slice(publishedElementCount) // only new elements\n        .map(element => JSON.stringify(element))\n        .join(',');\n\n      if (isFinalDelta) {\n        textDelta += ']';\n      }\n\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta,\n        },\n      };\n    },\n\n    validateFinalResult(\n      value: JSONValue | undefined,\n    ): ValidationResult<Array<ELEMENT>> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n\n      // check that each element in the array is of the correct type:\n      for (const element of inputArray) {\n        const result = safeValidateTypes({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n\n      return { success: true, value: inputArray as Array<ELEMENT> };\n    },\n\n    createElementStream(\n      originalStream: ReadableStream<ObjectStreamPart<ELEMENT[]>>,\n    ) {\n      let publishedElements = 0;\n\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream<ObjectStreamPart<ELEMENT[]>, ELEMENT>({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case 'object': {\n                  const array = chunk.object;\n\n                  // publish new elements one by one:\n                  for (\n                    ;\n                    publishedElements < array.length;\n                    publishedElements++\n                  ) {\n                    controller.enqueue(array[publishedElements]);\n                  }\n\n                  break;\n                }\n\n                case 'text-delta':\n                case 'finish':\n                case 'error': // suppress error (use onError instead)\n                  break;\n\n                default: {\n                  const _exhaustiveCheck: never = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`,\n                  );\n                }\n              }\n            },\n          }),\n        ),\n      );\n    },\n  };\n};\n\nconst enumOutputStrategy = <ENUM extends string>(\n  enumValues: Array<ENUM>,\n): OutputStrategy<ENUM, ENUM, never> => {\n  return {\n    type: 'enum',\n\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        result: { type: 'string', enum: enumValues },\n      },\n      required: ['result'],\n      additionalProperties: false,\n    },\n\n    validateFinalResult(value: JSONValue | undefined): ValidationResult<ENUM> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || typeof value.result !== 'string') {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause:\n              'value must be an object that contains a string in the \"result\" property.',\n          }),\n        };\n      }\n\n      const result = value.result as string;\n\n      return enumValues.includes(result as ENUM)\n        ? { success: true, value: result as ENUM }\n        : {\n            success: false,\n            error: new TypeValidationError({\n              value,\n              cause: 'value must be a string in the enum',\n            }),\n          };\n    },\n\n    validatePartialResult() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'partial results in enum mode',\n      });\n    },\n\n    createElementStream() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'element streams in enum mode',\n      });\n    },\n  };\n};\n\nexport function getOutputStrategy<SCHEMA>({\n  output,\n  schema,\n  enumValues,\n}: {\n  output: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n  enumValues?: Array<SCHEMA>;\n}): OutputStrategy<any, any, any> {\n  switch (output) {\n    case 'object':\n      return objectOutputStrategy(asSchema(schema!));\n    case 'array':\n      return arrayOutputStrategy(asSchema(schema!));\n    case 'enum':\n      return enumOutputStrategy(enumValues! as Array<string>);\n    case 'no-schema':\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck: never = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n", "export type AsyncIterableStream<T> = AsyncIterable<T> & ReadableStream<T>;\n\nexport function createAsyncIterableStream<T>(\n  source: ReadableStream<T>,\n): AsyncIterableStream<T> {\n  const stream = source.pipeThrough(new TransformStream<T, T>());\n\n  (stream as AsyncIterableStream<T>)[Symbol.asyncIterator] = () => {\n    const reader = stream.getReader();\n    return {\n      async next(): Promise<IteratorResult<T>> {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: undefined } : { done: false, value };\n      },\n    };\n  };\n\n  return stream as AsyncIterableStream<T>;\n}\n", "import { z } from 'zod';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { Schema } from '@ai-sdk/ui-utils';\n\nexport function validateObjectGenerationInput({\n  output,\n  mode,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues,\n}: {\n  output?: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: z.Schema<any, z.ZodTypeDef, any> | Schema<any>;\n  schemaName?: string;\n  schemaDescription?: string;\n  enumValues?: Array<unknown>;\n  mode?: 'auto' | 'json' | 'tool';\n}) {\n  if (\n    output != null &&\n    output !== 'object' &&\n    output !== 'array' &&\n    output !== 'enum' &&\n    output !== 'no-schema'\n  ) {\n    throw new InvalidArgumentError({\n      parameter: 'output',\n      value: output,\n      message: 'Invalid output type.',\n    });\n  }\n\n  if (output === 'no-schema') {\n    if (mode === 'auto' || mode === 'tool') {\n      throw new InvalidArgumentError({\n        parameter: 'mode',\n        value: mode,\n        message: 'Mode must be \"json\" for no-schema output.',\n      });\n    }\n\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for no-schema output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for no-schema output.',\n      });\n    }\n  }\n\n  if (output === 'object') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is required for object output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for object output.',\n      });\n    }\n  }\n\n  if (output === 'array') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Element schema is required for array output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for array output.',\n      });\n    }\n  }\n\n  if (output === 'enum') {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for enum output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for enum output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for enum output.',\n      });\n    }\n\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are required for enum output.',\n      });\n    }\n\n    for (const value of enumValues) {\n      if (typeof value !== 'string') {\n        throw new InvalidArgumentError({\n          parameter: 'enumValues',\n          value,\n          message: 'Enum values must be strings.',\n        });\n      }\n    }\n  }\n}\n", "/**\n * Helper utility to serialize prompt content for OpenTelemetry tracing.\n * It is initially created because normalized LanguageModelV1Prompt carries\n * images as Uint8Arrays, on which JSON.stringify acts weirdly, converting\n * them to objects with stringified indices as keys, e.g. {\"0\": 42, \"1\": 69 }.\n */\n\nimport {\n  LanguageModelV1ImagePart,\n  LanguageModelV1Message,\n  LanguageModelV1Prompt,\n  LanguageModelV1ProviderMetadata,\n} from '@ai-sdk/provider';\nimport { convertDataContentToBase64String } from './data-content';\n\nexport function stringifyForTelemetry(prompt: LanguageModelV1Prompt): string {\n  const processedPrompt = prompt.map((message: LanguageModelV1Message) => {\n    return {\n      ...message,\n      content:\n        typeof message.content === 'string'\n          ? message.content\n          : message.content.map(processPart),\n    };\n  });\n\n  return JSON.stringify(processedPrompt);\n}\n\ntype MessageContentPart = Exclude<\n  LanguageModelV1Message['content'],\n  string\n>[number];\ntype ProcessedMessageContentPart =\n  | Exclude<MessageContentPart, LanguageModelV1ImagePart>\n  | {\n      type: 'image';\n      image: string | URL;\n      mimeType?: string;\n      providerMetadata?: LanguageModelV1ProviderMetadata;\n    };\n\nfunction processPart(part: MessageContentPart): ProcessedMessageContentPart {\n  if (part.type === 'image') {\n    return {\n      ...part,\n      image:\n        part.image instanceof Uint8Array\n          ? convertDataContentToBase64String(part.image)\n          : part.image,\n    };\n  }\n  return part;\n}\n", "import {\n  JSONValue,\n  LanguageModelV1CallOptions,\n  LanguageModelV1FinishReason,\n  LanguageModelV1StreamPart,\n} from '@ai-sdk/provider';\nimport { createIdGenerator } from '@ai-sdk/provider-utils';\nimport {\n  DeepPartial,\n  Schema,\n  isDeepEqualData,\n  parsePartialJson,\n} from '@ai-sdk/ui-utils';\nimport { ServerResponse } from 'http';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors/no-object-generated-error';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n} from '../types/language-model';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport {\n  LanguageModelUsage,\n  calculateLanguageModelUsage,\n} from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { injectJsonInstruction } from './inject-json-instruction';\nimport { OutputStrategy, getOutputStrategy } from './output-strategy';\nimport { ObjectStreamPart, StreamObjectResult } from './stream-object-result';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnFinishCallback<RESULT> = (event: {\n  /**\nThe token usage of the generated response.\n*/\n  usage: LanguageModelUsage;\n\n  /**\nThe generated object. Can be undefined if the final object does not match the schema.\n*/\n  object: RESULT | undefined;\n\n  /**\nOptional error object. This is e.g. a TypeValidationError when the final object does not match the schema.\n*/\n  error: unknown | undefined;\n\n  /**\nResponse metadata.\n */\n  response: LanguageModelResponseMetadata;\n\n  /**\nWarnings from the model provider (e.g. unsupported settings).\n*/\n  warnings?: CallWarning[];\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n*/\n  providerMetadata: ProviderMetadata | undefined;\n\n  /**\n@deprecated Use `providerMetadata` instead.\n*/\n  experimental_providerMetadata?: ProviderMetadata;\n}) => Promise<void> | void;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject<OBJECT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output?: 'object' | undefined;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe schema of the object that the model should generate.\n */\n      schema: z.Schema<OBJECT, z.ZodTypeDef, any> | Schema<OBJECT>;\n\n      /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<OBJECT>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<DeepPartial<OBJECT>, OBJECT, never>;\n/**\nGenerate an array with structured, typed elements for a given prompt and element schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject<ELEMENT>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'array';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe element schema of the array that the model should generate.\n */\n      schema: z.Schema<ELEMENT, z.ZodTypeDef, any> | Schema<ELEMENT>;\n\n      /**\nOptional name of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n     */\n      schemaName?: string;\n\n      /**\nOptional description of the array that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n */\n      schemaDescription?: string;\n\n      /**\nThe mode to use for object generation.\n\nThe schema is converted into a JSON schema and used in one of the following ways\n\n- 'auto': The provider will choose the best mode for the model.\n- 'tool': A tool with the JSON schema as parameters is provided and the provider is instructed to use it.\n- 'json': The JSON schema and an instruction are injected into the prompt. If the provider supports JSON mode, it is enabled. If the provider supports JSON grammars, the grammar is used.\n\nPlease note that most providers do not support all modes.\n\nDefault and recommended: 'auto' (best mode for the model).\n     */\n      mode?: 'auto' | 'json' | 'tool';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<Array<ELEMENT>>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<\n  Array<ELEMENT>,\n  Array<ELEMENT>,\n  AsyncIterableStream<ELEMENT>\n>;\n/**\nGenerate JSON with any schema for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@return\nA result object for accessing the partial object stream and additional information.\n */\nexport function streamObject(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt & {\n      output: 'no-schema';\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nThe mode to use for object generation. Must be \"json\" for no-schema output.\n     */\n      mode?: 'json';\n\n      /**\nOptional telemetry configuration (experimental).\n     */\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\n@deprecated Use `providerOptions` instead.\n*/\n      experimental_providerMetadata?: ProviderMetadata;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n     */\n      onFinish?: StreamObjectOnFinishCallback<JSONValue>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<JSONValue, JSONValue, never>;\nexport function streamObject<SCHEMA, PARTIAL, RESULT, ELEMENT_STREAM>({\n  model,\n  schema: inputSchema,\n  schemaName,\n  schemaDescription,\n  mode,\n  output = 'object',\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  onError,\n  onFinish,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n    now = originalNow,\n  } = {},\n  ...settings\n}: Omit<CallSettings, 'stopSequences'> &\n  Prompt & {\n    /**\n     * The expected structure of the output.\n     *\n     * - 'object': Generate a single object that conforms to the schema.\n     * - 'array': Generate an array of objects that conform to the schema.\n     * - 'no-schema': Generate any JSON object. No schema is specified.\n     *\n     * Default is 'object' if not specified.\n     */\n    output?: 'object' | 'array' | 'no-schema';\n\n    model: LanguageModel;\n    schema?: z.Schema<SCHEMA, z.ZodTypeDef, any> | Schema<SCHEMA>;\n    schemaName?: string;\n    schemaDescription?: string;\n    mode?: 'auto' | 'json' | 'tool';\n    experimental_telemetry?: TelemetrySettings;\n    providerOptions?: ProviderOptions;\n    experimental_providerMetadata?: ProviderMetadata;\n    onError?: StreamObjectOnErrorCallback;\n    onFinish?: StreamObjectOnFinishCallback<RESULT>;\n    _internal?: {\n      generateId?: () => string;\n      currentDate?: () => Date;\n      now?: () => number;\n    };\n  }): StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM> {\n  validateObjectGenerationInput({\n    output,\n    mode,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n  });\n\n  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });\n\n  // automatically set mode to 'json' for no-schema output\n  if (outputStrategy.type === 'no-schema' && mode === undefined) {\n    mode = 'json';\n  }\n\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId,\n    currentDate,\n    now,\n  });\n}\n\nclass DefaultStreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n  implements StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n{\n  private readonly objectPromise = new DelayedPromise<RESULT>();\n  private readonly usagePromise = new DelayedPromise<LanguageModelUsage>();\n  private readonly providerMetadataPromise = new DelayedPromise<\n    ProviderMetadata | undefined\n  >();\n  private readonly warningsPromise = new DelayedPromise<\n    CallWarning[] | undefined\n  >();\n  private readonly requestPromise =\n    new DelayedPromise<LanguageModelRequestMetadata>();\n  private readonly responsePromise =\n    new DelayedPromise<LanguageModelResponseMetadata>();\n\n  private readonly baseStream: ReadableStream<ObjectStreamPart<PARTIAL>>;\n\n  private readonly outputStrategy: OutputStrategy<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >;\n\n  constructor({\n    model,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    mode,\n    onError,\n    onFinish,\n    generateId,\n    currentDate,\n    now,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    outputStrategy: OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM>;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    schemaName: string | undefined;\n    schemaDescription: string | undefined;\n    providerOptions: ProviderOptions | undefined;\n    mode: 'auto' | 'json' | 'tool' | undefined;\n    onError: StreamObjectOnErrorCallback | undefined;\n    onFinish: StreamObjectOnFinishCallback<RESULT> | undefined;\n    generateId: () => string;\n    currentDate: () => Date;\n    now: () => number;\n  }) {\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n    });\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries },\n    });\n\n    const tracer = getTracer(telemetry);\n    const self = this;\n\n    const stitchableStream =\n      createStitchableStream<ObjectStreamPart<PARTIAL>>();\n\n    const eventProcessor = new TransformStream<\n      ObjectStreamPart<PARTIAL>,\n      ObjectStreamPart<PARTIAL>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n\n        if (chunk.type === 'error') {\n          onError?.({ error: chunk.error });\n        }\n      },\n    });\n\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n\n    recordSpan({\n      name: 'ai.streamObject',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: 'ai.streamObject',\n            telemetry,\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.schema':\n            outputStrategy.jsonSchema != null\n              ? { input: () => JSON.stringify(outputStrategy.jsonSchema) }\n              : undefined,\n          'ai.schema.name': schemaName,\n          'ai.schema.description': schemaDescription,\n          'ai.settings.output': outputStrategy.type,\n          'ai.settings.mode': mode,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpan => {\n        // use the default provider mode when the mode is set to 'auto' or unspecified\n        if (mode === 'auto' || mode == null) {\n          mode = model.defaultObjectGenerationMode;\n        }\n\n        let callOptions: LanguageModelV1CallOptions;\n        let transformer: Transformer<\n          LanguageModelV1StreamPart,\n          string | Omit<LanguageModelV1StreamPart, 'text-delta'>\n        >;\n\n        switch (mode) {\n          case 'json': {\n            const standardizedPrompt = standardizePrompt({\n              prompt: {\n                system:\n                  outputStrategy.jsonSchema == null\n                    ? injectJsonInstruction({ prompt: system })\n                    : model.supportsStructuredOutputs\n                      ? system\n                      : injectJsonInstruction({\n                          prompt: system,\n                          schema: outputStrategy.jsonSchema,\n                        }),\n                prompt,\n                messages,\n              },\n              tools: undefined,\n            });\n\n            callOptions = {\n              mode: {\n                type: 'object-json',\n                schema: outputStrategy.jsonSchema,\n                name: schemaName,\n                description: schemaDescription,\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers,\n            };\n\n            transformer = {\n              transform: (chunk, controller) => {\n                switch (chunk.type) {\n                  case 'text-delta':\n                    controller.enqueue(chunk.textDelta);\n                    break;\n                  case 'response-metadata':\n                  case 'finish':\n                  case 'error':\n                    controller.enqueue(chunk);\n                    break;\n                }\n              },\n            };\n\n            break;\n          }\n\n          case 'tool': {\n            const standardizedPrompt = standardizePrompt({\n              prompt: { system, prompt, messages },\n              tools: undefined,\n            });\n\n            callOptions = {\n              mode: {\n                type: 'object-tool',\n                tool: {\n                  type: 'function',\n                  name: schemaName ?? 'json',\n                  description:\n                    schemaDescription ?? 'Respond with a JSON object.',\n                  parameters: outputStrategy.jsonSchema!,\n                },\n              },\n              ...prepareCallSettings(settings),\n              inputFormat: standardizedPrompt.type,\n              prompt: await convertToLanguageModelPrompt({\n                prompt: standardizedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context,\n              }),\n              providerMetadata: providerOptions,\n              abortSignal,\n              headers,\n            };\n\n            transformer = {\n              transform(chunk, controller) {\n                switch (chunk.type) {\n                  case 'tool-call-delta':\n                    controller.enqueue(chunk.argsTextDelta);\n                    break;\n                  case 'response-metadata':\n                  case 'finish':\n                  case 'error':\n                    controller.enqueue(chunk);\n                    break;\n                }\n              },\n            };\n\n            break;\n          }\n\n          case undefined: {\n            throw new Error(\n              'Model does not have a default object generation mode.',\n            );\n          }\n\n          default: {\n            const _exhaustiveCheck: never = mode;\n            throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n          }\n        }\n\n        const {\n          result: { stream, warnings, rawResponse, request },\n          doStreamSpan,\n          startTimestampMs,\n        } = await retry(() =>\n          recordSpan({\n            name: 'ai.streamObject.doStream',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.streamObject.doStream',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                'ai.prompt.format': {\n                  input: () => callOptions.inputFormat,\n                },\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(callOptions.prompt),\n                },\n                'ai.settings.mode': mode,\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': model.provider,\n                'gen_ai.request.model': model.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async doStreamSpan => ({\n              startTimestampMs: now(),\n              doStreamSpan,\n              result: await model.doStream(callOptions),\n            }),\n          }),\n        );\n\n        self.requestPromise.resolve(request ?? {});\n\n        // store information for onFinish callback:\n        let usage: LanguageModelUsage | undefined;\n        let finishReason: LanguageModelV1FinishReason | undefined;\n        let providerMetadata: ProviderMetadata | undefined;\n        let object: RESULT | undefined;\n        let error: unknown | undefined;\n\n        // pipe chunks through a transformation stream that extracts metadata:\n        let accumulatedText = '';\n        let textDelta = '';\n        let response: {\n          id: string;\n          timestamp: Date;\n          modelId: string;\n        } = {\n          id: generateId(),\n          timestamp: currentDate(),\n          modelId: model.modelId,\n        };\n\n        // Keep track of raw parse result before type validation, since e.g. Zod might\n        // change the object by mapping properties.\n        let latestObjectJson: JSONValue | undefined = undefined;\n        let latestObject: PARTIAL | undefined = undefined;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n\n        const transformedStream = stream\n          .pipeThrough(new TransformStream(transformer))\n          .pipeThrough(\n            new TransformStream<\n              string | ObjectStreamInputPart,\n              ObjectStreamPart<PARTIAL>\n            >({\n              async transform(chunk, controller): Promise<void> {\n                // Telemetry event for first chunk:\n                if (isFirstChunk) {\n                  const msToFirstChunk = now() - startTimestampMs;\n\n                  isFirstChunk = false;\n\n                  doStreamSpan.addEvent('ai.stream.firstChunk', {\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n\n                  doStreamSpan.setAttributes({\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n                }\n\n                // process partial text chunks\n                if (typeof chunk === 'string') {\n                  accumulatedText += chunk;\n                  textDelta += chunk;\n\n                  const { value: currentObjectJson, state: parseState } =\n                    parsePartialJson(accumulatedText);\n\n                  if (\n                    currentObjectJson !== undefined &&\n                    !isDeepEqualData(latestObjectJson, currentObjectJson)\n                  ) {\n                    const validationResult =\n                      outputStrategy.validatePartialResult({\n                        value: currentObjectJson,\n                        textDelta,\n                        latestObject,\n                        isFirstDelta,\n                        isFinalDelta: parseState === 'successful-parse',\n                      });\n\n                    if (\n                      validationResult.success &&\n                      !isDeepEqualData(\n                        latestObject,\n                        validationResult.value.partial,\n                      )\n                    ) {\n                      // inside inner check to correctly parse the final element in array mode:\n                      latestObjectJson = currentObjectJson;\n                      latestObject = validationResult.value.partial;\n\n                      controller.enqueue({\n                        type: 'object',\n                        object: latestObject,\n                      });\n\n                      controller.enqueue({\n                        type: 'text-delta',\n                        textDelta: validationResult.value.textDelta,\n                      });\n\n                      textDelta = '';\n                      isFirstDelta = false;\n                    }\n                  }\n\n                  return;\n                }\n\n                switch (chunk.type) {\n                  case 'response-metadata': {\n                    response = {\n                      id: chunk.id ?? response.id,\n                      timestamp: chunk.timestamp ?? response.timestamp,\n                      modelId: chunk.modelId ?? response.modelId,\n                    };\n                    break;\n                  }\n\n                  case 'finish': {\n                    // send final text delta:\n                    if (textDelta !== '') {\n                      controller.enqueue({ type: 'text-delta', textDelta });\n                    }\n\n                    // store finish reason for telemetry:\n                    finishReason = chunk.finishReason;\n\n                    // store usage and metadata for promises and onFinish callback:\n                    usage = calculateLanguageModelUsage(chunk.usage);\n                    providerMetadata = chunk.providerMetadata;\n\n                    controller.enqueue({ ...chunk, usage, response });\n\n                    // resolve promises that can be resolved now:\n                    self.usagePromise.resolve(usage);\n                    self.providerMetadataPromise.resolve(providerMetadata);\n                    self.responsePromise.resolve({\n                      ...response,\n                      headers: rawResponse?.headers,\n                    });\n\n                    // resolve the object promise with the latest object:\n                    const validationResult = outputStrategy.validateFinalResult(\n                      latestObjectJson,\n                      {\n                        text: accumulatedText,\n                        response,\n                        usage,\n                      },\n                    );\n\n                    if (validationResult.success) {\n                      object = validationResult.value;\n                      self.objectPromise.resolve(object);\n                    } else {\n                      error = new NoObjectGeneratedError({\n                        message:\n                          'No object generated: response did not match schema.',\n                        cause: validationResult.error,\n                        text: accumulatedText,\n                        response,\n                        usage,\n                        finishReason: finishReason,\n                      });\n                      self.objectPromise.reject(error);\n                    }\n\n                    break;\n                  }\n\n                  default: {\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                }\n              },\n\n              // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n              async flush(controller) {\n                try {\n                  const finalUsage = usage ?? {\n                    promptTokens: NaN,\n                    completionTokens: NaN,\n                    totalTokens: NaN,\n                  };\n\n                  doStreamSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.response.finishReason': finishReason,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                        'ai.response.id': response.id,\n                        'ai.response.model': response.modelId,\n                        'ai.response.timestamp':\n                          response.timestamp.toISOString(),\n\n                        'ai.usage.promptTokens': finalUsage.promptTokens,\n                        'ai.usage.completionTokens':\n                          finalUsage.completionTokens,\n\n                        // standardized gen-ai llm span attributes:\n                        'gen_ai.response.finish_reasons': [finishReason],\n                        'gen_ai.response.id': response.id,\n                        'gen_ai.response.model': response.modelId,\n                        'gen_ai.usage.input_tokens': finalUsage.promptTokens,\n                        'gen_ai.usage.output_tokens':\n                          finalUsage.completionTokens,\n                      },\n                    }),\n                  );\n\n                  // finish doStreamSpan before other operations for correct timing:\n                  doStreamSpan.end();\n\n                  // Add response information to the root span:\n                  rootSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.usage.promptTokens': finalUsage.promptTokens,\n                        'ai.usage.completionTokens':\n                          finalUsage.completionTokens,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                      },\n                    }),\n                  );\n\n                  // call onFinish callback:\n                  await onFinish?.({\n                    usage: finalUsage,\n                    object,\n                    error,\n                    response: {\n                      ...response,\n                      headers: rawResponse?.headers,\n                    },\n                    warnings,\n                    providerMetadata,\n                    experimental_providerMetadata: providerMetadata,\n                  });\n                } catch (error) {\n                  controller.enqueue({ type: 'error', error });\n                } finally {\n                  rootSpan.end();\n                }\n              },\n            }),\n          );\n\n        stitchableStream.addStream(transformedStream);\n      },\n    })\n      .catch(error => {\n        // add an empty stream with an error to break the stream:\n        stitchableStream.addStream(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue({ type: 'error', error });\n              controller.close();\n            },\n          }),\n        );\n      })\n      .finally(() => {\n        stitchableStream.close();\n      });\n\n    this.outputStrategy = outputStrategy;\n  }\n\n  get object() {\n    return this.objectPromise.value;\n  }\n\n  get usage() {\n    return this.usagePromise.value;\n  }\n\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n\n  get request() {\n    return this.requestPromise.value;\n  }\n\n  get response() {\n    return this.responsePromise.value;\n  }\n\n  get partialObjectStream(): AsyncIterableStream<PARTIAL> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, PARTIAL>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'object':\n                controller.enqueue(chunk.object);\n                break;\n\n              case 'text-delta':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get elementStream(): ELEMENT_STREAM {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, string>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'text-delta':\n                controller.enqueue(chunk.textDelta);\n                break;\n\n              case 'object':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<ObjectStreamPart<PARTIAL>> {\n    return createAsyncIterableStream(this.baseStream);\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n\nexport type ObjectStreamInputPart =\n  | {\n      type: 'error';\n      error: unknown;\n    }\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      providerMetadata?: ProviderMetadata;\n    };\n", "/**\n * Delayed promise. It is only constructed once the value is accessed.\n * This is useful to avoid unhandled promise rejections when the promise is created\n * but not accessed.\n */\nexport class DelayedPromise<T> {\n  private status:\n    | { type: 'pending' }\n    | { type: 'resolved'; value: T }\n    | { type: 'rejected'; error: unknown } = { type: 'pending' };\n  private promise: Promise<T> | undefined;\n  private _resolve: undefined | ((value: T) => void) = undefined;\n  private _reject: undefined | ((error: unknown) => void) = undefined;\n\n  get value(): Promise<T> {\n    if (this.promise) {\n      return this.promise;\n    }\n\n    this.promise = new Promise<T>((resolve, reject) => {\n      if (this.status.type === 'resolved') {\n        resolve(this.status.value);\n      } else if (this.status.type === 'rejected') {\n        reject(this.status.error);\n      }\n\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n\n    return this.promise;\n  }\n\n  resolve(value: T): void {\n    this.status = { type: 'resolved', value };\n\n    if (this.promise) {\n      this._resolve?.(value);\n    }\n  }\n\n  reject(error: unknown): void {\n    this.status = { type: 'rejected', error };\n\n    if (this.promise) {\n      this._reject?.(error);\n    }\n  }\n}\n", "/**\n * Creates a Promise with externally accessible resolve and reject functions.\n *\n * @template T - The type of the value that the Promise will resolve to.\n * @returns An object containing:\n *   - promise: A Promise that can be resolved or rejected externally.\n *   - resolve: A function to resolve the Promise with a value of type T.\n *   - reject: A function to reject the Promise with an error.\n */\nexport function createResolvablePromise<T = any>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (error: unknown) => void;\n} {\n  let resolve: (value: T) => void;\n  let reject: (error: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  };\n}\n", "import { createResolvablePromise } from '../../util/create-resolvable-promise';\n\n/**\n * Creates a stitchable stream that can pipe one stream at a time.\n *\n * @template T - The type of values emitted by the streams.\n * @returns {Object} An object containing the stitchable stream and control methods.\n */\nexport function createStitchableStream<T>(): {\n  stream: ReadableStream<T>;\n  addStream: (innerStream: ReadableStream<T>) => void;\n  close: () => void;\n  terminate: () => void;\n} {\n  let innerStreamReaders: ReadableStreamDefaultReader<T>[] = [];\n  let controller: ReadableStreamDefaultController<T> | null = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise<void>();\n\n  const processPull = async () => {\n    // Case 1: Outer stream is closed and no more inner streams\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller?.close();\n      return;\n    }\n\n    // Case 2: No inner streams available, but outer stream is open\n    // wait for a new inner stream to be added or the outer stream to close\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise<void>();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n\n      if (done) {\n        // Case 3: Current inner stream is done\n        innerStreamReaders.shift(); // Remove the finished stream\n\n        // Continue pulling from the next stream if available\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller?.close();\n        }\n      } else {\n        // Case 4: Current inner stream returns an item\n        controller?.enqueue(value);\n      }\n    } catch (error) {\n      // Case 5: Current inner stream throws an error\n      controller?.error(error);\n      innerStreamReaders.shift(); // Remove the errored stream\n\n      if (isClosed && innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    }\n  };\n\n  return {\n    stream: new ReadableStream<T>({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      },\n    }),\n    addStream: (innerStream: ReadableStream<T>) => {\n      if (isClosed) {\n        throw new Error('Cannot add inner stream: outer stream is closed');\n      }\n\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n\n      if (innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    },\n\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n\n      innerStreamReaders.forEach(reader => reader.cancel());\n      innerStreamReaders = [];\n      controller?.close();\n    },\n  };\n}\n", "// Shim for performance.now() to support environments that don't have it:\nexport function now(): number {\n  return globalThis?.performance?.now() ?? Date.now();\n}\n", "import { createIdGenerator, IDGenerator } from '@ai-sdk/provider-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { NoOutputSpecifiedError } from '../../errors/no-output-specified-error';\nimport { ToolExecutionError } from '../../errors/tool-execution-error';\nimport { CoreAssistantMessage, CoreMessage } from '../prompt';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { LanguageModel, ToolChoice } from '../types';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport {\n  addLanguageModelUsage,\n  calculateLanguageModelUsage,\n  LanguageModelUsage,\n} from '../types/usage';\nimport { removeTextAfterLastWhitespace } from '../util/remove-text-after-last-whitespace';\nimport { GenerateTextResult } from './generate-text-result';\nimport { DefaultGeneratedFile, GeneratedFile } from './generated-file';\nimport { Output } from './output';\nimport { parseToolCall } from './parse-tool-call';\nimport { asReasoningText, ReasoningDetail } from './reasoning-detail';\nimport { ResponseMessage, StepResult } from './step-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallArray } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultArray } from './tool-result';\nimport { ToolSet } from './tool-set';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\nconst originalGenerateMessageId = createIdGenerator({\n  prefix: 'msg',\n  size: 24,\n});\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type GenerateTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamText` instead.\n\n@param model - The language model to use.\n\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n@param toolChoice - The tool choice strategy. Default: 'auto'.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n\n@returns\nA result object that contains the generated text, the results of the tool calls, and additional information.\n */\nexport async function generateText<\n  TOOLS extends ToolSet,\n  OUTPUT = never,\n  OUTPUT_PARTIAL = never,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_activeTools: activeTools,\n  experimental_prepareStep: prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  onStepFinish,\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n*/\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n     */\n    maxSteps?: number;\n\n    /**\nGenerate a unique ID for each message.\n     */\n    experimental_generateMessageId?: IDGenerator;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n@deprecated Use `providerOptions` instead.\n     */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    experimental_output?: Output<OUTPUT, OUTPUT_PARTIAL>;\n\n    /**\nOptional function that you can use to provide different settings for a step.\n\n@param options - The options for the step.\n@param options.steps - The steps that have been executed so far.\n@param options.stepNumber - The number of the step that is being executed.\n@param options.maxSteps - The maximum number of steps.\n@param options.model - The model that is being used.\n\n@returns An object that contains the settings for the step.\nIf you return undefined (or for undefined settings), the settings from the outer level will be used.\n    */\n    experimental_prepareStep?: (options: {\n      steps: Array<StepResult<TOOLS>>;\n      stepNumber: number;\n      maxSteps: number;\n      model: LanguageModel;\n    }) => PromiseLike<\n      | {\n          model?: LanguageModel;\n          toolChoice?: ToolChoice<TOOLS>;\n          experimental_activeTools?: Array<keyof TOOLS>;\n        }\n      | undefined\n    >;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\n    Callback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: GenerateTextOnStepFinishCallback<TOOLS>;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: IDGenerator;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateTextResult<TOOLS, OUTPUT>> {\n  if (maxSteps < 1) {\n    throw new InvalidArgumentError({\n      parameter: 'maxSteps',\n      value: maxSteps,\n      message: 'maxSteps must be at least 1',\n    });\n  }\n\n  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { ...settings, maxRetries },\n  });\n\n  const initialPrompt = standardizePrompt({\n    prompt: {\n      system: output?.injectIntoSystemPrompt({ system, model }) ?? system,\n      prompt,\n      messages,\n    },\n    tools,\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.generateText',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.generateText',\n          telemetry,\n        }),\n        ...baseTelemetryAttributes,\n        // model:\n        'ai.model.provider': model.provider,\n        'ai.model.id': model.modelId,\n        // specific settings that only make sense on the outer level:\n        'ai.prompt': {\n          input: () => JSON.stringify({ system, prompt, messages }),\n        },\n        'ai.settings.maxSteps': maxSteps,\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const callSettings = prepareCallSettings(settings);\n\n      let currentModelResponse: Awaited<\n        ReturnType<LanguageModel['doGenerate']>\n      > & { response: { id: string; timestamp: Date; modelId: string } };\n      let currentToolCalls: ToolCallArray<TOOLS> = [];\n      let currentToolResults: ToolResultArray<TOOLS> = [];\n      let currentReasoningDetails: Array<ReasoningDetail> = [];\n      let stepCount = 0;\n      const responseMessages: Array<ResponseMessage> = [];\n      let text = '';\n      const sources: GenerateTextResult<TOOLS, OUTPUT>['sources'] = [];\n      const steps: GenerateTextResult<TOOLS, OUTPUT>['steps'] = [];\n      let usage: LanguageModelUsage = {\n        completionTokens: 0,\n        promptTokens: 0,\n        totalTokens: 0,\n      };\n\n      let stepType: 'initial' | 'tool-result' | 'continue' | 'done' = 'initial';\n\n      do {\n        // after the 1st step, we need to switch to messages format:\n        const promptFormat = stepCount === 0 ? initialPrompt.type : 'messages';\n\n        const stepInputMessages = [\n          ...initialPrompt.messages,\n          ...responseMessages,\n        ];\n\n        const prepareStepResult = await prepareStep?.({\n          model,\n          steps,\n          maxSteps,\n          stepNumber: stepCount,\n        });\n\n        const stepToolChoice = prepareStepResult?.toolChoice ?? toolChoice;\n        const stepActiveTools =\n          prepareStepResult?.experimental_activeTools ?? activeTools;\n        const stepModel = prepareStepResult?.model ?? model;\n\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: {\n            type: promptFormat,\n            system: initialPrompt.system,\n            messages: stepInputMessages,\n          },\n          modelSupportsImageUrls: stepModel.supportsImageUrls,\n          modelSupportsUrl: stepModel.supportsUrl?.bind(stepModel), // support 'this' context\n        });\n\n        const mode = {\n          type: 'regular' as const,\n          ...prepareToolsAndToolChoice({\n            tools,\n            toolChoice: stepToolChoice,\n            activeTools: stepActiveTools,\n          }),\n        };\n\n        currentModelResponse = await retry(() =>\n          recordSpan({\n            name: 'ai.generateText.doGenerate',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.generateText.doGenerate',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // model:\n                'ai.model.provider': stepModel.provider,\n                'ai.model.id': stepModel.modelId,\n                // prompt:\n                'ai.prompt.format': { input: () => promptFormat },\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(promptMessages),\n                },\n                'ai.prompt.tools': {\n                  // convert the language model level tools:\n                  input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                },\n                'ai.prompt.toolChoice': {\n                  input: () =>\n                    mode.toolChoice != null\n                      ? JSON.stringify(mode.toolChoice)\n                      : undefined,\n                },\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': stepModel.provider,\n                'gen_ai.request.model': stepModel.modelId,\n                'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                'gen_ai.request.max_tokens': settings.maxTokens,\n                'gen_ai.request.presence_penalty': settings.presencePenalty,\n                'gen_ai.request.stop_sequences': settings.stopSequences,\n                'gen_ai.request.temperature': settings.temperature,\n                'gen_ai.request.top_k': settings.topK,\n                'gen_ai.request.top_p': settings.topP,\n              },\n            }),\n            tracer,\n            fn: async span => {\n              const result = await stepModel.doGenerate({\n                mode,\n                ...callSettings,\n                inputFormat: promptFormat,\n                responseFormat: output?.responseFormat({ model }),\n                prompt: promptMessages,\n                providerMetadata: providerOptions,\n                abortSignal,\n                headers,\n              });\n\n              // Fill in default values:\n              const responseData = {\n                id: result.response?.id ?? generateId(),\n                timestamp: result.response?.timestamp ?? currentDate(),\n                modelId: result.response?.modelId ?? stepModel.modelId,\n              };\n\n              // Add response information to the span:\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.response.finishReason': result.finishReason,\n                    'ai.response.text': {\n                      output: () => result.text,\n                    },\n                    'ai.response.toolCalls': {\n                      output: () => JSON.stringify(result.toolCalls),\n                    },\n                    'ai.response.id': responseData.id,\n                    'ai.response.model': responseData.modelId,\n                    'ai.response.timestamp':\n                      responseData.timestamp.toISOString(),\n\n                    'ai.usage.promptTokens': result.usage.promptTokens,\n                    'ai.usage.completionTokens': result.usage.completionTokens,\n\n                    // standardized gen-ai llm span attributes:\n                    'gen_ai.response.finish_reasons': [result.finishReason],\n                    'gen_ai.response.id': responseData.id,\n                    'gen_ai.response.model': responseData.modelId,\n                    'gen_ai.usage.input_tokens': result.usage.promptTokens,\n                    'gen_ai.usage.output_tokens': result.usage.completionTokens,\n                  },\n                }),\n              );\n\n              return { ...result, response: responseData };\n            },\n          }),\n        );\n\n        // parse tool calls:\n        currentToolCalls = await Promise.all(\n          (currentModelResponse.toolCalls ?? []).map(toolCall =>\n            parseToolCall({\n              toolCall,\n              tools,\n              repairToolCall,\n              system,\n              messages: stepInputMessages,\n            }),\n          ),\n        );\n\n        // execute tools:\n        currentToolResults =\n          tools == null\n            ? []\n            : await executeTools({\n                toolCalls: currentToolCalls,\n                tools,\n                tracer,\n                telemetry,\n                messages: stepInputMessages,\n                abortSignal,\n              });\n\n        // token usage:\n        const currentUsage = calculateLanguageModelUsage(\n          currentModelResponse.usage,\n        );\n        usage = addLanguageModelUsage(usage, currentUsage);\n\n        // check if another step is needed:\n        let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n        if (++stepCount < maxSteps) {\n          if (\n            continueSteps &&\n            currentModelResponse.finishReason === 'length' &&\n            // only use continue when there are no tool calls:\n            currentToolCalls.length === 0\n          ) {\n            nextStepType = 'continue';\n          } else if (\n            // there are tool calls:\n            currentToolCalls.length > 0 &&\n            // all current tool calls have results:\n            currentToolResults.length === currentToolCalls.length\n          ) {\n            nextStepType = 'tool-result';\n          }\n        }\n\n        // text:\n        const originalText = currentModelResponse.text ?? '';\n        const stepTextLeadingWhitespaceTrimmed =\n          stepType === 'continue' && // only for continue steps\n          text.trimEnd() !== text // only trim when there is preceding whitespace\n            ? originalText.trimStart()\n            : originalText;\n        const stepText =\n          nextStepType === 'continue'\n            ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed)\n            : stepTextLeadingWhitespaceTrimmed;\n\n        text =\n          nextStepType === 'continue' || stepType === 'continue'\n            ? text + stepText\n            : stepText;\n\n        currentReasoningDetails = asReasoningDetails(\n          currentModelResponse.reasoning,\n        );\n\n        // sources:\n        sources.push(...(currentModelResponse.sources ?? []));\n\n        // append to messages for potential next step:\n        if (stepType === 'continue') {\n          // continue step: update the last assistant message\n          // continue is only possible when there are no tool calls,\n          // so we can assume that there is a single last assistant message:\n          const lastMessage = responseMessages[\n            responseMessages.length - 1\n          ] as CoreAssistantMessage;\n\n          if (typeof lastMessage.content === 'string') {\n            lastMessage.content += stepText;\n          } else {\n            lastMessage.content.push({\n              text: stepText,\n              type: 'text',\n            });\n          }\n        } else {\n          responseMessages.push(\n            ...toResponseMessages({\n              text,\n              files: asFiles(currentModelResponse.files),\n              reasoning: asReasoningDetails(currentModelResponse.reasoning),\n              tools: tools ?? ({} as TOOLS),\n              toolCalls: currentToolCalls,\n              toolResults: currentToolResults,\n              messageId: generateMessageId(),\n              generateMessageId,\n            }),\n          );\n        }\n\n        // Add step information (after response messages are updated):\n        const currentStepResult: StepResult<TOOLS> = {\n          stepType,\n          text: stepText,\n          // TODO v5: rename reasoning to reasoningText (and use reasoning for composite array)\n          reasoning: asReasoningText(currentReasoningDetails),\n          reasoningDetails: currentReasoningDetails,\n          files: asFiles(currentModelResponse.files),\n          sources: currentModelResponse.sources ?? [],\n          toolCalls: currentToolCalls,\n          toolResults: currentToolResults,\n          finishReason: currentModelResponse.finishReason,\n          usage: currentUsage,\n          warnings: currentModelResponse.warnings,\n          logprobs: currentModelResponse.logprobs,\n          request: currentModelResponse.request ?? {},\n          response: {\n            ...currentModelResponse.response,\n            headers: currentModelResponse.rawResponse?.headers,\n            body: currentModelResponse.rawResponse?.body,\n\n            // deep clone msgs to avoid mutating past messages in multi-step:\n            messages: structuredClone(responseMessages),\n          },\n          providerMetadata: currentModelResponse.providerMetadata,\n          experimental_providerMetadata: currentModelResponse.providerMetadata,\n          isContinued: nextStepType === 'continue',\n        };\n        steps.push(currentStepResult);\n        await onStepFinish?.(currentStepResult);\n\n        stepType = nextStepType;\n      } while (stepType !== 'done');\n\n      // Add response information to the span:\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.response.finishReason': currentModelResponse.finishReason,\n            'ai.response.text': {\n              output: () => currentModelResponse.text,\n            },\n            'ai.response.toolCalls': {\n              output: () => JSON.stringify(currentModelResponse.toolCalls),\n            },\n\n            'ai.usage.promptTokens': currentModelResponse.usage.promptTokens,\n            'ai.usage.completionTokens':\n              currentModelResponse.usage.completionTokens,\n          },\n        }),\n      );\n\n      return new DefaultGenerateTextResult({\n        text,\n        files: asFiles(currentModelResponse.files),\n        reasoning: asReasoningText(currentReasoningDetails),\n        reasoningDetails: currentReasoningDetails,\n        sources,\n        outputResolver: () => {\n          if (output == null) {\n            throw new NoOutputSpecifiedError();\n          }\n\n          return output.parseOutput(\n            { text },\n            {\n              response: currentModelResponse.response,\n              usage,\n              finishReason: currentModelResponse.finishReason,\n            },\n          );\n        },\n        toolCalls: currentToolCalls,\n        toolResults: currentToolResults,\n        finishReason: currentModelResponse.finishReason,\n        usage,\n        warnings: currentModelResponse.warnings,\n        request: currentModelResponse.request ?? {},\n        response: {\n          ...currentModelResponse.response,\n          headers: currentModelResponse.rawResponse?.headers,\n          body: currentModelResponse.rawResponse?.body,\n          messages: responseMessages,\n        },\n        logprobs: currentModelResponse.logprobs,\n        steps,\n        providerMetadata: currentModelResponse.providerMetadata,\n      });\n    },\n  });\n}\n\nasync function executeTools<TOOLS extends ToolSet>({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n}: {\n  toolCalls: ToolCallArray<TOOLS>;\n  tools: TOOLS;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  messages: CoreMessage[];\n  abortSignal: AbortSignal | undefined;\n}): Promise<ToolResultArray<TOOLS>> {\n  const toolResults = await Promise.all(\n    toolCalls.map(async ({ toolCallId, toolName, args }) => {\n      const tool = tools[toolName];\n\n      if (tool?.execute == null) {\n        return undefined;\n      }\n\n      const result = await recordSpan({\n        name: 'ai.toolCall',\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: 'ai.toolCall',\n              telemetry,\n            }),\n            'ai.toolCall.name': toolName,\n            'ai.toolCall.id': toolCallId,\n            'ai.toolCall.args': {\n              output: () => JSON.stringify(args),\n            },\n          },\n        }),\n        tracer,\n        fn: async span => {\n          try {\n            const result = await tool.execute!(args, {\n              toolCallId,\n              messages,\n              abortSignal,\n            });\n\n            try {\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.toolCall.result': {\n                      output: () => JSON.stringify(result),\n                    },\n                  },\n                }),\n              );\n            } catch (ignored) {\n              // JSON stringify might fail if the result is not serializable,\n              // in which case we just ignore it. In the future we might want to\n              // add an optional serialize method to the tool interface and warn\n              // if the result is not serializable.\n            }\n\n            return result;\n          } catch (error) {\n            throw new ToolExecutionError({\n              toolCallId,\n              toolName,\n              toolArgs: args,\n              cause: error,\n            });\n          }\n        },\n      });\n\n      return {\n        type: 'tool-result',\n        toolCallId,\n        toolName,\n        args,\n        result,\n      } as ToolResultArray<TOOLS>[number];\n    }),\n  );\n\n  return toolResults.filter(\n    (result): result is NonNullable<typeof result> => result != null,\n  );\n}\n\nclass DefaultGenerateTextResult<TOOLS extends ToolSet, OUTPUT>\n  implements GenerateTextResult<TOOLS, OUTPUT>\n{\n  readonly text: GenerateTextResult<TOOLS, OUTPUT>['text'];\n  readonly files: GenerateTextResult<TOOLS, OUTPUT>['files'];\n  readonly reasoning: GenerateTextResult<TOOLS, OUTPUT>['reasoning'];\n  readonly reasoningDetails: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['reasoningDetails'];\n  readonly toolCalls: GenerateTextResult<TOOLS, OUTPUT>['toolCalls'];\n  readonly toolResults: GenerateTextResult<TOOLS, OUTPUT>['toolResults'];\n  readonly finishReason: GenerateTextResult<TOOLS, OUTPUT>['finishReason'];\n  readonly usage: GenerateTextResult<TOOLS, OUTPUT>['usage'];\n  readonly warnings: GenerateTextResult<TOOLS, OUTPUT>['warnings'];\n  readonly steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n  readonly logprobs: GenerateTextResult<TOOLS, OUTPUT>['logprobs'];\n  readonly experimental_providerMetadata: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['experimental_providerMetadata'];\n  readonly providerMetadata: GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['providerMetadata'];\n  readonly response: GenerateTextResult<TOOLS, OUTPUT>['response'];\n  readonly request: GenerateTextResult<TOOLS, OUTPUT>['request'];\n  readonly sources: GenerateTextResult<TOOLS, OUTPUT>['sources'];\n\n  private readonly outputResolver: () => GenerateTextResult<\n    TOOLS,\n    OUTPUT\n  >['experimental_output'];\n\n  constructor(options: {\n    text: GenerateTextResult<TOOLS, OUTPUT>['text'];\n    files: GenerateTextResult<TOOLS, OUTPUT>['files'];\n    reasoning: GenerateTextResult<TOOLS, OUTPUT>['reasoning'];\n    reasoningDetails: GenerateTextResult<TOOLS, OUTPUT>['reasoningDetails'];\n    toolCalls: GenerateTextResult<TOOLS, OUTPUT>['toolCalls'];\n    toolResults: GenerateTextResult<TOOLS, OUTPUT>['toolResults'];\n    finishReason: GenerateTextResult<TOOLS, OUTPUT>['finishReason'];\n    usage: GenerateTextResult<TOOLS, OUTPUT>['usage'];\n    warnings: GenerateTextResult<TOOLS, OUTPUT>['warnings'];\n    logprobs: GenerateTextResult<TOOLS, OUTPUT>['logprobs'];\n    steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n    providerMetadata: GenerateTextResult<TOOLS, OUTPUT>['providerMetadata'];\n    response: GenerateTextResult<TOOLS, OUTPUT>['response'];\n    request: GenerateTextResult<TOOLS, OUTPUT>['request'];\n    outputResolver: () => GenerateTextResult<\n      TOOLS,\n      OUTPUT\n    >['experimental_output'];\n    sources: GenerateTextResult<TOOLS, OUTPUT>['sources'];\n  }) {\n    this.text = options.text;\n    this.files = options.files;\n    this.reasoning = options.reasoning;\n    this.reasoningDetails = options.reasoningDetails;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.request = options.request;\n    this.response = options.response;\n    this.steps = options.steps;\n    this.experimental_providerMetadata = options.providerMetadata;\n    this.providerMetadata = options.providerMetadata;\n    this.logprobs = options.logprobs;\n    this.outputResolver = options.outputResolver;\n    this.sources = options.sources;\n  }\n\n  get experimental_output() {\n    return this.outputResolver();\n  }\n}\n\nfunction asReasoningDetails(\n  reasoning:\n    | string\n    | Array<\n        | { type: 'text'; text: string; signature?: string }\n        | { type: 'redacted'; data: string }\n      >\n    | undefined,\n): Array<\n  | { type: 'text'; text: string; signature?: string }\n  | { type: 'redacted'; data: string }\n> {\n  if (reasoning == null) {\n    return [];\n  }\n\n  if (typeof reasoning === 'string') {\n    return [{ type: 'text', text: reasoning }];\n  }\n\n  return reasoning;\n}\n\nfunction asFiles(\n  files:\n    | Array<{\n        data: string | Uint8Array;\n        mimeType: string;\n      }>\n    | undefined,\n): Array<GeneratedFile> {\n  return files?.map(file => new DefaultGeneratedFile(file)) ?? [];\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoOutputSpecifiedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no output type is specified and output-related methods are called.\n */\nexport class NoOutputSpecifiedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({ message = 'No output specified.' }: { message?: string } = {}) {\n    super({ name, message });\n  }\n\n  static isInstance(error: unknown): error is NoOutputSpecifiedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError, getErrorMessage, JSONValue } from '@ai-sdk/provider';\n\nconst name = 'AI_ToolExecutionError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class ToolExecutionError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolArgs: JSONValue;\n  readonly toolCallId: string;\n\n  constructor({\n    toolArgs,\n    toolName,\n    toolCallId,\n    cause,\n    message = `Error executing tool ${toolName}: ${getErrorMessage(cause)}`,\n  }: {\n    message?: string;\n    toolArgs: JSONValue;\n    toolName: string;\n    toolCallId: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n    this.toolCallId = toolCallId;\n  }\n\n  static isInstance(error: unknown): error is ToolExecutionError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import {\n  LanguageModelV1FunctionTool,\n  LanguageModelV1ProviderDefinedTool,\n  LanguageModelV1ToolChoice,\n} from '@ai-sdk/provider';\nimport { asSchema } from '@ai-sdk/ui-utils';\nimport { ToolSet } from '../generate-text';\nimport { ToolChoice } from '../types/language-model';\nimport { isNonEmptyObject } from '../util/is-non-empty-object';\n\nexport function prepareToolsAndToolChoice<TOOLS extends ToolSet>({\n  tools,\n  toolChoice,\n  activeTools,\n}: {\n  tools: TOOLS | undefined;\n  toolChoice: ToolChoice<TOOLS> | undefined;\n  activeTools: Array<keyof TOOLS> | undefined;\n}): {\n  tools:\n    | Array<LanguageModelV1FunctionTool | LanguageModelV1ProviderDefinedTool>\n    | undefined;\n  toolChoice: LanguageModelV1ToolChoice | undefined;\n} {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: undefined,\n      toolChoice: undefined,\n    };\n  }\n\n  // when activeTools is provided, we only include the tools that are in the list:\n  const filteredTools =\n    activeTools != null\n      ? Object.entries(tools).filter(([name]) =>\n          activeTools.includes(name as keyof TOOLS),\n        )\n      : Object.entries(tools);\n\n  return {\n    tools: filteredTools.map(([name, tool]) => {\n      const toolType = tool.type;\n      switch (toolType) {\n        case undefined:\n        case 'function':\n          return {\n            type: 'function' as const,\n            name,\n            description: tool.description,\n            parameters: asSchema(tool.parameters).jsonSchema,\n          };\n        case 'provider-defined':\n          return {\n            type: 'provider-defined' as const,\n            name,\n            id: tool.id,\n            args: tool.args,\n          };\n        default: {\n          const exhaustiveCheck: never = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice:\n      toolChoice == null\n        ? { type: 'auto' }\n        : typeof toolChoice === 'string'\n          ? { type: toolChoice }\n          : { type: 'tool' as const, toolName: toolChoice.toolName as string },\n  };\n}\n", "export function isNonEmptyObject(\n  object: Record<string, unknown> | undefined | null,\n): object is Record<string, unknown> {\n  return object != null && Object.keys(object).length > 0;\n}\n", "const lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\n\n/**\n * Splits the text on the last whitespace.\n *\n * Whitespace is defined as one or more whitespace characters,\n * e.g. space, tab, newline, etc.\n *\n * @param text - The text to split.\n * @returns The prefix, whitespace, and suffix. Undefined if there is no whitespace.\n */\nexport function splitOnLastWhitespace(text: string):\n  | {\n      prefix: string;\n      whitespace: string;\n      suffix: string;\n    }\n  | undefined {\n  const match = text.match(lastWhitespaceRegexp);\n  return match\n    ? { prefix: match[1], whitespace: match[2], suffix: match[3] }\n    : undefined;\n}\n", "import { splitOnLastWhitespace } from './split-on-last-whitespace';\n\nexport function removeTextAfterLastWhitespace(text: string): string {\n  const match = splitOnLastWhitespace(text);\n  return match ? match.prefix + match.whitespace : text;\n}\n", "import { LanguageModelV1FunctionToolCall } from '@ai-sdk/provider';\nimport { safeParseJSON, safeValidateTypes } from '@ai-sdk/provider-utils';\nimport { Schema, asSchema } from '@ai-sdk/ui-utils';\nimport { InvalidToolArgumentsError } from '../../errors/invalid-tool-arguments-error';\nimport { NoSuchToolError } from '../../errors/no-such-tool-error';\nimport { ToolCallRepairError } from '../../errors/tool-call-repair-error';\nimport { CoreMessage } from '../prompt';\nimport { inferParameters } from '../tool/tool';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolSet } from './tool-set';\n\nexport async function parseToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages,\n}: {\n  toolCall: LanguageModelV1FunctionToolCall;\n  tools: TOOLS | undefined;\n  repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n  system: string | undefined;\n  messages: CoreMessage[];\n}): Promise<ToolCallUnion<TOOLS>> {\n  if (tools == null) {\n    throw new NoSuchToolError({ toolName: toolCall.toolName });\n  }\n\n  try {\n    return await doParseToolCall({ toolCall, tools });\n  } catch (error) {\n    if (\n      repairToolCall == null ||\n      !(\n        NoSuchToolError.isInstance(error) ||\n        InvalidToolArgumentsError.isInstance(error)\n      )\n    ) {\n      throw error;\n    }\n\n    let repairedToolCall: LanguageModelV1FunctionToolCall | null = null;\n\n    try {\n      repairedToolCall = await repairToolCall({\n        toolCall,\n        tools,\n        parameterSchema: ({ toolName }) =>\n          asSchema(tools[toolName].parameters).jsonSchema,\n        system,\n        messages,\n        error,\n      });\n    } catch (repairError) {\n      throw new ToolCallRepairError({\n        cause: repairError,\n        originalError: error,\n      });\n    }\n\n    // no repaired tool call returned\n    if (repairedToolCall == null) {\n      throw error;\n    }\n\n    return await doParseToolCall({ toolCall: repairedToolCall, tools });\n  }\n}\n\nasync function doParseToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n}: {\n  toolCall: LanguageModelV1FunctionToolCall;\n  tools: TOOLS;\n}): Promise<ToolCallUnion<TOOLS>> {\n  const toolName = toolCall.toolName as keyof TOOLS & string;\n\n  const tool = tools[toolName];\n\n  if (tool == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools),\n    });\n  }\n\n  const schema = asSchema(tool.parameters) as Schema<\n    inferParameters<TOOLS[keyof TOOLS]['parameters']>\n  >;\n\n  // when the tool call has no arguments, we try passing an empty object to the schema\n  // (many LLMs generate empty strings for tool calls with no arguments)\n  const parseResult =\n    toolCall.args.trim() === ''\n      ? safeValidateTypes({ value: {}, schema })\n      : safeParseJSON({ text: toolCall.args, schema });\n\n  if (parseResult.success === false) {\n    throw new InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error,\n    });\n  }\n\n  return {\n    type: 'tool-call',\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value,\n  };\n}\n", "import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidToolArgumentsError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidToolArgumentsError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolArgs: string;\n\n  constructor({\n    toolArgs,\n    toolName,\n    cause,\n    message = `Invalid arguments for tool ${toolName}: ${getErrorMessage(\n      cause,\n    )}`,\n  }: {\n    message?: string;\n    toolArgs: string;\n    toolName: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolArgs = toolArgs;\n    this.toolName = toolName;\n  }\n\n  static isInstance(error: unknown): error is InvalidToolArgumentsError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchToolError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchToolError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly availableTools: string[] | undefined;\n\n  constructor({\n    toolName,\n    availableTools = undefined,\n    message = `Model tried to call unavailable tool '${toolName}'. ${\n      availableTools === undefined\n        ? 'No tools are available.'\n        : `Available tools: ${availableTools.join(', ')}.`\n    }`,\n  }: {\n    toolName: string;\n    availableTools?: string[] | undefined;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n\n  static isInstance(error: unknown): error is NoSuchToolError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\nimport { InvalidToolArgumentsError } from './invalid-tool-arguments-error';\nimport { NoSuchToolError } from './no-such-tool-error';\n\nconst name = 'AI_ToolCallRepairError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class ToolCallRepairError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalError: NoSuchToolError | InvalidToolArgumentsError;\n\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${getErrorMessage(cause)}`,\n  }: {\n    message?: string;\n    cause: unknown;\n    originalError: NoSuchToolError | InvalidToolArgumentsError;\n  }) {\n    super({ name, message, cause });\n    this.originalError = originalError;\n  }\n\n  static isInstance(error: unknown): error is ToolCallRepairError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "export type ReasoningDetail =\n  | { type: 'text'; text: string; signature?: string }\n  | { type: 'redacted'; data: string };\n\nexport function asReasoningText(\n  reasoning: Array<ReasoningDetail>,\n): string | undefined {\n  const reasoningText = reasoning\n    .filter(part => part.type === 'text')\n    .map(part => part.text)\n    .join('');\n\n  return reasoningText.length > 0 ? reasoningText : undefined;\n}\n", "import { ToolResultPart } from '../prompt';\nimport { GeneratedFile } from './generated-file';\nimport { ReasoningDetail } from './reasoning-detail';\nimport { ResponseMessage } from './step-result';\nimport { ToolCallArray } from './tool-call';\nimport { ToolResultArray } from './tool-result';\nimport { ToolSet } from './tool-set';\n\n/**\nConverts the result of a `generateText` or `streamText` call to a list of response messages.\n */\nexport function toResponseMessages<TOOLS extends ToolSet>({\n  text = '',\n  files,\n  reasoning,\n  tools,\n  toolCalls,\n  toolResults,\n  messageId,\n  generateMessageId,\n}: {\n  text: string | undefined;\n  files: Array<GeneratedFile>;\n  reasoning: Array<ReasoningDetail>;\n  tools: TOOLS;\n  toolCalls: ToolCallArray<TOOLS>;\n  toolResults: ToolResultArray<TOOLS>;\n  messageId: string;\n  generateMessageId: () => string;\n}): Array<ResponseMessage> {\n  const responseMessages: Array<ResponseMessage> = [];\n\n  const content = [];\n\n  // TODO language model v2: switch to order response content (instead of type-based ordering)\n\n  if (reasoning.length > 0) {\n    content.push(\n      ...reasoning.map(part =>\n        part.type === 'text'\n          ? { ...part, type: 'reasoning' as const }\n          : { ...part, type: 'redacted-reasoning' as const },\n      ),\n    );\n  }\n\n  if (files.length > 0) {\n    content.push(\n      ...files.map(file => ({\n        type: 'file' as const,\n        data: file.base64,\n        mimeType: file.mimeType,\n      })),\n    );\n  }\n\n  if (text.length > 0) {\n    content.push({ type: 'text' as const, text });\n  }\n\n  if (toolCalls.length > 0) {\n    content.push(...toolCalls);\n  }\n\n  if (content.length > 0) {\n    responseMessages.push({\n      role: 'assistant',\n      content,\n      id: messageId,\n    });\n  }\n\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: 'tool',\n      id: generateMessageId(),\n      content: toolResults.map((toolResult): ToolResultPart => {\n        const tool = tools[toolResult.toolName];\n        return tool?.experimental_toToolResultContent != null\n          ? {\n              type: 'tool-result',\n              toolCallId: toolResult.toolCallId,\n              toolName: toolResult.toolName,\n              result: tool.experimental_toToolResultContent(toolResult.result),\n              experimental_content: tool.experimental_toToolResultContent(\n                toolResult.result,\n              ),\n            }\n          : {\n              type: 'tool-result',\n              toolCallId: toolResult.toolCallId,\n              toolName: toolResult.toolName,\n              result: toolResult.result,\n            };\n      }),\n    });\n  }\n\n  return responseMessages;\n}\n", "import { safeParseJSON, safeValidateTypes } from '@ai-sdk/provider-utils';\nimport {\n  asSchema,\n  DeepPartial,\n  parsePartialJson,\n  Schema,\n} from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { NoObjectGeneratedError } from '../../errors';\nimport { injectJsonInstruction } from '../generate-object/inject-json-instruction';\nimport {\n  FinishReason,\n  LanguageModel,\n  LanguageModelV1CallOptions,\n} from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../types/usage';\n\nexport interface Output<OUTPUT, PARTIAL> {\n  readonly type: 'object' | 'text';\n  injectIntoSystemPrompt(options: {\n    system: string | undefined;\n    model: LanguageModel;\n  }): string | undefined;\n\n  responseFormat: (options: {\n    model: LanguageModel;\n  }) => LanguageModelV1CallOptions['responseFormat'];\n\n  parsePartial(options: { text: string }): { partial: PARTIAL } | undefined;\n\n  parseOutput(\n    options: { text: string },\n    context: {\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): OUTPUT;\n}\n\nexport const text = (): Output<string, string> => ({\n  type: 'text',\n\n  responseFormat: () => ({ type: 'text' }),\n\n  injectIntoSystemPrompt({ system }: { system: string | undefined }) {\n    return system;\n  },\n\n  parsePartial({ text }: { text: string }) {\n    return { partial: text };\n  },\n\n  parseOutput({ text }: { text: string }) {\n    return text;\n  },\n});\n\nexport const object = <OUTPUT>({\n  schema: inputSchema,\n}: {\n  schema: z.Schema<OUTPUT, z.ZodTypeDef, any> | Schema<OUTPUT>;\n}): Output<OUTPUT, DeepPartial<OUTPUT>> => {\n  const schema = asSchema(inputSchema);\n\n  return {\n    type: 'object',\n\n    responseFormat: ({ model }) => ({\n      type: 'json',\n      schema: model.supportsStructuredOutputs ? schema.jsonSchema : undefined,\n    }),\n\n    injectIntoSystemPrompt({ system, model }) {\n      // when the model supports structured outputs,\n      // we can use the system prompt as is:\n      return model.supportsStructuredOutputs\n        ? system\n        : injectJsonInstruction({\n            prompt: system,\n            schema: schema.jsonSchema,\n          });\n    },\n\n    parsePartial({ text }: { text: string }) {\n      const result = parsePartialJson(text);\n\n      switch (result.state) {\n        case 'failed-parse':\n        case 'undefined-input':\n          return undefined;\n\n        case 'repaired-parse':\n        case 'successful-parse':\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value as DeepPartial<OUTPUT>,\n          };\n\n        default: {\n          const _exhaustiveCheck: never = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    parseOutput(\n      { text }: { text: string },\n      context: {\n        response: LanguageModelResponseMetadata;\n        usage: LanguageModelUsage;\n        finishReason: FinishReason;\n      },\n    ) {\n      const parseResult = safeParseJSON({ text });\n\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: could not parse the response.',\n          cause: parseResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      const validationResult = safeValidateTypes({\n        value: parseResult.value,\n        schema,\n      });\n\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: response did not match schema.',\n          cause: validationResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      return validationResult.value;\n    },\n  };\n};\n", "export {\n  AISDKError,\n  APICallError,\n  EmptyResponseBodyError,\n  InvalidPromptError,\n  InvalidResponseDataError,\n  JSONParseError,\n  LoadAPIKeyError,\n  NoContentGeneratedError,\n  NoSuchModelError,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport { InvalidArgumentError } from './invalid-argument-error';\nexport { InvalidStreamPartError } from './invalid-stream-part-error';\nexport { InvalidToolArgumentsError } from './invalid-tool-arguments-error';\nexport { NoImageGeneratedError } from './no-image-generated-error';\nexport { NoObjectGeneratedError } from './no-object-generated-error';\nexport { NoOutputSpecifiedError } from './no-output-specified-error';\nexport { NoSuchToolError } from './no-such-tool-error';\nexport { ToolCallRepairError } from './tool-call-repair-error';\nexport { ToolExecutionError } from './tool-execution-error';\nexport { MCPClientError } from './mcp-client-error';\n\nexport { InvalidDataContentError } from '../core/prompt/invalid-data-content-error';\nexport { InvalidMessageRoleError } from '../core/prompt/invalid-message-role-error';\nexport { MessageConversionError } from '../core/prompt/message-conversion-error';\nexport { DownloadError } from '../util/download-error';\nexport { RetryError } from '../util/retry-error';\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { SingleRequestTextStreamPart } from '../core/generate-text/run-tools-transformation';\n\nconst name = 'AI_InvalidStreamPartError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidStreamPartError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly chunk: SingleRequestTextStreamPart<any>;\n\n  constructor({\n    chunk,\n    message,\n  }: {\n    chunk: SingleRequestTextStreamPart<any>;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.chunk = chunk;\n  }\n\n  static isInstance(error: unknown): error is InvalidStreamPartError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_MCPClientError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * An error occurred with the MCP client.\n */\nexport class MCPClientError extends AISDKError {\n  private readonly [symbol] = true;\n\n  constructor({\n    name = 'MCPClientError',\n    message,\n    cause,\n  }: {\n    name?: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n  }\n\n  static isInstance(error: unknown): error is MCPClientError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { delay as originalDelay } from '@ai-sdk/provider-utils';\nimport { TextStreamPart } from './stream-text-result';\nimport { ToolSet } from './tool-set';\nimport { InvalidArgumentError } from '@ai-sdk/provider';\n\nconst CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m,\n};\n\n/**\n * Detects the first chunk in a buffer.\n *\n * @param buffer - The buffer to detect the first chunk in.\n *\n * @returns The first detected chunk, or `undefined` if no chunk was detected.\n */\nexport type ChunkDetector = (buffer: string) => string | undefined | null;\n\n/**\n * Smooths text streaming output.\n *\n * @param delayInMs - The delay in milliseconds between each chunk. Defaults to 10ms. Can be set to `null` to skip the delay.\n * @param chunking - Controls how the text is chunked for streaming. Use \"word\" to stream word by word (default), \"line\" to stream line by line, or provide a custom RegExp pattern for custom chunking.\n *\n * @returns A transform stream that smooths text streaming output.\n */\nexport function smoothStream<TOOLS extends ToolSet>({\n  delayInMs = 10,\n  chunking = 'word',\n  _internal: { delay = originalDelay } = {},\n}: {\n  delayInMs?: number | null;\n  chunking?: 'word' | 'line' | RegExp | ChunkDetector;\n  /**\n   * Internal. For test use only. May change without notice.\n   */\n  _internal?: {\n    delay?: (delayInMs: number | null) => Promise<void>;\n  };\n} = {}): (options: {\n  tools: TOOLS;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>> {\n  let detectChunk: ChunkDetector;\n\n  if (typeof chunking === 'function') {\n    detectChunk = buffer => {\n      const match = chunking(buffer);\n\n      if (match == null) {\n        return null;\n      }\n\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`,\n        );\n      }\n\n      return match;\n    };\n  } else {\n    const chunkingRegex =\n      typeof chunking === 'string' ? CHUNKING_REGEXPS[chunking] : chunking;\n\n    if (chunkingRegex == null) {\n      throw new InvalidArgumentError({\n        argument: 'chunking',\n        message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`,\n      });\n    }\n\n    detectChunk = buffer => {\n      const match = chunkingRegex.exec(buffer);\n\n      if (!match) {\n        return null;\n      }\n\n      return buffer.slice(0, match.index) + match?.[0];\n    };\n  }\n\n  return () => {\n    let buffer = '';\n\n    return new TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>({\n      async transform(chunk, controller) {\n        if (chunk.type !== 'text-delta') {\n          if (buffer.length > 0) {\n            controller.enqueue({ type: 'text-delta', textDelta: buffer });\n            buffer = '';\n          }\n\n          controller.enqueue(chunk);\n          return;\n        }\n\n        buffer += chunk.textDelta;\n\n        let match;\n\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type: 'text-delta', textDelta: match });\n          buffer = buffer.slice(match.length);\n\n          await delay(delayInMs);\n        }\n      },\n    });\n  };\n}\n", "import { AISDKError, LanguageModelV1Source } from '@ai-sdk/provider';\nimport { createIdGenerator, IDGenerator } from '@ai-sdk/provider-utils';\nimport { DataStreamString, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { Span } from '@opentelemetry/api';\nimport { ServerResponse } from 'node:http';\nimport { InvalidArgumentError } from '../../errors/invalid-argument-error';\nimport { InvalidStreamPartError } from '../../errors/invalid-stream-part-error';\nimport { NoOutputSpecifiedError } from '../../errors/no-output-specified-error';\nimport { StreamData } from '../../streams/stream-data';\nimport { asArray } from '../../util/as-array';\nimport { consumeStream } from '../../util/consume-stream';\nimport { DelayedPromise } from '../../util/delayed-promise';\nimport { DataStreamWriter } from '../data-stream/data-stream-writer';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { CoreAssistantMessage } from '../prompt/message';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  FinishReason,\n  LanguageModel,\n  LogProbs,\n  ToolChoice,\n} from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata, ProviderOptions } from '../types/provider-metadata';\nimport { addLanguageModelUsage, LanguageModelUsage } from '../types/usage';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { mergeStreams } from '../util/merge-streams';\nimport { now as originalNow } from '../util/now';\nimport { prepareOutgoingHttpHeaders } from '../util/prepare-outgoing-http-headers';\nimport { prepareResponseHeaders } from '../util/prepare-response-headers';\nimport { splitOnLastWhitespace } from '../util/split-on-last-whitespace';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { GeneratedFile } from './generated-file';\nimport { Output } from './output';\nimport { asReasoningText, ReasoningDetail } from './reasoning-detail';\nimport {\n  runToolsTransformation,\n  SingleRequestTextStreamPart,\n} from './run-tools-transformation';\nimport { ResponseMessage, StepResult } from './step-result';\nimport {\n  ConsumeStreamOptions,\n  DataStreamOptions,\n  StreamTextResult,\n  TextStreamPart,\n} from './stream-text-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultUnion } from './tool-result';\nimport { ToolSet } from './tool-set';\nimport { stringifyForTelemetry } from '../prompt/stringify-for-telemetry';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\nconst originalGenerateMessageId = createIdGenerator({\n  prefix: 'msg',\n  size: 24,\n});\n\n/**\nA transformation that is applied to the stream.\n\n@param stopStream - A function that stops the source stream.\n@param tools - The tools that are accessible to and can be called by the model. The model needs to support calling tools.\n */\nexport type StreamTextTransform<TOOLS extends ToolSet> = (options: {\n  tools: TOOLS; // for type inference\n  stopStream: () => void;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>;\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type StreamTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nCallback that is set using the `onChunk` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnChunkCallback<TOOLS extends ToolSet> = (event: {\n  chunk: Extract<\n    TextStreamPart<TOOLS>,\n    {\n      type:\n        | 'text-delta'\n        | 'reasoning'\n        | 'source'\n        | 'tool-call'\n        | 'tool-call-streaming-start'\n        | 'tool-call-delta'\n        | 'tool-result';\n    }\n  >;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnFinishCallback<TOOLS extends ToolSet> = (\n  event: Omit<StepResult<TOOLS>, 'stepType' | 'isContinued'> & {\n    /**\nDetails for all steps.\n   */\n    readonly steps: StepResult<TOOLS>[];\n  },\n) => Promise<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateText` instead.\n\n@param model - The language model to use.\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param maxSteps - Maximum number of sequential LLM calls (steps), e.g. when you use tool calls.\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onChunk - Callback that is called for each chunk of the stream. The stream processing will pause until the callback promise is resolved.\n@param onError - Callback that is called when an error occurs during streaming. You can use it to log errors.\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n@param onFinish - Callback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\n@return\nA result object for accessing different stream types and additional information.\n */\nexport function streamText<\n  TOOLS extends ToolSet,\n  OUTPUT = never,\n  PARTIAL_OUTPUT = never,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxSteps = 1,\n  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,\n  experimental_output: output,\n  experimental_continueSteps: continueSteps = false,\n  experimental_telemetry: telemetry,\n  experimental_providerMetadata,\n  providerOptions = experimental_providerMetadata,\n  experimental_toolCallStreaming = false,\n  toolCallStreaming = experimental_toolCallStreaming,\n  experimental_activeTools: activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  onChunk,\n  onError,\n  onFinish,\n  onStepFinish,\n  _internal: {\n    now = originalNow,\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n    */\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nMaximum number of sequential LLM calls (steps), e.g. when you use tool calls. Must be at least 1.\n\nA maximum number is required to prevent infinite loops in the case of misconfigured tools.\n\nBy default, it's set to 1, which means that only a single LLM call is made.\n */\n    maxSteps?: number;\n\n    /**\nGenerate a unique ID for each message.\n     */\n    experimental_generateMessageId?: IDGenerator;\n\n    /**\nWhen enabled, the model will perform additional steps if the finish reason is \"length\" (experimental).\n\nBy default, it's set to false.\n     */\n    experimental_continueSteps?: boolean;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n@deprecated Use `providerOptions` instead.\n */\n    experimental_providerMetadata?: ProviderMetadata;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    experimental_activeTools?: Array<keyof TOOLS>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    experimental_output?: Output<OUTPUT, PARTIAL_OUTPUT>;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\nEnable streaming of tool call deltas as they are generated. Disabled by default.\n     */\n    toolCallStreaming?: boolean;\n\n    /**\n@deprecated Use `toolCallStreaming` instead.\n     */\n    experimental_toolCallStreaming?: boolean;\n\n    /**\nOptional stream transformations.\nThey are applied in the order they are provided.\nThe stream transformations must maintain the stream structure for streamText to work correctly.\n     */\n    experimental_transform?:\n      | StreamTextTransform<TOOLS>\n      | Array<StreamTextTransform<TOOLS>>;\n\n    /**\nCallback that is called for each chunk of the stream.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onChunk?: StreamTextOnChunkCallback<TOOLS>;\n\n    /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onError?: StreamTextOnErrorCallback;\n\n    /**\nCallback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\nThe usage is the combined usage of all steps.\n     */\n    onFinish?: StreamTextOnFinishCallback<TOOLS>;\n\n    /**\nCallback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: StreamTextOnStepFinishCallback<TOOLS>;\n\n    /**\nInternal. For test use only. May change without notice.\n     */\n    _internal?: {\n      now?: () => number;\n      generateId?: IDGenerator;\n      currentDate?: () => Date;\n    };\n  }): StreamTextResult<TOOLS, PARTIAL_OUTPUT> {\n  return new DefaultStreamTextResult<TOOLS, OUTPUT, PARTIAL_OUTPUT>({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n    now,\n    currentDate,\n    generateId,\n    generateMessageId,\n  });\n}\n\ntype EnrichedStreamPart<TOOLS extends ToolSet, PARTIAL_OUTPUT> = {\n  part: TextStreamPart<TOOLS>;\n  partialOutput: PARTIAL_OUTPUT | undefined;\n};\n\nfunction createOutputTransformStream<\n  TOOLS extends ToolSet,\n  OUTPUT,\n  PARTIAL_OUTPUT,\n>(\n  output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined,\n): TransformStream<\n  TextStreamPart<TOOLS>,\n  EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n> {\n  if (!output) {\n    return new TransformStream<\n      TextStreamPart<TOOLS>,\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n      },\n    });\n  }\n\n  let text = '';\n  let textChunk = '';\n  let lastPublishedJson = '';\n\n  function publishTextChunk({\n    controller,\n    partialOutput = undefined,\n  }: {\n    controller: TransformStreamDefaultController<\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >;\n    partialOutput?: PARTIAL_OUTPUT;\n  }) {\n    controller.enqueue({\n      part: { type: 'text-delta', textDelta: textChunk },\n      partialOutput,\n    });\n    textChunk = '';\n  }\n\n  return new TransformStream<\n    TextStreamPart<TOOLS>,\n    EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n  >({\n    transform(chunk, controller) {\n      // ensure that we publish the last text chunk before the step finish:\n      if (chunk.type === 'step-finish') {\n        publishTextChunk({ controller });\n      }\n\n      if (chunk.type !== 'text-delta') {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n        return;\n      }\n\n      text += chunk.textDelta;\n      textChunk += chunk.textDelta;\n\n      // only publish if partial json can be parsed:\n      const result = output.parsePartial({ text });\n      if (result != null) {\n        // only send new json if it has changed:\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    },\n\n    flush(controller) {\n      // publish remaining text (there should be none if the content was correctly formatted):\n      if (textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n    },\n  });\n}\n\nclass DefaultStreamTextResult<TOOLS extends ToolSet, OUTPUT, PARTIAL_OUTPUT>\n  implements StreamTextResult<TOOLS, PARTIAL_OUTPUT>\n{\n  private readonly warningsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['warnings']>\n  >();\n  private readonly usagePromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['usage']>\n  >();\n  private readonly finishReasonPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['finishReason']>\n  >();\n  private readonly providerMetadataPromise = new DelayedPromise<\n    Awaited<\n      StreamTextResult<TOOLS, PARTIAL_OUTPUT>['experimental_providerMetadata']\n    >\n  >();\n  private readonly textPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['text']>\n  >();\n  private readonly reasoningPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['reasoning']>\n  >();\n  private readonly reasoningDetailsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['reasoningDetails']>\n  >();\n  private readonly sourcesPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['sources']>\n  >();\n  private readonly filesPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['files']>\n  >();\n  private readonly toolCallsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['toolCalls']>\n  >();\n  private readonly toolResultsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['toolResults']>\n  >();\n  private readonly requestPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['request']>\n  >();\n  private readonly responsePromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['response']>\n  >();\n  private readonly stepsPromise = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, PARTIAL_OUTPUT>['steps']>\n  >();\n\n  private readonly addStream: (\n    stream: ReadableStream<TextStreamPart<TOOLS>>,\n  ) => void;\n\n  private readonly closeStream: () => void;\n\n  private baseStream: ReadableStream<EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>>;\n\n  private output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined;\n\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    toolCallStreaming,\n    transforms,\n    activeTools,\n    repairToolCall,\n    maxSteps,\n    output,\n    continueSteps,\n    providerOptions,\n    now,\n    currentDate,\n    generateId,\n    generateMessageId,\n    onChunk,\n    onError,\n    onFinish,\n    onStepFinish,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    tools: TOOLS | undefined;\n    toolChoice: ToolChoice<TOOLS> | undefined;\n    toolCallStreaming: boolean;\n    transforms: Array<StreamTextTransform<TOOLS>>;\n    activeTools: Array<keyof TOOLS> | undefined;\n    repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n    maxSteps: number;\n    output: Output<OUTPUT, PARTIAL_OUTPUT> | undefined;\n    continueSteps: boolean;\n    providerOptions: ProviderOptions | undefined;\n    now: () => number;\n    currentDate: () => Date;\n    generateId: () => string;\n    generateMessageId: () => string;\n\n    // callbacks:\n    onChunk: undefined | StreamTextOnChunkCallback<TOOLS>;\n    onError: undefined | StreamTextOnErrorCallback;\n    onFinish: undefined | StreamTextOnFinishCallback<TOOLS>;\n    onStepFinish: undefined | StreamTextOnStepFinishCallback<TOOLS>;\n  }) {\n    if (maxSteps < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxSteps',\n        value: maxSteps,\n        message: 'maxSteps must be at least 1',\n      });\n    }\n\n    this.output = output;\n\n    // event processor for telemetry, invoking callbacks, etc.\n    // The event processor reads the transformed stream to enable correct\n    // recording of the final transformed outputs.\n    let recordedStepText = '';\n    let recordedContinuationText = '';\n    let recordedFullText = '';\n\n    let stepReasoning: Array<ReasoningDetail> = [];\n    let stepFiles: Array<GeneratedFile> = [];\n    let activeReasoningText: undefined | (ReasoningDetail & { type: 'text' }) =\n      undefined;\n\n    let recordedStepSources: LanguageModelV1Source[] = [];\n    const recordedSources: LanguageModelV1Source[] = [];\n\n    const recordedResponse: LanguageModelResponseMetadata & {\n      messages: Array<ResponseMessage>;\n    } = {\n      id: generateId(),\n      timestamp: currentDate(),\n      modelId: model.modelId,\n      messages: [],\n    };\n    let recordedToolCalls: ToolCallUnion<TOOLS>[] = [];\n    let recordedToolResults: ToolResultUnion<TOOLS>[] = [];\n    let recordedFinishReason: FinishReason | undefined = undefined;\n    let recordedUsage: LanguageModelUsage | undefined = undefined;\n    let stepType: 'initial' | 'continue' | 'tool-result' = 'initial';\n    const recordedSteps: StepResult<TOOLS>[] = [];\n    let rootSpan!: Span;\n\n    const eventProcessor = new TransformStream<\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n      EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>\n    >({\n      async transform(chunk, controller) {\n        controller.enqueue(chunk); // forward the chunk to the next stream\n\n        const { part } = chunk;\n\n        if (\n          part.type === 'text-delta' ||\n          part.type === 'reasoning' ||\n          part.type === 'source' ||\n          part.type === 'tool-call' ||\n          part.type === 'tool-result' ||\n          part.type === 'tool-call-streaming-start' ||\n          part.type === 'tool-call-delta'\n        ) {\n          await onChunk?.({ chunk: part });\n        }\n\n        if (part.type === 'error') {\n          await onError?.({ error: part.error });\n        }\n\n        if (part.type === 'text-delta') {\n          recordedStepText += part.textDelta;\n          recordedContinuationText += part.textDelta;\n          recordedFullText += part.textDelta;\n        }\n\n        if (part.type === 'reasoning') {\n          if (activeReasoningText == null) {\n            activeReasoningText = { type: 'text', text: part.textDelta };\n            stepReasoning.push(activeReasoningText);\n          } else {\n            activeReasoningText.text += part.textDelta;\n          }\n        }\n\n        if (part.type === 'reasoning-signature') {\n          if (activeReasoningText == null) {\n            throw new AISDKError({\n              name: 'InvalidStreamPart',\n              message: 'reasoning-signature without reasoning',\n            });\n          }\n\n          activeReasoningText.signature = part.signature;\n          activeReasoningText = undefined; // signature concludes reasoning part\n        }\n\n        if (part.type === 'redacted-reasoning') {\n          stepReasoning.push({ type: 'redacted', data: part.data });\n        }\n\n        if (part.type === 'file') {\n          stepFiles.push(part);\n        }\n\n        if (part.type === 'source') {\n          recordedSources.push(part.source);\n          recordedStepSources.push(part.source);\n        }\n\n        if (part.type === 'tool-call') {\n          recordedToolCalls.push(part);\n        }\n\n        if (part.type === 'tool-result') {\n          recordedToolResults.push(part);\n        }\n\n        if (part.type === 'step-finish') {\n          const stepMessages = toResponseMessages({\n            text: recordedContinuationText,\n            files: stepFiles,\n            reasoning: stepReasoning,\n            tools: tools ?? ({} as TOOLS),\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            messageId: part.messageId,\n            generateMessageId,\n          });\n\n          // determine the next step type\n          const currentStep = recordedSteps.length;\n          let nextStepType: 'done' | 'continue' | 'tool-result' = 'done';\n          if (currentStep + 1 < maxSteps) {\n            if (\n              continueSteps &&\n              part.finishReason === 'length' &&\n              // only use continue when there are no tool calls:\n              recordedToolCalls.length === 0\n            ) {\n              nextStepType = 'continue';\n            } else if (\n              // there are tool calls:\n              recordedToolCalls.length > 0 &&\n              // all current tool calls have results:\n              recordedToolResults.length === recordedToolCalls.length\n            ) {\n              nextStepType = 'tool-result';\n            }\n          }\n\n          // Add step information (after response messages are updated):\n          const currentStepResult: StepResult<TOOLS> = {\n            stepType,\n            text: recordedStepText,\n            reasoning: asReasoningText(stepReasoning),\n            reasoningDetails: stepReasoning,\n            files: stepFiles,\n            sources: recordedStepSources,\n            toolCalls: recordedToolCalls,\n            toolResults: recordedToolResults,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: part.warnings,\n            logprobs: part.logprobs,\n            request: part.request,\n            response: {\n              ...part.response,\n              messages: [...recordedResponse.messages, ...stepMessages],\n            },\n            providerMetadata: part.experimental_providerMetadata,\n            experimental_providerMetadata: part.experimental_providerMetadata,\n            isContinued: part.isContinued,\n          };\n\n          await onStepFinish?.(currentStepResult);\n\n          recordedSteps.push(currentStepResult);\n\n          recordedToolCalls = [];\n          recordedToolResults = [];\n          recordedStepText = '';\n          recordedStepSources = [];\n          stepReasoning = [];\n          stepFiles = [];\n          activeReasoningText = undefined;\n\n          if (nextStepType !== 'done') {\n            stepType = nextStepType;\n          }\n\n          if (nextStepType !== 'continue') {\n            recordedResponse.messages.push(...stepMessages);\n            recordedContinuationText = '';\n          }\n        }\n\n        if (part.type === 'finish') {\n          recordedResponse.id = part.response.id;\n          recordedResponse.timestamp = part.response.timestamp;\n          recordedResponse.modelId = part.response.modelId;\n          recordedResponse.headers = part.response.headers;\n          recordedUsage = part.usage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            return; // no steps recorded (e.g. in error scenario)\n          }\n\n          // from last step (when there are errors there may be no last step)\n          const lastStep = recordedSteps[recordedSteps.length - 1];\n\n          self.warningsPromise.resolve(lastStep.warnings);\n          self.requestPromise.resolve(lastStep.request);\n          self.responsePromise.resolve(lastStep.response);\n          self.toolCallsPromise.resolve(lastStep.toolCalls);\n          self.toolResultsPromise.resolve(lastStep.toolResults);\n          self.providerMetadataPromise.resolve(\n            lastStep.experimental_providerMetadata,\n          );\n          self.reasoningPromise.resolve(lastStep.reasoning);\n          self.reasoningDetailsPromise.resolve(lastStep.reasoningDetails);\n\n          // derived:\n          const finishReason = recordedFinishReason ?? 'unknown';\n          const usage = recordedUsage ?? {\n            completionTokens: NaN,\n            promptTokens: NaN,\n            totalTokens: NaN,\n          };\n\n          // from finish:\n          self.finishReasonPromise.resolve(finishReason);\n          self.usagePromise.resolve(usage);\n\n          // aggregate results:\n          self.textPromise.resolve(recordedFullText);\n          self.sourcesPromise.resolve(recordedSources);\n          self.filesPromise.resolve(lastStep.files);\n          self.stepsPromise.resolve(recordedSteps);\n\n          // call onFinish callback:\n          await onFinish?.({\n            finishReason,\n            logprobs: undefined,\n            usage,\n            text: recordedFullText,\n            reasoning: lastStep.reasoning,\n            reasoningDetails: lastStep.reasoningDetails,\n            files: lastStep.files,\n            sources: lastStep.sources,\n            toolCalls: lastStep.toolCalls,\n            toolResults: lastStep.toolResults,\n            request: lastStep.request ?? {},\n            response: lastStep.response,\n            warnings: lastStep.warnings,\n            providerMetadata: lastStep.providerMetadata,\n            experimental_providerMetadata:\n              lastStep.experimental_providerMetadata,\n            steps: recordedSteps,\n          });\n\n          // Add response information to the root span:\n          rootSpan.setAttributes(\n            selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                'ai.response.finishReason': finishReason,\n                'ai.response.text': { output: () => recordedFullText },\n                'ai.response.toolCalls': {\n                  output: () =>\n                    lastStep.toolCalls?.length\n                      ? JSON.stringify(lastStep.toolCalls)\n                      : undefined,\n                },\n\n                'ai.usage.promptTokens': usage.promptTokens,\n                'ai.usage.completionTokens': usage.completionTokens,\n              },\n            }),\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      },\n    });\n\n    // initialize the stitchable stream and the transformed stream:\n    const stitchableStream = createStitchableStream<TextStreamPart<TOOLS>>();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n\n    let stream = stitchableStream.stream;\n\n    // transform the stream before output parsing\n    // to enable replacement of stream segments:\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools: tools as TOOLS,\n          stopStream() {\n            stitchableStream.terminate();\n          },\n        }),\n      );\n    }\n\n    this.baseStream = stream\n      .pipeThrough(createOutputTransformStream(output))\n      .pipeThrough(eventProcessor);\n\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n    });\n\n    const tracer = getTracer(telemetry);\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...settings, maxRetries },\n    });\n\n    const initialPrompt = standardizePrompt({\n      prompt: {\n        system: output?.injectIntoSystemPrompt({ system, model }) ?? system,\n        prompt,\n        messages,\n      },\n      tools,\n    });\n\n    const self = this;\n\n    recordSpan({\n      name: 'ai.streamText',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: 'ai.streamText', telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.settings.maxSteps': maxSteps,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpanArg => {\n        rootSpan = rootSpanArg;\n\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage,\n          stepType,\n          previousStepText,\n          hasLeadingWhitespace,\n          messageId,\n        }: {\n          currentStep: number;\n          responseMessages: Array<ResponseMessage>;\n          usage: LanguageModelUsage;\n          stepType: 'initial' | 'continue' | 'tool-result';\n          previousStepText: string;\n          hasLeadingWhitespace: boolean;\n          messageId: string;\n        }) {\n          // after the 1st step, we need to switch to messages format:\n          const promptFormat =\n            responseMessages.length === 0 ? initialPrompt.type : 'messages';\n\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages,\n          ];\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              type: promptFormat,\n              system: initialPrompt.system,\n              messages: stepInputMessages,\n            },\n            modelSupportsImageUrls: model.supportsImageUrls,\n            modelSupportsUrl: model.supportsUrl?.bind(model), // support 'this' context\n          });\n\n          const mode = {\n            type: 'regular' as const,\n            ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools }),\n          };\n\n          const {\n            result: { stream, warnings, rawResponse, request },\n            doStreamSpan,\n            startTimestampMs,\n          } = await retry(() =>\n            recordSpan({\n              name: 'ai.streamText.doStream',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.streamText.doStream',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  'ai.prompt.format': {\n                    input: () => promptFormat,\n                  },\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.prompt.tools': {\n                    // convert the language model level tools:\n                    input: () => mode.tools?.map(tool => JSON.stringify(tool)),\n                  },\n                  'ai.prompt.toolChoice': {\n                    input: () =>\n                      mode.toolChoice != null\n                        ? JSON.stringify(mode.toolChoice)\n                        : undefined,\n                  },\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': model.provider,\n                  'gen_ai.request.model': model.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.stop_sequences': settings.stopSequences,\n                  'gen_ai.request.temperature': settings.temperature,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async doStreamSpan => ({\n                startTimestampMs: now(), // get before the call\n                doStreamSpan,\n                result: await model.doStream({\n                  mode,\n                  ...prepareCallSettings(settings),\n                  inputFormat: promptFormat,\n                  responseFormat: output?.responseFormat({ model }),\n                  prompt: promptMessages,\n                  providerMetadata: providerOptions,\n                  abortSignal,\n                  headers,\n                }),\n              }),\n            }),\n          );\n\n          const transformedStream = runToolsTransformation({\n            tools,\n            generatorStream: stream,\n            toolCallStreaming,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal,\n          });\n\n          const stepRequest = request ?? {};\n          const stepToolCalls: ToolCallUnion<TOOLS>[] = [];\n          const stepToolResults: ToolResultUnion<TOOLS>[] = [];\n\n          const stepReasoning: Array<ReasoningDetail> = [];\n          const stepFiles: Array<GeneratedFile> = [];\n          let activeReasoningText:\n            | undefined\n            | (ReasoningDetail & { type: 'text' }) = undefined;\n\n          let stepFinishReason: FinishReason = 'unknown';\n          let stepUsage: LanguageModelUsage = {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0,\n          };\n          let stepProviderMetadata: ProviderMetadata | undefined;\n          let stepFirstChunk = true;\n          let stepText = '';\n          let fullStepText = stepType === 'continue' ? previousStepText : '';\n          let stepLogProbs: LogProbs | undefined;\n          let stepResponse: { id: string; timestamp: Date; modelId: string } = {\n            id: generateId(),\n            timestamp: currentDate(),\n            modelId: model.modelId,\n          };\n\n          // chunk buffer when using continue:\n          let chunkBuffer = '';\n          let chunkTextPublished = false;\n          let inWhitespacePrefix = true;\n          let hasWhitespaceSuffix = false; // for next step. when true, step ended with whitespace\n\n          async function publishTextChunk({\n            controller,\n            chunk,\n          }: {\n            controller: TransformStreamDefaultController<TextStreamPart<TOOLS>>;\n            chunk: TextStreamPart<TOOLS> & { type: 'text-delta' };\n          }) {\n            controller.enqueue(chunk);\n\n            stepText += chunk.textDelta;\n            fullStepText += chunk.textDelta;\n            chunkTextPublished = true;\n            hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n          }\n\n          self.addStream(\n            transformedStream.pipeThrough(\n              new TransformStream<\n                SingleRequestTextStreamPart<TOOLS>,\n                TextStreamPart<TOOLS>\n              >({\n                async transform(chunk, controller): Promise<void> {\n                  if (stepFirstChunk) {\n                    // Telemetry for first chunk:\n                    const msToFirstChunk = now() - startTimestampMs;\n\n                    stepFirstChunk = false;\n\n                    doStreamSpan.addEvent('ai.stream.firstChunk', {\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    doStreamSpan.setAttributes({\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    // Step start:\n                    controller.enqueue({\n                      type: 'step-start',\n                      messageId,\n                      request: stepRequest,\n                      warnings: warnings ?? [],\n                    });\n                  }\n\n                  // Filter out empty text deltas\n                  if (\n                    chunk.type === 'text-delta' &&\n                    chunk.textDelta.length === 0\n                  ) {\n                    return;\n                  }\n\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case 'text-delta': {\n                      if (continueSteps) {\n                        // when a new step starts, leading whitespace is to be discarded\n                        // when there is already preceding whitespace in the chunk buffer\n                        const trimmedChunkText =\n                          inWhitespacePrefix && hasLeadingWhitespace\n                            ? chunk.textDelta.trimStart()\n                            : chunk.textDelta;\n\n                        if (trimmedChunkText.length === 0) {\n                          break;\n                        }\n\n                        inWhitespacePrefix = false;\n                        chunkBuffer += trimmedChunkText;\n\n                        const split = splitOnLastWhitespace(chunkBuffer);\n\n                        // publish the text until the last whitespace:\n                        if (split != null) {\n                          chunkBuffer = split.suffix;\n\n                          await publishTextChunk({\n                            controller,\n                            chunk: {\n                              type: 'text-delta',\n                              textDelta: split.prefix + split.whitespace,\n                            },\n                          });\n                        }\n                      } else {\n                        await publishTextChunk({ controller, chunk });\n                      }\n                      break;\n                    }\n\n                    case 'reasoning': {\n                      controller.enqueue(chunk);\n\n                      if (activeReasoningText == null) {\n                        activeReasoningText = {\n                          type: 'text',\n                          text: chunk.textDelta,\n                        };\n                        stepReasoning.push(activeReasoningText);\n                      } else {\n                        activeReasoningText.text += chunk.textDelta;\n                      }\n\n                      break;\n                    }\n\n                    case 'reasoning-signature': {\n                      controller.enqueue(chunk);\n\n                      if (activeReasoningText == null) {\n                        throw new InvalidStreamPartError({\n                          chunk,\n                          message: 'reasoning-signature without reasoning',\n                        });\n                      }\n\n                      activeReasoningText.signature = chunk.signature;\n                      activeReasoningText = undefined; // signature concludes reasoning part\n                      break;\n                    }\n\n                    case 'redacted-reasoning': {\n                      controller.enqueue(chunk);\n                      stepReasoning.push({\n                        type: 'redacted',\n                        data: chunk.data,\n                      });\n\n                      break;\n                    }\n\n                    case 'tool-call': {\n                      controller.enqueue(chunk);\n                      // store tool calls for onFinish callback and toolCalls promise:\n                      stepToolCalls.push(chunk);\n                      break;\n                    }\n\n                    case 'tool-result': {\n                      controller.enqueue(chunk);\n                      // store tool results for onFinish callback and toolResults promise:\n                      stepToolResults.push(chunk);\n                      break;\n                    }\n\n                    case 'response-metadata': {\n                      stepResponse = {\n                        id: chunk.id ?? stepResponse.id,\n                        timestamp: chunk.timestamp ?? stepResponse.timestamp,\n                        modelId: chunk.modelId ?? stepResponse.modelId,\n                      };\n                      break;\n                    }\n\n                    case 'finish': {\n                      // Note: tool executions might not be finished yet when the finish event is emitted.\n                      // store usage and finish reason for promises and onFinish callback:\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepProviderMetadata =\n                        chunk.experimental_providerMetadata;\n                      stepLogProbs = chunk.logprobs;\n\n                      // Telemetry for finish event timing\n                      // (since tool executions can take longer and distort calculations)\n                      const msToFinish = now() - startTimestampMs;\n                      doStreamSpan.addEvent('ai.stream.finish');\n                      doStreamSpan.setAttributes({\n                        'ai.response.msToFinish': msToFinish,\n                        'ai.response.avgCompletionTokensPerSecond':\n                          (1000 * stepUsage.completionTokens) / msToFinish,\n                      });\n\n                      break;\n                    }\n\n                    case 'file': {\n                      stepFiles.push(chunk);\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    // forward:\n                    case 'source':\n                    case 'tool-call-streaming-start':\n                    case 'tool-call-delta': {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'error': {\n                      controller.enqueue(chunk);\n                      stepFinishReason = 'error';\n                      break;\n                    }\n\n                    default: {\n                      const exhaustiveCheck: never = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson =\n                    stepToolCalls.length > 0\n                      ? JSON.stringify(stepToolCalls)\n                      : undefined;\n\n                  // determine the next step type\n                  let nextStepType: 'done' | 'continue' | 'tool-result' =\n                    'done';\n                  if (currentStep + 1 < maxSteps) {\n                    if (\n                      continueSteps &&\n                      stepFinishReason === 'length' &&\n                      // only use continue when there are no tool calls:\n                      stepToolCalls.length === 0\n                    ) {\n                      nextStepType = 'continue';\n                    } else if (\n                      // there are tool calls:\n                      stepToolCalls.length > 0 &&\n                      // all current tool calls have results:\n                      stepToolResults.length === stepToolCalls.length\n                    ) {\n                      nextStepType = 'tool-result';\n                    }\n                  }\n\n                  // when using continuation, publish buffer on final step or if there\n                  // was no whitespace in the step:\n                  if (\n                    continueSteps &&\n                    chunkBuffer.length > 0 &&\n                    (nextStepType !== 'continue' || // when the next step is a regular step, publish the buffer\n                      (stepType === 'continue' && !chunkTextPublished)) // when the next step is a continue step, publish the buffer if no text was published in the step\n                  ) {\n                    await publishTextChunk({\n                      controller,\n                      chunk: {\n                        type: 'text-delta',\n                        textDelta: chunkBuffer,\n                      },\n                    });\n                    chunkBuffer = '';\n                  }\n\n                  // record telemetry information first to ensure best effort timing\n                  try {\n                    doStreamSpan.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          'ai.response.finishReason': stepFinishReason,\n                          'ai.response.text': { output: () => stepText },\n                          'ai.response.toolCalls': {\n                            output: () => stepToolCallsJson,\n                          },\n                          'ai.response.id': stepResponse.id,\n                          'ai.response.model': stepResponse.modelId,\n                          'ai.response.timestamp':\n                            stepResponse.timestamp.toISOString(),\n\n                          'ai.usage.promptTokens': stepUsage.promptTokens,\n                          'ai.usage.completionTokens':\n                            stepUsage.completionTokens,\n\n                          // standardized gen-ai llm span attributes:\n                          'gen_ai.response.finish_reasons': [stepFinishReason],\n                          'gen_ai.response.id': stepResponse.id,\n                          'gen_ai.response.model': stepResponse.modelId,\n                          'gen_ai.usage.input_tokens': stepUsage.promptTokens,\n                          'gen_ai.usage.output_tokens':\n                            stepUsage.completionTokens,\n                        },\n                      }),\n                    );\n                  } catch (error) {\n                    // ignore error setting telemetry attributes\n                  } finally {\n                    // finish doStreamSpan before other operations for correct timing:\n                    doStreamSpan.end();\n                  }\n\n                  controller.enqueue({\n                    type: 'step-finish',\n                    finishReason: stepFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    experimental_providerMetadata: stepProviderMetadata,\n                    logprobs: stepLogProbs,\n                    request: stepRequest,\n                    response: {\n                      ...stepResponse,\n                      headers: rawResponse?.headers,\n                    },\n                    warnings,\n                    isContinued: nextStepType === 'continue',\n                    messageId,\n                  });\n\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n\n                  if (nextStepType === 'done') {\n                    controller.enqueue({\n                      type: 'finish',\n                      finishReason: stepFinishReason,\n                      usage: combinedUsage,\n                      providerMetadata: stepProviderMetadata,\n                      experimental_providerMetadata: stepProviderMetadata,\n                      logprobs: stepLogProbs,\n                      response: {\n                        ...stepResponse,\n                        headers: rawResponse?.headers,\n                      },\n                    });\n\n                    self.closeStream(); // close the stitchable stream\n                  } else {\n                    // append to messages for the next step:\n                    if (stepType === 'continue') {\n                      // continue step: update the last assistant message\n                      // continue is only possible when there are no tool calls,\n                      // so we can assume that there is a single last assistant message:\n                      const lastMessage = responseMessages[\n                        responseMessages.length - 1\n                      ] as CoreAssistantMessage;\n\n                      if (typeof lastMessage.content === 'string') {\n                        lastMessage.content += stepText;\n                      } else {\n                        lastMessage.content.push({\n                          text: stepText,\n                          type: 'text',\n                        });\n                      }\n                    } else {\n                      responseMessages.push(\n                        ...toResponseMessages({\n                          text: stepText,\n                          files: stepFiles,\n                          reasoning: stepReasoning,\n                          tools: tools ?? ({} as TOOLS),\n                          toolCalls: stepToolCalls,\n                          toolResults: stepToolResults,\n                          messageId,\n                          generateMessageId,\n                        }),\n                      );\n                    }\n\n                    await streamStep({\n                      currentStep: currentStep + 1,\n                      responseMessages,\n                      usage: combinedUsage,\n                      stepType: nextStepType,\n                      previousStepText: fullStepText,\n                      hasLeadingWhitespace: hasWhitespaceSuffix,\n                      messageId:\n                        // keep the same id when continuing a step:\n                        nextStepType === 'continue'\n                          ? messageId\n                          : generateMessageId(),\n                    });\n                  }\n                },\n              }),\n            ),\n          );\n        }\n\n        // add the initial stream to the stitchable stream\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0,\n          },\n          previousStepText: '',\n          stepType: 'initial',\n          hasLeadingWhitespace: false,\n          messageId: generateMessageId(),\n        });\n      },\n    }).catch(error => {\n      // add an error stream part and close the streams:\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: 'error', error });\n            controller.close();\n          },\n        }),\n      );\n      self.closeStream();\n    });\n  }\n\n  get warnings() {\n    return this.warningsPromise.value;\n  }\n\n  get usage() {\n    return this.usagePromise.value;\n  }\n\n  get finishReason() {\n    return this.finishReasonPromise.value;\n  }\n\n  get experimental_providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get providerMetadata() {\n    return this.providerMetadataPromise.value;\n  }\n\n  get text() {\n    return this.textPromise.value;\n  }\n\n  get reasoning() {\n    return this.reasoningPromise.value;\n  }\n\n  get reasoningDetails() {\n    return this.reasoningDetailsPromise.value;\n  }\n\n  get sources() {\n    return this.sourcesPromise.value;\n  }\n\n  get files() {\n    return this.filesPromise.value;\n  }\n\n  get toolCalls() {\n    return this.toolCallsPromise.value;\n  }\n\n  get toolResults() {\n    return this.toolResultsPromise.value;\n  }\n\n  get request() {\n    return this.requestPromise.value;\n  }\n\n  get response() {\n    return this.responsePromise.value;\n  }\n\n  get steps() {\n    return this.stepsPromise.value;\n  }\n\n  /**\nSplit out a new stream from the original stream.\nThe original stream is replaced to allow for further splitting,\nsince we do not know how many times the stream will be split.\n\nNote: this leads to buffering the stream content on the server.\nHowever, the LLM results are expected to be small enough to not cause issues.\n   */\n  private teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>, string>({\n          transform({ part }, controller) {\n            if (part.type === 'text-delta') {\n              controller.enqueue(part.textDelta);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<TextStreamPart<TOOLS>> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n          TextStreamPart<TOOLS>\n        >({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          },\n        }),\n      ),\n    );\n  }\n\n  async consumeStream(options?: ConsumeStreamOptions): Promise<void> {\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options?.onError,\n      });\n    } catch (error) {\n      options?.onError?.(error);\n    }\n  }\n\n  get experimental_partialOutputStream(): AsyncIterableStream<PARTIAL_OUTPUT> {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, PARTIAL_OUTPUT>,\n          PARTIAL_OUTPUT\n        >({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  private toDataStreamInternal({\n    getErrorMessage = () => 'An error occurred.', // mask error messages for safety by default\n    sendUsage = true,\n    sendReasoning = false,\n    sendSources = false,\n    experimental_sendFinish = true,\n  }: {\n    getErrorMessage: ((error: unknown) => string) | undefined;\n    sendUsage: boolean | undefined;\n    sendReasoning: boolean | undefined;\n    sendSources: boolean | undefined;\n    experimental_sendFinish: boolean | undefined;\n  }): ReadableStream<DataStreamString> {\n    return this.fullStream.pipeThrough(\n      new TransformStream<TextStreamPart<TOOLS>, DataStreamString>({\n        transform: async (chunk, controller) => {\n          const chunkType = chunk.type;\n          switch (chunkType) {\n            case 'text-delta': {\n              controller.enqueue(formatDataStreamPart('text', chunk.textDelta));\n              break;\n            }\n\n            case 'reasoning': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('reasoning', chunk.textDelta),\n                );\n              }\n              break;\n            }\n\n            case 'redacted-reasoning': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('redacted_reasoning', {\n                    data: chunk.data,\n                  }),\n                );\n              }\n              break;\n            }\n\n            case 'reasoning-signature': {\n              if (sendReasoning) {\n                controller.enqueue(\n                  formatDataStreamPart('reasoning_signature', {\n                    signature: chunk.signature,\n                  }),\n                );\n              }\n              break;\n            }\n\n            case 'file': {\n              controller.enqueue(\n                formatDataStreamPart('file', {\n                  mimeType: chunk.mimeType,\n                  data: chunk.base64,\n                }),\n              );\n              break;\n            }\n\n            case 'source': {\n              if (sendSources) {\n                controller.enqueue(\n                  formatDataStreamPart('source', chunk.source),\n                );\n              }\n              break;\n            }\n\n            case 'tool-call-streaming-start': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call_streaming_start', {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-call-delta': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call_delta', {\n                  toolCallId: chunk.toolCallId,\n                  argsTextDelta: chunk.argsTextDelta,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-call': {\n              controller.enqueue(\n                formatDataStreamPart('tool_call', {\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  args: chunk.args,\n                }),\n              );\n              break;\n            }\n\n            case 'tool-result': {\n              controller.enqueue(\n                formatDataStreamPart('tool_result', {\n                  toolCallId: chunk.toolCallId,\n                  result: chunk.result,\n                }),\n              );\n              break;\n            }\n\n            case 'error': {\n              controller.enqueue(\n                formatDataStreamPart('error', getErrorMessage(chunk.error)),\n              );\n              break;\n            }\n\n            case 'step-start': {\n              controller.enqueue(\n                formatDataStreamPart('start_step', {\n                  messageId: chunk.messageId,\n                }),\n              );\n              break;\n            }\n\n            case 'step-finish': {\n              controller.enqueue(\n                formatDataStreamPart('finish_step', {\n                  finishReason: chunk.finishReason,\n                  usage: sendUsage\n                    ? {\n                        promptTokens: chunk.usage.promptTokens,\n                        completionTokens: chunk.usage.completionTokens,\n                      }\n                    : undefined,\n                  isContinued: chunk.isContinued,\n                }),\n              );\n              break;\n            }\n\n            case 'finish': {\n              if (experimental_sendFinish) {\n                controller.enqueue(\n                  formatDataStreamPart('finish_message', {\n                    finishReason: chunk.finishReason,\n                    usage: sendUsage\n                      ? {\n                          promptTokens: chunk.usage.promptTokens,\n                          completionTokens: chunk.usage.completionTokens,\n                        }\n                      : undefined,\n                  }),\n                );\n              }\n              break;\n            }\n\n            default: {\n              const exhaustiveCheck: never = chunkType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n      }),\n    );\n  }\n\n  pipeDataStreamToResponse(\n    response: ServerResponse,\n    {\n      status,\n      statusText,\n      headers,\n      data,\n      getErrorMessage,\n      sendUsage,\n      sendReasoning,\n      sendSources,\n      experimental_sendFinish,\n    }: ResponseInit &\n      DataStreamOptions & {\n        data?: StreamData;\n        getErrorMessage?: (error: unknown) => string;\n      } = {},\n  ) {\n    writeToServerResponse({\n      response,\n      status,\n      statusText,\n      headers: prepareOutgoingHttpHeaders(headers, {\n        contentType: 'text/plain; charset=utf-8',\n        dataStreamVersion: 'v1',\n      }),\n      stream: this.toDataStream({\n        data,\n        getErrorMessage,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n      }),\n    });\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    writeToServerResponse({\n      response,\n      status: init?.status,\n      statusText: init?.statusText,\n      headers: prepareOutgoingHttpHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n      stream: this.textStream.pipeThrough(new TextEncoderStream()),\n    });\n  }\n\n  // TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())\n  toDataStream(\n    options?: DataStreamOptions & {\n      data?: StreamData;\n      getErrorMessage?: (error: unknown) => string;\n    },\n  ) {\n    const stream = this.toDataStreamInternal({\n      getErrorMessage: options?.getErrorMessage,\n      sendUsage: options?.sendUsage,\n      sendReasoning: options?.sendReasoning,\n      sendSources: options?.sendSources,\n      experimental_sendFinish: options?.experimental_sendFinish,\n    }).pipeThrough(new TextEncoderStream());\n\n    return options?.data ? mergeStreams(options?.data.stream, stream) : stream;\n  }\n\n  mergeIntoDataStream(writer: DataStreamWriter, options?: DataStreamOptions) {\n    writer.merge(\n      this.toDataStreamInternal({\n        getErrorMessage: writer.onError,\n        sendUsage: options?.sendUsage,\n        sendReasoning: options?.sendReasoning,\n        sendSources: options?.sendSources,\n        experimental_sendFinish: options?.experimental_sendFinish,\n      }),\n    );\n  }\n\n  toDataStreamResponse({\n    headers,\n    status,\n    statusText,\n    data,\n    getErrorMessage,\n    sendUsage,\n    sendReasoning,\n    sendSources,\n    experimental_sendFinish,\n  }: ResponseInit &\n    DataStreamOptions & {\n      data?: StreamData;\n      getErrorMessage?: (error: unknown) => string;\n    } = {}): Response {\n    return new Response(\n      this.toDataStream({\n        data,\n        getErrorMessage,\n        sendUsage,\n        sendReasoning,\n        sendSources,\n        experimental_sendFinish,\n      }),\n      {\n        status,\n        statusText,\n        headers: prepareResponseHeaders(headers, {\n          contentType: 'text/plain; charset=utf-8',\n          dataStreamVersion: 'v1',\n        }),\n      },\n    );\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: init?.status ?? 200,\n      headers: prepareResponseHeaders(init?.headers, {\n        contentType: 'text/plain; charset=utf-8',\n      }),\n    });\n  }\n}\n", "export function asArray<T>(value: T | T[] | undefined): T[] {\n  return value === undefined ? [] : Array.isArray(value) ? value : [value];\n}\n", "/**\n * Consumes a ReadableStream until it's fully read.\n *\n * This function reads the stream chunk by chunk until the stream is exhausted.\n * It doesn't process or return the data from the stream; it simply ensures\n * that the entire stream is read.\n *\n * @param {ReadableStream} stream - The ReadableStream to be consumed.\n * @returns {Promise<void>} A promise that resolves when the stream is fully consumed.\n */\nexport async function consumeStream({\n  stream,\n  onError,\n}: {\n  stream: ReadableStream;\n  onError?: (error: unknown) => void;\n}): Promise<void> {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done) break;\n    }\n  } catch (error) {\n    onError?.(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n", "/**\n * Merges two readable streams into a single readable stream, emitting values\n * from each stream as they become available.\n *\n * The first stream is prioritized over the second stream. If both streams have\n * values available, the first stream's value is emitted first.\n *\n * @template VALUE1 - The type of values emitted by the first stream.\n * @template VALUE2 - The type of values emitted by the second stream.\n * @param {ReadableStream<VALUE1>} stream1 - The first readable stream.\n * @param {ReadableStream<VALUE2>} stream2 - The second readable stream.\n * @returns {ReadableStream<VALUE1 | VALUE2>} A new readable stream that emits values from both input streams.\n */\nexport function mergeStreams<VALUE1, VALUE2>(\n  stream1: ReadableStream<VALUE1>,\n  stream2: ReadableStream<VALUE2>,\n): ReadableStream<VALUE1 | VALUE2> {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n\n  let lastRead1: Promise<ReadableStreamReadResult<VALUE1>> | undefined =\n    undefined;\n  let lastRead2: Promise<ReadableStreamReadResult<VALUE2>> | undefined =\n    undefined;\n\n  let stream1Done = false;\n  let stream2Done = false;\n\n  // only use when stream 2 is done:\n  async function readStream1(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n\n      const result = await lastRead1;\n      lastRead1 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  // only use when stream 1 is done:\n  async function readStream2(\n    controller: ReadableStreamDefaultController<VALUE1 | VALUE2>,\n  ) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n\n      const result = await lastRead2;\n      lastRead2 = undefined;\n\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n\n  return new ReadableStream<VALUE1 | VALUE2>({\n    async pull(controller) {\n      try {\n        // stream 1 is done, we can only read from stream 2:\n        if (stream1Done) {\n          await readStream2(controller);\n          return;\n        }\n\n        // stream 2 is done, we can only read from stream 1:\n        if (stream2Done) {\n          await readStream1(controller);\n          return;\n        }\n\n        // pull the next value from the stream that was read last:\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n\n        // Note on Promise.race (prioritizing stream 1 over stream 2):\n        // If the iterable contains one or more non-promise values and/or an already settled promise,\n        // then Promise.race() will settle to the first of these values found in the iterable.\n        const { result, reader } = await Promise.race([\n          lastRead1.then(result => ({ result, reader: reader1 })),\n          lastRead2.then(result => ({ result, reader: reader2 })),\n        ]);\n\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n\n        if (reader === reader1) {\n          lastRead1 = undefined;\n          if (result.done) {\n            // stream 1 is done, we can only read from stream 2:\n            await readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = undefined;\n          // stream 2 is done, we can only read from stream 1:\n          if (result.done) {\n            stream2Done = true;\n            await readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    },\n  });\n}\n", "import { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport { generateId } from '@ai-sdk/ui-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { ToolExecutionError } from '../../errors';\nimport { CoreMessage } from '../prompt/message';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  FinishReason,\n  LanguageModelUsage,\n  LogProbs,\n  ProviderMetadata,\n} from '../types';\nimport { Source } from '../types/language-model';\nimport { calculateLanguageModelUsage } from '../types/usage';\nimport { DefaultGeneratedFileWithType, GeneratedFile } from './generated-file';\nimport { parseToolCall } from './parse-tool-call';\nimport { ToolCallUnion } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair';\nimport { ToolResultUnion } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nexport type SingleRequestTextStreamPart<TOOLS extends ToolSet> =\n  | {\n      type: 'text-delta';\n      textDelta: string;\n    }\n  | {\n      type: 'reasoning';\n      textDelta: string;\n    }\n  | {\n      type: 'reasoning-signature';\n      signature: string;\n    }\n  | {\n      type: 'redacted-reasoning';\n      data: string;\n    }\n  | ({\n      type: 'file';\n    } & GeneratedFile)\n  | {\n      type: 'source';\n      source: Source;\n    }\n  | ({\n      type: 'tool-call';\n    } & ToolCallUnion<TOOLS>)\n  | {\n      type: 'tool-call-streaming-start';\n      toolCallId: string;\n      toolName: string;\n    }\n  | {\n      type: 'tool-call-delta';\n      toolCallId: string;\n      toolName: string;\n      argsTextDelta: string;\n    }\n  | ({\n      type: 'tool-result';\n    } & ToolResultUnion<TOOLS>)\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      logprobs?: LogProbs;\n      usage: LanguageModelUsage;\n      experimental_providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'error';\n      error: unknown;\n    };\n\nexport function runToolsTransformation<TOOLS extends ToolSet>({\n  tools,\n  generatorStream,\n  toolCallStreaming,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n}: {\n  tools: TOOLS | undefined;\n  generatorStream: ReadableStream<LanguageModelV1StreamPart>;\n  toolCallStreaming: boolean;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  system: string | undefined;\n  messages: CoreMessage[];\n  abortSignal: AbortSignal | undefined;\n  repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n}): ReadableStream<SingleRequestTextStreamPart<TOOLS>> {\n  // tool results stream\n  let toolResultsStreamController: ReadableStreamDefaultController<\n    SingleRequestTextStreamPart<TOOLS>\n  > | null = null;\n  const toolResultsStream = new ReadableStream<\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    start(controller) {\n      toolResultsStreamController = controller;\n    },\n  });\n\n  // keep track of active tool calls for tool call streaming:\n  const activeToolCalls: Record<string, boolean> = {};\n\n  // keep track of outstanding tool results for stream closing:\n  const outstandingToolResults = new Set<string>();\n\n  let canClose = false;\n  let finishChunk:\n    | (SingleRequestTextStreamPart<TOOLS> & { type: 'finish' })\n    | undefined = undefined;\n\n  function attemptClose() {\n    // close the tool results controller if no more outstanding tool calls\n    if (canClose && outstandingToolResults.size === 0) {\n      // we delay sending the finish chunk until all tool results (incl. delayed ones)\n      // are received to ensure that the frontend receives tool results before a message\n      // finish event arrives.\n      if (finishChunk != null) {\n        toolResultsStreamController!.enqueue(finishChunk);\n      }\n\n      toolResultsStreamController!.close();\n    }\n  }\n\n  // forward stream\n  const forwardStream = new TransformStream<\n    LanguageModelV1StreamPart,\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    async transform(\n      chunk: LanguageModelV1StreamPart,\n      controller: TransformStreamDefaultController<\n        SingleRequestTextStreamPart<TOOLS>\n      >,\n    ) {\n      const chunkType = chunk.type;\n\n      switch (chunkType) {\n        // forward:\n        case 'text-delta':\n        case 'reasoning':\n        case 'reasoning-signature':\n        case 'redacted-reasoning':\n        case 'source':\n        case 'response-metadata':\n        case 'error': {\n          controller.enqueue(chunk);\n          break;\n        }\n\n        case 'file': {\n          controller.enqueue(\n            new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mimeType: chunk.mimeType,\n            }),\n          );\n          break;\n        }\n\n        // forward with less information:\n        case 'tool-call-delta': {\n          if (toolCallStreaming) {\n            if (!activeToolCalls[chunk.toolCallId]) {\n              controller.enqueue({\n                type: 'tool-call-streaming-start',\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n              });\n\n              activeToolCalls[chunk.toolCallId] = true;\n            }\n\n            controller.enqueue({\n              type: 'tool-call-delta',\n              toolCallId: chunk.toolCallId,\n              toolName: chunk.toolName,\n              argsTextDelta: chunk.argsTextDelta,\n            });\n          }\n          break;\n        }\n\n        // process tool call:\n        case 'tool-call': {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages,\n            });\n\n            controller.enqueue(toolCall);\n\n            const tool = tools![toolCall.toolName];\n\n            if (tool.execute != null) {\n              const toolExecutionId = generateId(); // use our own id to guarantee uniqueness\n              outstandingToolResults.add(toolExecutionId);\n\n              // Note: we don't await the tool execution here (by leaving out 'await' on recordSpan),\n              // because we want to process the next chunk as soon as possible.\n              // This is important for the case where the tool execution takes a long time.\n              recordSpan({\n                name: 'ai.toolCall',\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: 'ai.toolCall',\n                      telemetry,\n                    }),\n                    'ai.toolCall.name': toolCall.toolName,\n                    'ai.toolCall.id': toolCall.toolCallId,\n                    'ai.toolCall.args': {\n                      output: () => JSON.stringify(toolCall.args),\n                    },\n                  },\n                }),\n                tracer,\n                fn: async span =>\n                  tool.execute!(toolCall.args, {\n                    toolCallId: toolCall.toolCallId,\n                    messages,\n                    abortSignal,\n                  }).then(\n                    (result: any) => {\n                      toolResultsStreamController!.enqueue({\n                        ...toolCall,\n                        type: 'tool-result',\n                        result,\n                      } as any);\n\n                      outstandingToolResults.delete(toolExecutionId);\n\n                      attemptClose();\n\n                      // record telemetry\n                      try {\n                        span.setAttributes(\n                          selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                              'ai.toolCall.result': {\n                                output: () => JSON.stringify(result),\n                              },\n                            },\n                          }),\n                        );\n                      } catch (ignored) {\n                        // JSON stringify might fail if the result is not serializable,\n                        // in which case we just ignore it. In the future we might want to\n                        // add an optional serialize method to the tool interface and warn\n                        // if the result is not serializable.\n                      }\n                    },\n                    (error: any) => {\n                      toolResultsStreamController!.enqueue({\n                        type: 'error',\n                        error: new ToolExecutionError({\n                          toolCallId: toolCall.toolCallId,\n                          toolName: toolCall.toolName,\n                          toolArgs: toolCall.args,\n                          cause: error,\n                        }),\n                      });\n\n                      outstandingToolResults.delete(toolExecutionId);\n                      attemptClose();\n                    },\n                  ),\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController!.enqueue({\n              type: 'error',\n              error,\n            });\n          }\n\n          break;\n        }\n\n        case 'finish': {\n          finishChunk = {\n            type: 'finish',\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateLanguageModelUsage(chunk.usage),\n            experimental_providerMetadata: chunk.providerMetadata,\n          };\n          break;\n        }\n\n        default: {\n          const _exhaustiveCheck: never = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    flush() {\n      canClose = true;\n      attemptClose();\n    },\n  });\n\n  // combine the generator stream and the tool results stream\n  return new ReadableStream<SingleRequestTextStreamPart<TOOLS>>({\n    async start(controller) {\n      // need to wait for both pipes so there are no dangling promises that\n      // can cause uncaught promise rejections when the stream is aborted\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              // the generator stream controller is automatically closed when it's consumed\n            },\n          }),\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            },\n          }),\n        ),\n      ]);\n    },\n  });\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { SpeechModelResponseMetadata } from '../core/types/speech-model-response-metadata';\n\n/**\nError that is thrown when no speech audio was generated.\n */\nexport class NoSpeechGeneratedError extends AISDKError {\n  readonly responses: Array<SpeechModelResponseMetadata>;\n\n  constructor(options: { responses: Array<SpeechModelResponseMetadata> }) {\n    super({\n      name: 'AI_NoSpeechGeneratedError',\n      message: 'No speech audio generated.',\n    });\n\n    this.responses = options.responses;\n  }\n}\n", "import {\n  GeneratedFile,\n  DefaultGeneratedFile,\n} from '../generate-text/generated-file';\n\n/**\n * A generated audio file.\n */\nexport interface GeneratedAudioFile extends GeneratedFile {\n  /**\n   * Audio format of the file (e.g., 'mp3', 'wav', etc.)\n   */\n  readonly format: string;\n}\n\nexport class DefaultGeneratedAudioFile\n  extends DefaultGeneratedFile\n  implements GeneratedAudioFile\n{\n  readonly format: string;\n\n  constructor({\n    data,\n    mimeType,\n  }: {\n    data: string | Uint8Array;\n    mimeType: string;\n  }) {\n    super({ data, mimeType });\n    let format = 'mp3';\n\n    // If format is not provided, try to determine it from the mimeType\n    if (mimeType) {\n      const mimeTypeParts = mimeType.split('/');\n\n      if (mimeTypeParts.length === 2) {\n        // Handle special cases for audio formats\n        if (mimeType !== 'audio/mpeg') {\n          format = mimeTypeParts[1];\n        }\n      }\n    }\n\n    if (!format) {\n      throw new Error(\n        'Audio format must be provided or determinable from mimeType',\n      );\n    }\n\n    this.format = format;\n  }\n}\n\nexport class DefaultGeneratedAudioFileWithType extends DefaultGeneratedAudioFile {\n  readonly type = 'audio';\n\n  constructor(options: {\n    data: string | Uint8Array;\n    mimeType: string;\n    format: string;\n  }) {\n    super(options);\n  }\n}\n", "import { JSONValue, SpeechModelV1 } from '@ai-sdk/provider';\nimport { NoSpeechGeneratedError } from '../../errors/no-speech-generated-error';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { SpeechWarning } from '../types/speech-model';\nimport { SpeechModelResponseMetadata } from '../types/speech-model-response-metadata';\nimport { SpeechResult } from './generate-speech-result';\nimport {\n  audioMimeTypeSignatures,\n  detectMimeType,\n} from '../util/detect-mimetype';\nimport {\n  DefaultGeneratedAudioFile,\n  GeneratedAudioFile,\n} from './generated-audio-file';\n\n/**\nGenerates speech audio using a speech model.\n\n@param model - The speech model to use.\n@param text - The text to convert to speech.\n@param voice - The voice to use for speech generation.\n@param outputFormat - The output format to use for speech generation e.g. \"mp3\", \"wav\", etc.\n@param instructions - Instructions for the speech generation e.g. \"Speak in a slow and steady tone\".\n@param speed - The speed of the speech generation.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated audio data.\n */\nexport async function generateSpeech({\n  model,\n  text,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe speech model to use.\n     */\n  model: SpeechModelV1;\n\n  /**\nThe text to convert to speech.\n   */\n  text: string;\n\n  /**\nThe voice to use for speech generation.\n   */\n  voice?: string;\n\n  /**\n   * The desired output format for the audio e.g. \"mp3\", \"wav\", etc.\n   */\n  outputFormat?: 'mp3' | 'wav' | (string & {});\n\n  /**\n    Instructions for the speech generation e.g. \"Speak in a slow and steady tone\".\n  */\n  instructions?: string;\n\n  /**\n  The speed of the speech generation.\n   */\n  speed?: number;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {}\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per speech model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<SpeechResult> {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n\n  const result = await retry(() =>\n    model.doGenerate({\n      text,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      abortSignal,\n      headers,\n      providerOptions,\n    }),\n  );\n\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mimeType:\n        detectMimeType({\n          data: result.audio,\n          signatures: audioMimeTypeSignatures,\n        }) ?? 'audio/mp3',\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata,\n  });\n}\n\nclass DefaultSpeechResult implements SpeechResult {\n  readonly audio: GeneratedAudioFile;\n  readonly warnings: Array<SpeechWarning>;\n  readonly responses: Array<SpeechModelResponseMetadata>;\n  readonly providerMetadata: Record<string, Record<string, JSONValue>>;\n\n  constructor(options: {\n    audio: GeneratedAudioFile;\n    warnings: Array<SpeechWarning>;\n    responses: Array<SpeechModelResponseMetadata>;\n    providerMetadata: Record<string, Record<string, JSONValue>> | undefined;\n  }) {\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata ?? {};\n  }\n}\n", "import { AISDKError } from '@ai-sdk/provider';\nimport { TranscriptionModelResponseMetadata } from '../core/types/transcription-model-response-metadata';\n\n/**\nError that is thrown when no transcript was generated.\n */\nexport class NoTranscriptGeneratedError extends AISDKError {\n  readonly responses: Array<TranscriptionModelResponseMetadata>;\n\n  constructor(options: {\n    responses: Array<TranscriptionModelResponseMetadata>;\n  }) {\n    super({\n      name: 'AI_NoTranscriptGeneratedError',\n      message: 'No transcript generated.',\n    });\n\n    this.responses = options.responses;\n  }\n}\n", "import { JSONValue, TranscriptionModelV1 } from '@ai-sdk/provider';\nimport { NoTranscriptGeneratedError } from '../../errors/no-transcript-generated-error';\nimport { download } from '../../util/download';\nimport { DataContent } from '../prompt';\nimport { convertDataContentToUint8Array } from '../prompt/data-content';\nimport { prepareRetries } from '../prompt/prepare-retries';\nimport { ProviderOptions } from '../types/provider-metadata';\nimport { TranscriptionWarning } from '../types/transcription-model';\nimport { TranscriptionModelResponseMetadata } from '../types/transcription-model-response-metadata';\nimport {\n  audioMimeTypeSignatures,\n  detectMimeType,\n} from '../util/detect-mimetype';\nimport { TranscriptionResult } from './transcribe-result';\n\n/**\nGenerates transcripts using a transcription model.\n\n@param model - The transcription model to use.\n@param audio - The audio data to transcribe as DataContent (string | Uint8Array | ArrayBuffer | Buffer) or a URL.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated transcript.\n */\nexport async function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe transcription model to use.\n     */\n  model: TranscriptionModelV1;\n\n  /**\nThe audio data to transcribe.\n   */\n  audio: DataContent | URL;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {\n    \"temperature\": 0\n  }\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per transcript model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<TranscriptionResult> {\n  const { retry } = prepareRetries({ maxRetries: maxRetriesArg });\n  const audioData =\n    audio instanceof URL\n      ? (await download({ url: audio })).data\n      : convertDataContentToUint8Array(audio);\n\n  const result = await retry(() =>\n    model.doGenerate({\n      audio: audioData,\n      abortSignal,\n      headers,\n      providerOptions,\n      mediaType:\n        detectMimeType({\n          data: audioData,\n          signatures: audioMimeTypeSignatures,\n        }) ?? 'audio/wav',\n    }),\n  );\n\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata,\n  });\n}\n\nclass DefaultTranscriptionResult implements TranscriptionResult {\n  readonly text: string;\n  readonly segments: Array<{\n    text: string;\n    startSecond: number;\n    endSecond: number;\n  }>;\n  readonly language: string | undefined;\n  readonly durationInSeconds: number | undefined;\n  readonly warnings: Array<TranscriptionWarning>;\n  readonly responses: Array<TranscriptionModelResponseMetadata>;\n  readonly providerMetadata: Record<string, Record<string, JSONValue>>;\n\n  constructor(options: {\n    text: string;\n    segments: Array<{\n      text: string;\n      startSecond: number;\n      endSecond: number;\n    }>;\n    language: string | undefined;\n    durationInSeconds: number | undefined;\n    warnings: Array<TranscriptionWarning>;\n    responses: Array<TranscriptionModelResponseMetadata>;\n    providerMetadata: Record<string, Record<string, JSONValue>> | undefined;\n  }) {\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata ?? {};\n  }\n}\n", "/**\n * Deeply merges two objects together.\n * - Properties from the second object override those in the first object with the same key\n * - For nested objects, the merge is performed recursively (deep merge)\n * - Arrays are replaced, not merged\n * - Primitive values are replaced\n * - If both inputs are undefined, returns undefined\n * - If one input is undefined, returns the other\n *\n * @param target The target object to merge into\n * @param source The source object to merge from\n * @returns A new object with the merged properties, or undefined if both inputs are undefined\n */\nexport function mergeObjects<T extends object, U extends object>(\n  target: T | undefined,\n  source: U | undefined,\n): (T & U) | T | U | undefined {\n  // If both inputs are undefined, return undefined\n  if (target === undefined && source === undefined) {\n    return undefined;\n  }\n\n  // If target is undefined, return source\n  if (target === undefined) {\n    return source;\n  }\n\n  // If source is undefined, return target\n  if (source === undefined) {\n    return target;\n  }\n\n  // Create a new object to avoid mutating the inputs\n  const result = { ...target } as T & U;\n\n  // Iterate through all keys in the source object\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      const sourceValue = source[key];\n\n      // Skip if the source value is undefined\n      if (sourceValue === undefined) continue;\n\n      // Get the target value if it exists\n      const targetValue =\n        key in target ? target[key as unknown as keyof T] : undefined;\n\n      // Check if both values are objects that can be deeply merged\n      const isSourceObject =\n        sourceValue !== null &&\n        typeof sourceValue === 'object' &&\n        !Array.isArray(sourceValue) &&\n        !(sourceValue instanceof Date) &&\n        !(sourceValue instanceof RegExp);\n\n      const isTargetObject =\n        targetValue !== null &&\n        targetValue !== undefined &&\n        typeof targetValue === 'object' &&\n        !Array.isArray(targetValue) &&\n        !(targetValue instanceof Date) &&\n        !(targetValue instanceof RegExp);\n\n      // If both values are mergeable objects, merge them recursively\n      if (isSourceObject && isTargetObject) {\n        result[key as keyof (T & U)] = mergeObjects(\n          targetValue as object,\n          sourceValue as object,\n        ) as any;\n      } else {\n        // For primitives, arrays, or when one value is not a mergeable object,\n        // simply override with the source value\n        result[key as keyof (T & U)] = sourceValue as any;\n      }\n    }\n  }\n\n  return result;\n}\n", "import {\n  LanguageModelV1CallOptions,\n  LanguageModelV1ProviderMetadata,\n} from '@ai-sdk/provider';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\nimport { mergeObjects } from '../util/merge-objects';\n\n/**\n * Applies default settings for a language model.\n */\nexport function defaultSettingsMiddleware({\n  settings,\n}: {\n  settings: Partial<\n    LanguageModelV1CallOptions & {\n      providerMetadata?: LanguageModelV1ProviderMetadata;\n    }\n  >;\n}): LanguageModelV1Middleware {\n  return {\n    middlewareVersion: 'v1',\n    transformParams: async ({ params }) => {\n      return {\n        ...settings,\n        ...params,\n        providerMetadata: mergeObjects(\n          settings.providerMetadata,\n          params.providerMetadata,\n        ),\n\n        // special case for temperature 0\n        // TODO remove when temperature defaults to undefined\n        temperature:\n          params.temperature === 0 || params.temperature == null\n            ? (settings.temperature ?? 0)\n            : params.temperature,\n      };\n    },\n  };\n}\n", "/**\n * Returns the index of the start of the searchedText in the text, or null if it\n * is not found.\n */\nexport function getPotentialStartIndex(\n  text: string,\n  searchedText: string,\n): number | null {\n  // Return null immediately if searchedText is empty.\n  if (searchedText.length === 0) {\n    return null;\n  }\n\n  // Check if the searchedText exists as a direct substring of text.\n  const directIndex = text.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n\n  // Otherwise, look for the largest suffix of \"text\" that matches\n  // a prefix of \"searchedText\". We go from the end of text inward.\n  for (let i = text.length - 1; i >= 0; i--) {\n    const suffix = text.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n\n  return null;\n}\n", "import type { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport { getPotentialStartIndex } from '../util/get-potential-start-index';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\n\n/**\n * Extract an XML-tagged reasoning section from the generated text and exposes it\n * as a `reasoning` property on the result.\n *\n * @param tagName - The name of the XML tag to extract reasoning from.\n * @param separator - The separator to use between reasoning and text sections.\n * @param startWithReasoning - Whether to start with reasoning tokens.\n */\nexport function extractReasoningMiddleware({\n  tagName,\n  separator = '\\n',\n  startWithReasoning = false,\n}: {\n  tagName: string;\n  separator?: string;\n  startWithReasoning?: boolean;\n}): LanguageModelV1Middleware {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `<\\/${tagName}>`;\n\n  return {\n    middlewareVersion: 'v1',\n    wrapGenerate: async ({ doGenerate }) => {\n      const { text: rawText, ...rest } = await doGenerate();\n\n      if (rawText == null) {\n        return { text: rawText, ...rest };\n      }\n\n      const text = startWithReasoning ? openingTag + rawText : rawText;\n\n      const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, 'gs');\n      const matches = Array.from(text.matchAll(regexp));\n\n      if (!matches.length) {\n        return { text, ...rest };\n      }\n\n      const reasoning = matches.map(match => match[1]).join(separator);\n\n      let textWithoutReasoning = text;\n      for (let i = matches.length - 1; i >= 0; i--) {\n        const match = matches[i];\n\n        const beforeMatch = textWithoutReasoning.slice(0, match.index);\n        const afterMatch = textWithoutReasoning.slice(\n          match.index! + match[0].length,\n        );\n\n        textWithoutReasoning =\n          beforeMatch +\n          (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : '') +\n          afterMatch;\n      }\n\n      return { ...rest, text: textWithoutReasoning, reasoning };\n    },\n\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n\n      let isFirstReasoning = true;\n      let isFirstText = true;\n      let afterSwitch = false;\n      let isReasoning = startWithReasoning;\n      let buffer = '';\n\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream<\n            LanguageModelV1StreamPart,\n            LanguageModelV1StreamPart\n          >({\n            transform: (chunk, controller) => {\n              if (chunk.type !== 'text-delta') {\n                controller.enqueue(chunk);\n                return;\n              }\n\n              buffer += chunk.textDelta;\n\n              function publish(text: string) {\n                if (text.length > 0) {\n                  const prefix =\n                    afterSwitch &&\n                    (isReasoning ? !isFirstReasoning : !isFirstText)\n                      ? separator\n                      : '';\n\n                  controller.enqueue({\n                    type: isReasoning ? 'reasoning' : 'text-delta',\n                    textDelta: prefix + text,\n                  });\n                  afterSwitch = false;\n\n                  if (isReasoning) {\n                    isFirstReasoning = false;\n                  } else {\n                    isFirstText = false;\n                  }\n                }\n              }\n\n              do {\n                const nextTag = isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(buffer, nextTag);\n\n                // no opening or closing tag found, publish the buffer\n                if (startIndex == null) {\n                  publish(buffer);\n                  buffer = '';\n                  break;\n                }\n\n                // publish text before the tag\n                publish(buffer.slice(0, startIndex));\n\n                const foundFullMatch =\n                  startIndex + nextTag.length <= buffer.length;\n\n                if (foundFullMatch) {\n                  buffer = buffer.slice(startIndex + nextTag.length);\n                  isReasoning = !isReasoning;\n                  afterSwitch = true;\n                } else {\n                  buffer = buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            },\n          }),\n        ),\n        ...rest,\n      };\n    },\n  };\n}\n", "import type { LanguageModelV1StreamPart } from '@ai-sdk/provider';\nimport type { LanguageModelV1Middleware } from './language-model-v1-middleware';\n\n/**\n * Simulates streaming chunks with the response from a generate call.\n */\nexport function simulateStreamingMiddleware(): LanguageModelV1Middleware {\n  return {\n    middlewareVersion: 'v1',\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n\n      const simulatedStream = new ReadableStream<LanguageModelV1StreamPart>({\n        start(controller) {\n          controller.enqueue({ type: 'response-metadata', ...result.response });\n\n          if (result.reasoning) {\n            if (typeof result.reasoning === 'string') {\n              controller.enqueue({\n                type: 'reasoning',\n                textDelta: result.reasoning,\n              });\n            } else {\n              for (const reasoning of result.reasoning) {\n                switch (reasoning.type) {\n                  case 'text': {\n                    controller.enqueue({\n                      type: 'reasoning',\n                      textDelta: reasoning.text,\n                    });\n                    if (reasoning.signature != null) {\n                      controller.enqueue({\n                        type: 'reasoning-signature',\n                        signature: reasoning.signature,\n                      });\n                    }\n                    break;\n                  }\n                  case 'redacted': {\n                    controller.enqueue({\n                      type: 'redacted-reasoning',\n                      data: reasoning.data,\n                    });\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          if (result.text) {\n            controller.enqueue({\n              type: 'text-delta',\n              textDelta: result.text,\n            });\n          }\n\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: 'tool-call-delta',\n                toolCallType: 'function',\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                argsTextDelta: toolCall.args,\n              });\n\n              controller.enqueue({\n                type: 'tool-call',\n                ...toolCall,\n              });\n            }\n          }\n\n          controller.enqueue({\n            type: 'finish',\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata,\n          });\n\n          controller.close();\n        },\n      });\n\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings,\n      };\n    },\n  };\n}\n", "import { LanguageModelV1, LanguageModelV1CallOptions } from '@ai-sdk/provider';\nimport { LanguageModelV1Middleware } from './language-model-v1-middleware';\nimport { asArray } from '../../util/as-array';\n\n/**\n * Wraps a LanguageModelV1 instance with middleware functionality.\n * This function allows you to apply middleware to transform parameters,\n * wrap generate operations, and wrap stream operations of a language model.\n *\n * @param options - Configuration options for wrapping the language model.\n * @param options.model - The original LanguageModelV1 instance to be wrapped.\n * @param options.middleware - The middleware to be applied to the language model. When multiple middlewares are provided, the first middleware will transform the input first, and the last middleware will be wrapped directly around the model.\n * @param options.modelId - Optional custom model ID to override the original model's ID.\n * @param options.providerId - Optional custom provider ID to override the original model's provider.\n * @returns A new LanguageModelV1 instance with middleware applied.\n */\nexport const wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV1;\n  middleware: LanguageModelV1Middleware | LanguageModelV1Middleware[];\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV1 => {\n  return asArray(middlewareArg)\n    .reverse()\n    .reduce((wrappedModel, middleware) => {\n      return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n    }, model);\n};\n\nconst doWrap = ({\n  model,\n  middleware: { transformParams, wrapGenerate, wrapStream },\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV1;\n  middleware: LanguageModelV1Middleware;\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV1 => {\n  async function doTransform({\n    params,\n    type,\n  }: {\n    params: LanguageModelV1CallOptions;\n    type: 'generate' | 'stream';\n  }) {\n    return transformParams ? await transformParams({ params, type }) : params;\n  }\n\n  return {\n    specificationVersion: 'v1',\n\n    provider: providerId ?? model.provider,\n    modelId: modelId ?? model.modelId,\n\n    defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n    supportsImageUrls: model.supportsImageUrls,\n    supportsUrl: model.supportsUrl?.bind(model),\n    supportsStructuredOutputs: model.supportsStructuredOutputs,\n\n    async doGenerate(\n      params: LanguageModelV1CallOptions,\n    ): Promise<Awaited<ReturnType<LanguageModelV1['doGenerate']>>> {\n      const transformedParams = await doTransform({ params, type: 'generate' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate\n        ? wrapGenerate({\n            doGenerate,\n            doStream,\n            params: transformedParams,\n            model,\n          })\n        : doGenerate();\n    },\n\n    async doStream(\n      params: LanguageModelV1CallOptions,\n    ): Promise<Awaited<ReturnType<LanguageModelV1['doStream']>>> {\n      const transformedParams = await doTransform({ params, type: 'stream' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream\n        ? wrapStream({ doGenerate, doStream, params: transformedParams, model })\n        : doStream();\n    },\n  };\n};\n\n/**\n * @deprecated Use `wrapLanguageModel` instead.\n */\n// TODO remove in v5\nexport const experimental_wrapLanguageModel = wrapLanguageModel;\n", "import { Message } from '@ai-sdk/ui-utils';\n\n/**\n * Appends a client message to the messages array.\n * If the last message in the array has the same id as the new message, it will be replaced.\n * Otherwise, the new message will be appended.\n */\nexport function appendClientMessage({\n  messages,\n  message,\n}: {\n  messages: Message[];\n  message: Message;\n}) {\n  return [\n    ...(messages.length > 0 && messages[messages.length - 1].id === message.id\n      ? messages.slice(0, -1)\n      : messages),\n    message,\n  ];\n}\n", "import {\n  extractMaxToolInvocationStep,\n  FileUIPart,\n  Message,\n  ReasoningUIPart,\n  StepStartUIPart,\n  TextUIPart,\n  ToolInvocation,\n  ToolInvocationUIPart,\n} from '@ai-sdk/ui-utils';\nimport { ResponseMessage } from '../generate-text/step-result';\nimport { convertDataContentToBase64String } from './data-content';\nimport { AISDKError } from '@ai-sdk/provider';\n\n/**\n * Appends the ResponseMessage[] from the response to a Message[] (for useChat).\n * The messages are converted to Messages before being appended.\n * Timestamps are generated for the new messages.\n *\n * @returns A new Message[] with the response messages appended.\n */\nexport function appendResponseMessages({\n  messages,\n  responseMessages,\n  _internal: { currentDate = () => new Date() } = {},\n}: {\n  messages: Message[];\n  responseMessages: ResponseMessage[];\n\n  /**\nInternal. For test use only. May change without notice.\n     */\n  _internal?: {\n    currentDate?: () => Date;\n  };\n}): Message[] {\n  const clonedMessages = structuredClone(messages);\n\n  for (const message of responseMessages) {\n    const role = message.role;\n\n    // check if the last message is an assistant message:\n    const lastMessage = clonedMessages[clonedMessages.length - 1];\n    const isLastMessageAssistant = lastMessage.role === 'assistant';\n\n    switch (role) {\n      case 'assistant': {\n        function getToolInvocations(step: number) {\n          return (\n            typeof message.content === 'string'\n              ? []\n              : message.content.filter(part => part.type === 'tool-call')\n          ).map(call => ({\n            state: 'call' as const,\n            step,\n            args: call.args,\n            toolCallId: call.toolCallId,\n            toolName: call.toolName,\n          }));\n        }\n\n        const parts: Array<\n          | TextUIPart\n          | ReasoningUIPart\n          | ToolInvocationUIPart\n          | FileUIPart\n          | StepStartUIPart\n        > = [{ type: 'step-start' as const }]; // always start with a step-start part\n        let textContent = '';\n        let reasoningTextContent = undefined;\n\n        if (typeof message.content === 'string') {\n          textContent = message.content;\n          parts.push({\n            type: 'text' as const,\n            text: message.content,\n          });\n        } else {\n          let reasoningPart: ReasoningUIPart | undefined = undefined;\n          for (const part of message.content) {\n            switch (part.type) {\n              case 'text': {\n                reasoningPart = undefined; // reset the reasoning part\n\n                textContent += part.text;\n                parts.push({\n                  type: 'text' as const,\n                  text: part.text,\n                });\n                break;\n              }\n              case 'reasoning': {\n                if (reasoningPart == null) {\n                  reasoningPart = {\n                    type: 'reasoning' as const,\n                    reasoning: '',\n                    details: [],\n                  };\n                  parts.push(reasoningPart);\n                }\n\n                reasoningTextContent = (reasoningTextContent ?? '') + part.text;\n                reasoningPart.reasoning += part.text;\n                reasoningPart.details.push({\n                  type: 'text' as const,\n                  text: part.text,\n                  signature: part.signature,\n                });\n                break;\n              }\n              case 'redacted-reasoning': {\n                if (reasoningPart == null) {\n                  reasoningPart = {\n                    type: 'reasoning' as const,\n                    reasoning: '',\n                    details: [],\n                  };\n                  parts.push(reasoningPart);\n                }\n\n                reasoningPart.details.push({\n                  type: 'redacted' as const,\n                  data: part.data,\n                });\n                break;\n              }\n              case 'tool-call':\n                break;\n              case 'file':\n                if (part.data instanceof URL) {\n                  throw new AISDKError({\n                    name: 'InvalidAssistantFileData',\n                    message: 'File data cannot be a URL',\n                  });\n                }\n                parts.push({\n                  type: 'file' as const,\n                  mimeType: part.mimeType,\n                  data: convertDataContentToBase64String(part.data),\n                });\n                break;\n            }\n          }\n        }\n\n        if (isLastMessageAssistant) {\n          const maxStep = extractMaxToolInvocationStep(\n            lastMessage.toolInvocations,\n          );\n\n          lastMessage.parts ??= [];\n\n          lastMessage.content = textContent;\n          lastMessage.reasoning = reasoningTextContent;\n          lastMessage.parts.push(...parts);\n\n          lastMessage.toolInvocations = [\n            ...(lastMessage.toolInvocations ?? []),\n            ...getToolInvocations(maxStep === undefined ? 0 : maxStep + 1),\n          ];\n\n          getToolInvocations(maxStep === undefined ? 0 : maxStep + 1)\n            .map(call => ({\n              type: 'tool-invocation' as const,\n              toolInvocation: call,\n            }))\n            .forEach(part => {\n              lastMessage.parts!.push(part);\n            });\n        } else {\n          // last message was a user message, add the assistant message:\n          clonedMessages.push({\n            role: 'assistant',\n            id: message.id,\n            createdAt: currentDate(), // generate a createdAt date for the message, will be overridden by the client\n            content: textContent,\n            reasoning: reasoningTextContent,\n            toolInvocations: getToolInvocations(0),\n            parts: [\n              ...parts,\n              ...getToolInvocations(0).map(call => ({\n                type: 'tool-invocation' as const,\n                toolInvocation: call,\n              })),\n            ],\n          });\n        }\n\n        break;\n      }\n\n      case 'tool': {\n        // for tool call results, add the result to previous message:\n        lastMessage.toolInvocations ??= []; // ensure the toolInvocations array exists\n\n        if (lastMessage.role !== 'assistant') {\n          throw new Error(\n            `Tool result must follow an assistant message: ${lastMessage.role}`,\n          );\n        }\n\n        lastMessage.parts ??= [];\n\n        for (const contentPart of message.content) {\n          // find the tool call in the previous message:\n          const toolCall = lastMessage.toolInvocations.find(\n            call => call.toolCallId === contentPart.toolCallId,\n          );\n          const toolCallPart: ToolInvocationUIPart | undefined =\n            lastMessage.parts.find(\n              (part): part is ToolInvocationUIPart =>\n                part.type === 'tool-invocation' &&\n                part.toolInvocation.toolCallId === contentPart.toolCallId,\n            );\n\n          if (!toolCall) {\n            throw new Error('Tool call not found in previous message');\n          }\n\n          // add the result to the tool call:\n          toolCall.state = 'result';\n          const toolResult = toolCall as ToolInvocation & { state: 'result' };\n          toolResult.result = contentPart.result;\n\n          if (toolCallPart) {\n            toolCallPart.toolInvocation = toolResult;\n          } else {\n            lastMessage.parts.push({\n              type: 'tool-invocation' as const,\n              toolInvocation: toolResult,\n            });\n          }\n        }\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported message role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return clonedMessages;\n}\n", "import { NoSuchModelError, ProviderV1 } from '@ai-sdk/provider';\nimport { EmbeddingModel, ImageModel, LanguageModel, Provider } from '../types';\n\n/**\n * Creates a custom provider with specified language models, text embedding models, and an optional fallback provider.\n *\n * @param {Object} options - The options for creating the custom provider.\n * @param {Record<string, LanguageModel>} [options.languageModels] - A record of language models, where keys are model IDs and values are LanguageModel instances.\n * @param {Record<string, EmbeddingModel<string>>} [options.textEmbeddingModels] - A record of text embedding models, where keys are model IDs and values are EmbeddingModel<string> instances.\n * @param {Record<string, ImageModel>} [options.imageModels] - A record of image models, where keys are model IDs and values are ImageModel instances.\n * @param {Provider} [options.fallbackProvider] - An optional fallback provider to use when a requested model is not found in the custom provider.\n * @returns {Provider} A Provider object with languageModel, textEmbeddingModel, and imageModel methods.\n *\n * @throws {NoSuchModelError} Throws when a requested model is not found and no fallback provider is available.\n */\nexport function customProvider<\n  LANGUAGE_MODELS extends Record<string, LanguageModel>,\n  EMBEDDING_MODELS extends Record<string, EmbeddingModel<string>>,\n  IMAGE_MODELS extends Record<string, ImageModel>,\n>({\n  languageModels,\n  textEmbeddingModels,\n  imageModels,\n  fallbackProvider,\n}: {\n  languageModels?: LANGUAGE_MODELS;\n  textEmbeddingModels?: EMBEDDING_MODELS;\n  imageModels?: IMAGE_MODELS;\n  fallbackProvider?: ProviderV1;\n}): Provider & {\n  languageModel(modelId: ExtractModelId<LANGUAGE_MODELS>): LanguageModel;\n  textEmbeddingModel(\n    modelId: ExtractModelId<EMBEDDING_MODELS>,\n  ): EmbeddingModel<string>;\n  imageModel(modelId: ExtractModelId<IMAGE_MODELS>): ImageModel;\n} {\n  return {\n    languageModel(modelId: ExtractModelId<LANGUAGE_MODELS>): LanguageModel {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'languageModel' });\n    },\n\n    textEmbeddingModel(\n      modelId: ExtractModelId<EMBEDDING_MODELS>,\n    ): EmbeddingModel<string> {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'textEmbeddingModel' });\n    },\n\n    imageModel(modelId: ExtractModelId<IMAGE_MODELS>): ImageModel {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n\n      if (fallbackProvider?.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'imageModel' });\n    },\n  };\n}\n\n/**\n * @deprecated Use `customProvider` instead.\n */\nexport const experimental_customProvider = customProvider;\n\ntype ExtractModelId<MODELS extends Record<string, unknown>> = Extract<\n  keyof MODELS,\n  string\n>;\n", "import { AISDKError, NoSuchModelError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchProviderError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchProviderError extends NoSuchModelError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly providerId: string;\n  readonly availableProviders: string[];\n\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`,\n  }: {\n    modelId: string;\n    modelType: 'languageModel' | 'textEmbeddingModel';\n    providerId: string;\n    availableProviders: string[];\n    message?: string;\n  }) {\n    super({ errorName: name, modelId, modelType, message });\n\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n\n  static isInstance(error: unknown): error is NoSuchProviderError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n", "import { NoSuchModelError, ProviderV1 } from '@ai-sdk/provider';\nimport { EmbeddingModel, ImageModel, LanguageModel } from '../types';\nimport { NoSuchProviderError } from './no-such-provider-error';\n\ntype ExtractLiteralUnion<T> = T extends string\n  ? string extends T\n    ? never\n    : T\n  : never;\n\nexport interface ProviderRegistryProvider<\n  PROVIDERS extends Record<string, ProviderV1> = Record<string, ProviderV1>,\n  SEPARATOR extends string = ':',\n> {\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['languageModel']>>[0]>}`\n      : never,\n  ): LanguageModel;\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): LanguageModel;\n\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['textEmbeddingModel']>>[0]>}`\n      : never,\n  ): EmbeddingModel<string>;\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): EmbeddingModel<string>;\n\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['imageModel']>>[0]>}`\n      : never,\n  ): ImageModel;\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): ImageModel;\n}\n\n/**\n * Creates a registry for the given providers.\n */\nexport function createProviderRegistry<\n  PROVIDERS extends Record<string, ProviderV1>,\n  SEPARATOR extends string = ':',\n>(\n  providers: PROVIDERS,\n  {\n    separator = ':' as SEPARATOR,\n  }: {\n    separator?: SEPARATOR;\n  } = {},\n): ProviderRegistryProvider<PROVIDERS, SEPARATOR> {\n  const registry = new DefaultProviderRegistry<PROVIDERS, SEPARATOR>({\n    separator,\n  });\n\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider } as {\n      id: keyof PROVIDERS;\n      provider: PROVIDERS[keyof PROVIDERS];\n    });\n  }\n\n  return registry;\n}\n\n/**\n * @deprecated Use `createProviderRegistry` instead.\n */\nexport const experimental_createProviderRegistry = createProviderRegistry;\n\nclass DefaultProviderRegistry<\n  PROVIDERS extends Record<string, ProviderV1>,\n  SEPARATOR extends string,\n> implements ProviderRegistryProvider<PROVIDERS, SEPARATOR>\n{\n  private providers: PROVIDERS = {} as PROVIDERS;\n  private separator: SEPARATOR;\n\n  constructor({ separator }: { separator: SEPARATOR }) {\n    this.separator = separator;\n  }\n\n  registerProvider<K extends keyof PROVIDERS>({\n    id,\n    provider,\n  }: {\n    id: K;\n    provider: PROVIDERS[K];\n  }): void {\n    this.providers[id] = provider;\n  }\n\n  private getProvider(id: string): ProviderV1 {\n    const provider = this.providers[id as keyof PROVIDERS];\n\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType: 'languageModel',\n        providerId: id,\n        availableProviders: Object.keys(this.providers),\n      });\n    }\n\n    return provider;\n  }\n\n  private splitId(\n    id: string,\n    modelType: 'languageModel' | 'textEmbeddingModel' | 'imageModel',\n  ): [string, string] {\n    const index = id.indexOf(this.separator);\n\n    if (index === -1) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType,\n        message:\n          `Invalid ${modelType} id for registry: ${id} ` +\n          `(must be in the format \"providerId${this.separator}modelId\")`,\n      });\n    }\n\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): LanguageModel {\n    const [providerId, modelId] = this.splitId(id, 'languageModel');\n    const model = this.getProvider(providerId).languageModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'languageModel' });\n    }\n\n    return model;\n  }\n\n  textEmbeddingModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): EmbeddingModel<string> {\n    const [providerId, modelId] = this.splitId(id, 'textEmbeddingModel');\n    const provider = this.getProvider(providerId);\n\n    const model = provider.textEmbeddingModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType: 'textEmbeddingModel',\n      });\n    }\n\n    return model;\n  }\n\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): ImageModel {\n    const [providerId, modelId] = this.splitId(id, 'imageModel');\n    const provider = this.getProvider(providerId);\n\n    const model = provider.imageModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'imageModel' });\n    }\n\n    return model;\n  }\n}\n", "import { JSONSchema7 } from '@ai-sdk/provider';\nimport { jsonSchema } from '@ai-sdk/ui-utils';\nimport { z, ZodType } from 'zod';\nimport { MCPClientError } from '../../../errors';\nimport { inferParameters, tool, Tool, ToolExecutionOptions } from '../tool';\nimport {\n  JSONRPCError,\n  JSONRPCNotification,\n  JSONRPCRequest,\n  JSONRPCResponse,\n} from './json-rpc-message';\nimport {\n  createMcpTransport,\n  isCustomMcpTransport,\n  MCPTransport,\n  MCPTransportConfig,\n} from './mcp-transport';\nimport {\n  CallToolResult,\n  CallToolResultSchema,\n  Configuration as ClientConfiguration,\n  InitializeResultSchema,\n  LATEST_PROTOCOL_VERSION,\n  ListToolsResult,\n  ListToolsResultSchema,\n  McpToolSet,\n  Notification,\n  PaginatedRequest,\n  Request,\n  RequestOptions,\n  ServerCapabilities,\n  SUPPORTED_PROTOCOL_VERSIONS,\n  ToolSchemas,\n} from './types';\n\nconst CLIENT_VERSION = '1.0.0';\n\ninterface MCPClientConfig {\n  /** Transport configuration for connecting to the MCP server */\n  transport: MCPTransportConfig | MCPTransport;\n  /** Optional callback for uncaught errors */\n  onUncaughtError?: (error: unknown) => void;\n  /** Optional client name, defaults to 'ai-sdk-mcp-client' */\n  name?: string;\n}\n\nexport async function createMCPClient(\n  config: MCPClientConfig,\n): Promise<MCPClient> {\n  const client = new MCPClient(config);\n  await client.init();\n  return client;\n}\n\n/**\n * A lightweight MCP Client implementation\n *\n * The primary purpose of this client is tool conversion between MCP<>AI SDK\n * but can later be extended to support other MCP features\n *\n * Tool parameters are automatically inferred from the server's JSON schema\n * if not explicitly provided in the tools configuration\n *\n * This client is meant to be used to communicate with a single server. To communicate and fetch tools across multiple servers, it's recommended to create a new client instance per server.\n *\n * Not supported:\n * - Client options (e.g. sampling, roots) as they are not needed for tool conversion\n * - Accepting notifications\n * - Session management (when passing a sessionId to an instance of the Streamable HTTP transport)\n * - Resumable SSE streams\n */\nclass MCPClient {\n  private transport: MCPTransport;\n  private onUncaughtError?: (error: unknown) => void;\n  private clientInfo: ClientConfiguration;\n  private requestMessageId = 0;\n  private responseHandlers: Map<\n    number,\n    (response: JSONRPCResponse | Error) => void\n  > = new Map();\n  private serverCapabilities: ServerCapabilities = {};\n  private isClosed = true;\n\n  constructor({\n    transport: transportConfig,\n    name = 'ai-sdk-mcp-client',\n    onUncaughtError,\n  }: MCPClientConfig) {\n    this.onUncaughtError = onUncaughtError;\n\n    if (isCustomMcpTransport(transportConfig)) {\n      this.transport = transportConfig;\n    } else {\n      this.transport = createMcpTransport(transportConfig);\n    }\n\n    this.transport.onclose = () => this.onClose();\n    this.transport.onerror = (error: Error) => this.onError(error);\n    this.transport.onmessage = message => {\n      if ('method' in message) {\n        // This lightweight client implementation does not support\n        // receiving notifications or requests from server.\n        // If we get an unsupported message, we can safely ignore it and pass to the onError handler:\n        this.onError(\n          new MCPClientError({\n            message: 'Unsupported message type',\n          }),\n        );\n        return;\n      }\n\n      this.onResponse(message);\n    };\n\n    this.clientInfo = {\n      name,\n      version: CLIENT_VERSION,\n    };\n  }\n\n  async init(): Promise<this> {\n    try {\n      await this.transport.start();\n      this.isClosed = false;\n\n      const result = await this.request({\n        request: {\n          method: 'initialize',\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            clientInfo: this.clientInfo,\n          },\n        },\n        resultSchema: InitializeResultSchema,\n      });\n\n      if (result === undefined) {\n        throw new MCPClientError({\n          message: 'Server sent invalid initialize result',\n        });\n      }\n\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new MCPClientError({\n          message: `Server's protocol version is not supported: ${result.protocolVersion}`,\n        });\n      }\n\n      this.serverCapabilities = result.capabilities;\n\n      // Complete initialization handshake:\n      await this.notification({\n        method: 'notifications/initialized',\n      });\n\n      return this;\n    } catch (error) {\n      await this.close();\n      throw error;\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) return;\n    await this.transport?.close();\n    this.onClose();\n  }\n\n  private assertCapability(method: string): void {\n    switch (method) {\n      case 'initialize':\n        break;\n      case 'tools/list':\n      case 'tools/call':\n        if (!this.serverCapabilities.tools) {\n          throw new MCPClientError({\n            message: `Server does not support tools`,\n          });\n        }\n        break;\n      default:\n        throw new MCPClientError({\n          message: `Unsupported method: ${method}`,\n        });\n    }\n  }\n\n  private async request<T extends ZodType<object>>({\n    request,\n    resultSchema,\n    options,\n  }: {\n    request: Request;\n    resultSchema: T;\n    options?: RequestOptions;\n  }): Promise<z.infer<T>> {\n    return new Promise((resolve, reject) => {\n      if (this.isClosed) {\n        return reject(\n          new MCPClientError({\n            message: 'Attempted to send a request from a closed client',\n          }),\n        );\n      }\n\n      this.assertCapability(request.method);\n\n      const signal = options?.signal;\n      signal?.throwIfAborted();\n\n      const messageId = this.requestMessageId++;\n      const jsonrpcRequest: JSONRPCRequest = {\n        ...request,\n        jsonrpc: '2.0',\n        id: messageId,\n      };\n\n      const cleanup = () => {\n        this.responseHandlers.delete(messageId);\n      };\n\n      this.responseHandlers.set(messageId, response => {\n        if (signal?.aborted) {\n          return reject(\n            new MCPClientError({\n              message: 'Request was aborted',\n              cause: signal.reason,\n            }),\n          );\n        }\n\n        if (response instanceof Error) {\n          return reject(response);\n        }\n\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          const parseError = new MCPClientError({\n            message: 'Failed to parse server response',\n            cause: error,\n          });\n          reject(parseError);\n        }\n      });\n\n      this.transport.send(jsonrpcRequest).catch(error => {\n        cleanup();\n        reject(error);\n      });\n    });\n  }\n\n  private async listTools({\n    params,\n    options,\n  }: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  } = {}): Promise<ListToolsResult> {\n    try {\n      return this.request({\n        request: { method: 'tools/list', params },\n        resultSchema: ListToolsResultSchema,\n        options,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async callTool({\n    name,\n    args,\n    options,\n  }: {\n    name: string;\n    args: Record<string, unknown>;\n    options?: ToolExecutionOptions;\n  }): Promise<CallToolResult> {\n    try {\n      return this.request({\n        request: { method: 'tools/call', params: { name, arguments: args } },\n        resultSchema: CallToolResultSchema,\n        options: {\n          signal: options?.abortSignal,\n        },\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async notification(notification: Notification): Promise<void> {\n    const jsonrpcNotification: JSONRPCNotification = {\n      ...notification,\n      jsonrpc: '2.0',\n    };\n    await this.transport.send(jsonrpcNotification);\n  }\n\n  /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */\n  async tools<TOOL_SCHEMAS extends ToolSchemas = 'automatic'>({\n    schemas = 'automatic',\n  }: {\n    schemas?: TOOL_SCHEMAS;\n  } = {}): Promise<McpToolSet<TOOL_SCHEMAS>> {\n    const tools: Record<string, Tool> = {};\n\n    try {\n      const listToolsResult = await this.listTools();\n\n      for (const { name, description, inputSchema } of listToolsResult.tools) {\n        if (schemas !== 'automatic' && !(name in schemas)) {\n          continue;\n        }\n\n        const parameters =\n          schemas === 'automatic'\n            ? jsonSchema({\n                ...inputSchema,\n                properties: inputSchema.properties ?? {},\n                additionalProperties: false,\n              } as JSONSchema7)\n            : schemas[name].parameters;\n\n        const self = this;\n        const toolWithExecute = tool({\n          description,\n          parameters,\n          execute: async (\n            args: inferParameters<typeof parameters>,\n            options: ToolExecutionOptions,\n          ): Promise<CallToolResult> => {\n            options?.abortSignal?.throwIfAborted();\n\n            return self.callTool({\n              name,\n              args,\n              options,\n            });\n          },\n        });\n\n        tools[name] = toolWithExecute;\n      }\n\n      return tools as McpToolSet<TOOL_SCHEMAS>;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private onClose(): void {\n    if (this.isClosed) return;\n\n    this.isClosed = true;\n    const error = new MCPClientError({\n      message: 'Connection closed',\n    });\n\n    for (const handler of this.responseHandlers.values()) {\n      handler(error);\n    }\n\n    this.responseHandlers.clear();\n  }\n\n  private onError(error: unknown): void {\n    if (this.onUncaughtError) {\n      this.onUncaughtError(error);\n    }\n  }\n\n  private onResponse(response: JSONRPCResponse | JSONRPCError): void {\n    const messageId = Number(response.id);\n    const handler = this.responseHandlers.get(messageId);\n\n    if (handler === undefined) {\n      throw new MCPClientError({\n        message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(\n          response,\n        )}`,\n      });\n    }\n\n    this.responseHandlers.delete(messageId);\n\n    handler(\n      'result' in response\n        ? response\n        : new MCPClientError({\n            message: response.error.message,\n            cause: response.error,\n          }),\n    );\n  }\n}\n", "import { Schema } from '@ai-sdk/ui-utils';\nimport { z } from 'zod';\nimport { ToolResultContent } from '../prompt/tool-result-content';\nimport { CoreMessage } from '../prompt/message';\n\nexport type ToolParameters = z.ZodTypeAny | Schema<any>;\n\nexport type inferParameters<PARAMETERS extends ToolParameters> =\n  PARAMETERS extends Schema<any>\n    ? PARAMETERS['_type']\n    : PARAMETERS extends z.ZodTypeAny\n      ? z.infer<PARAMETERS>\n      : never;\n\nexport interface ToolExecutionOptions {\n  /**\n   * The ID of the tool call. You can use it e.g. when sending tool-call related information with stream data.\n   */\n  toolCallId: string;\n\n  /**\n   * Messages that were sent to the language model to initiate the response that contained the tool call.\n   * The messages **do not** include the system prompt nor the assistant response that contained the tool call.\n   */\n  messages: CoreMessage[];\n\n  /**\n   * An optional abort signal that indicates that the overall operation should be aborted.\n   */\n  abortSignal?: AbortSignal;\n}\n\n/**\nA tool contains the description and the schema of the input that the tool expects.\nThis enables the language model to generate the input.\n\nThe tool can also contain an optional execute function for the actual execution function of the tool.\n */\nexport type Tool<PARAMETERS extends ToolParameters = any, RESULT = any> = {\n  /**\nThe schema of the input that the tool expects. The language model will use this to generate the input.\nIt is also used to validate the output of the language model.\nUse descriptions to make the input understandable for the language model.\n   */\n  parameters: PARAMETERS;\n\n  /**\nAn optional description of what the tool does.\nWill be used by the language model to decide whether to use the tool.\nNot used for provider-defined tools.\n   */\n  description?: string;\n\n  /**\nOptional conversion function that maps the tool result to multi-part tool content for LLMs.\n   */\n  experimental_toToolResultContent?: (result: RESULT) => ToolResultContent;\n\n  /**\nAn async function that is called with the arguments from the tool call and produces a result.\nIf not provided, the tool will not be executed automatically.\n\n@args is the input of the tool call.\n@options.abortSignal is a signal that can be used to abort the tool call.\n   */\n  execute?: (\n    args: inferParameters<PARAMETERS>,\n    options: ToolExecutionOptions,\n  ) => PromiseLike<RESULT>;\n} & (\n  | {\n      /**\nFunction tool.\n       */\n      type?: undefined | 'function';\n    }\n  | {\n      /**\nProvider-defined tool.\n       */\n      type: 'provider-defined';\n\n      /**\nThe ID of the tool. Should follow the format `<provider-name>.<tool-name>`.\n       */\n      id: `${string}.${string}`;\n\n      /**\nThe arguments for configuring the tool. Must match the expected arguments defined by the provider for this tool.\n       */\n      args: Record<string, unknown>;\n    }\n);\n\n/**\n * @deprecated Use `Tool` instead.\n */\n// TODO remove in v5\nexport type CoreTool<\n  PARAMETERS extends ToolParameters = any,\n  RESULT = any,\n> = Tool<PARAMETERS, RESULT>;\n\n/**\nHelper function for inferring the execute args of a tool.\n */\n// Note: special type inference is needed for the execute function args to make sure they are inferred correctly.\nexport function tool<PARAMETERS extends ToolParameters, RESULT>(\n  tool: Tool<PARAMETERS, RESULT> & {\n    execute: (\n      args: inferParameters<PARAMETERS>,\n      options: ToolExecutionOptions,\n    ) => PromiseLike<RESULT>;\n  },\n): Tool<PARAMETERS, RESULT> & {\n  execute: (\n    args: inferParameters<PARAMETERS>,\n    options: ToolExecutionOptions,\n  ) => PromiseLike<RESULT>;\n};\nexport function tool<PARAMETERS extends ToolParameters, RESULT>(\n  tool: Tool<PARAMETERS, RESULT> & {\n    execute?: undefined;\n  },\n): Tool<PARAMETERS, RESULT> & {\n  execute: undefined;\n};\nexport function tool<PARAMETERS extends ToolParameters, RESULT = any>(\n  tool: Tool<PARAMETERS, RESULT>,\n): Tool<PARAMETERS, RESULT> {\n  return tool;\n}\n", "import { createEventSourceParserStream } from '@ai-sdk/provider-utils';\nimport { MCPClientError } from '../../../errors';\nimport { JSONRPCMessage, JSONRPCMessageSchema } from './json-rpc-message';\nimport { MCPTransport } from './mcp-transport';\n\nexport class SseMCPTransport implements MCPTransport {\n  private endpoint?: URL;\n  private abortController?: AbortController;\n  private url: URL;\n  private connected = false;\n  private sseConnection?: {\n    close: () => void;\n  };\n  private headers?: Record<string, string>;\n\n  onclose?: () => void;\n  onerror?: (error: unknown) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor({\n    url,\n    headers,\n  }: {\n    url: string;\n    headers?: Record<string, string>;\n  }) {\n    this.url = new URL(url);\n    this.headers = headers;\n  }\n\n  async start(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (this.connected) {\n        return resolve();\n      }\n\n      this.abortController = new AbortController();\n\n      const establishConnection = async () => {\n        try {\n          const headers = new Headers(this.headers);\n          headers.set('Accept', 'text/event-stream');\n          const response = await fetch(this.url.href, {\n            headers,\n            signal: this.abortController?.signal,\n          });\n\n          if (!response.ok || !response.body) {\n            const error = new MCPClientError({\n              message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`,\n            });\n            this.onerror?.(error);\n            return reject(error);\n          }\n\n          const stream = response.body\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(createEventSourceParserStream());\n\n          const reader = stream.getReader();\n\n          const processEvents = async () => {\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n\n                if (done) {\n                  if (this.connected) {\n                    this.connected = false;\n                    throw new MCPClientError({\n                      message:\n                        'MCP SSE Transport Error: Connection closed unexpectedly',\n                    });\n                  }\n                  return;\n                }\n\n                const { event, data } = value;\n\n                if (event === 'endpoint') {\n                  this.endpoint = new URL(data, this.url);\n\n                  if (this.endpoint.origin !== this.url.origin) {\n                    throw new MCPClientError({\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`,\n                    });\n                  }\n\n                  this.connected = true;\n                  resolve();\n                } else if (event === 'message') {\n                  try {\n                    const message = JSONRPCMessageSchema.parse(\n                      JSON.parse(data),\n                    );\n                    this.onmessage?.(message);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message:\n                        'MCP SSE Transport Error: Failed to parse message',\n                      cause: error,\n                    });\n                    this.onerror?.(e);\n                    // We do not throw here so we continue processing events after reporting the error\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === 'AbortError') {\n                return;\n              }\n\n              this.onerror?.(error);\n              reject(error);\n            }\n          };\n\n          this.sseConnection = {\n            close: () => reader.cancel(),\n          };\n\n          processEvents();\n        } catch (error) {\n          if (error instanceof Error && error.name === 'AbortError') {\n            return;\n          }\n\n          this.onerror?.(error);\n          reject(error);\n        }\n      };\n\n      establishConnection();\n    });\n  }\n\n  async close(): Promise<void> {\n    this.connected = false;\n    this.sseConnection?.close();\n    this.abortController?.abort();\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    if (!this.endpoint || !this.connected) {\n      throw new MCPClientError({\n        message: 'MCP SSE Transport Error: Not connected',\n      });\n    }\n\n    try {\n      const headers = new Headers(this.headers);\n      headers.set('Content-Type', 'application/json');\n      const init = {\n        method: 'POST',\n        headers,\n        body: JSON.stringify(message),\n        signal: this.abortController?.signal,\n      };\n\n      const response = await fetch(this.endpoint, init);\n\n      if (!response.ok) {\n        const text = await response.text().catch(() => null);\n        const error = new MCPClientError({\n          message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text}`,\n        });\n        this.onerror?.(error);\n        return;\n      }\n    } catch (error) {\n      this.onerror?.(error);\n      return;\n    }\n  }\n}\n\nexport function deserializeMessage(line: string): JSONRPCMessage {\n  return JSONRPCMessageSchema.parse(JSON.parse(line));\n}\n", "import { z } from 'zod';\nimport { BaseParamsSchema, RequestSchema, ResultSchema } from './types';\n\nconst JSONRPC_VERSION = '2.0';\n\nconst JSONRPCRequestSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n  })\n  .merge(RequestSchema)\n  .strict();\n\nexport type JSONRPCRequest = z.infer<typeof JSONRPCRequestSchema>;\n\nconst JSONRPCResponseSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    result: ResultSchema,\n  })\n  .strict();\n\nexport type JSONRPCResponse = z.infer<typeof JSONRPCResponseSchema>;\n\nconst JSONRPCErrorSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    error: z.object({\n      code: z.number().int(),\n      message: z.string(),\n      data: z.optional(z.unknown()),\n    }),\n  })\n  .strict();\n\nexport type JSONRPCError = z.infer<typeof JSONRPCErrorSchema>;\n\nconst JSONRPCNotificationSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n  })\n  .merge(\n    z.object({\n      method: z.string(),\n      params: z.optional(BaseParamsSchema),\n    }),\n  )\n  .strict();\n\nexport type JSONRPCNotification = z.infer<typeof JSONRPCNotificationSchema>;\n\nexport const JSONRPCMessageSchema = z.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema,\n]);\n\nexport type JSONRPCMessage = z.infer<typeof JSONRPCMessageSchema>;\n", "import { z } from 'zod';\nimport {\n  inferParameters,\n  Tool,\n  ToolExecutionOptions,\n  ToolParameters,\n} from '../tool';\n\nexport const LATEST_PROTOCOL_VERSION = '2024-11-05';\nexport const SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  '2024-10-07',\n];\n\nexport type ToolSchemas =\n  | Record<string, { parameters: ToolParameters }>\n  | 'automatic'\n  | undefined;\n\nexport type McpToolSet<TOOL_SCHEMAS extends ToolSchemas = 'automatic'> =\n  TOOL_SCHEMAS extends Record<string, { parameters: ToolParameters }>\n    ? {\n        [K in keyof TOOL_SCHEMAS]: Tool<\n          TOOL_SCHEMAS[K]['parameters'],\n          CallToolResult\n        > & {\n          execute: (\n            args: inferParameters<TOOL_SCHEMAS[K]['parameters']>,\n            options: ToolExecutionOptions,\n          ) => PromiseLike<CallToolResult>;\n        };\n      }\n    : {\n        [k: string]: Tool<z.ZodUnknown, CallToolResult> & {\n          execute: (\n            args: unknown,\n            options: ToolExecutionOptions,\n          ) => PromiseLike<CallToolResult>;\n        };\n      };\n\nconst ClientOrServerImplementationSchema = z\n  .object({\n    name: z.string(),\n    version: z.string(),\n  })\n  .passthrough();\nexport type Configuration = z.infer<typeof ClientOrServerImplementationSchema>;\n\nexport const BaseParamsSchema = z\n  .object({\n    _meta: z.optional(z.object({}).passthrough()),\n  })\n  .passthrough();\ntype BaseParams = z.infer<typeof BaseParamsSchema>;\nexport const ResultSchema = BaseParamsSchema;\n\nexport const RequestSchema = z.object({\n  method: z.string(),\n  params: z.optional(BaseParamsSchema),\n});\nexport type Request = z.infer<typeof RequestSchema>;\nexport type RequestOptions = {\n  signal?: AbortSignal;\n  timeout?: number;\n  maxTotalTimeout?: number;\n};\n\nexport type Notification = z.infer<typeof RequestSchema>;\n\nconst ServerCapabilitiesSchema = z\n  .object({\n    experimental: z.optional(z.object({}).passthrough()),\n    logging: z.optional(z.object({}).passthrough()),\n    prompts: z.optional(\n      z\n        .object({\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    resources: z.optional(\n      z\n        .object({\n          subscribe: z.optional(z.boolean()),\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    tools: z.optional(\n      z\n        .object({\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n  })\n  .passthrough();\nexport type ServerCapabilities = z.infer<typeof ServerCapabilitiesSchema>;\n\nexport const InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: z.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: z.optional(z.string()),\n});\nexport type InitializeResult = z.infer<typeof InitializeResultSchema>;\n\nexport type PaginatedRequest = Request & {\n  params?: BaseParams & {\n    cursor?: string;\n  };\n};\n\nconst PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: z.optional(z.string()),\n});\n\nconst ToolSchema = z\n  .object({\n    name: z.string(),\n    description: z.optional(z.string()),\n    inputSchema: z\n      .object({\n        type: z.literal('object'),\n        properties: z.optional(z.object({}).passthrough()),\n      })\n      .passthrough(),\n  })\n  .passthrough();\nexport type MCPTool = z.infer<typeof ToolSchema>;\nexport const ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: z.array(ToolSchema),\n});\nexport type ListToolsResult = z.infer<typeof ListToolsResultSchema>;\n\nconst TextContentSchema = z\n  .object({\n    type: z.literal('text'),\n    text: z.string(),\n  })\n  .passthrough();\nconst ImageContentSchema = z\n  .object({\n    type: z.literal('image'),\n    data: z.string().base64(),\n    mimeType: z.string(),\n  })\n  .passthrough();\nconst ResourceContentsSchema = z\n  .object({\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n  })\n  .passthrough();\nconst TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: z.string(),\n});\nconst BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: z.string().base64(),\n});\nconst EmbeddedResourceSchema = z\n  .object({\n    type: z.literal('resource'),\n    resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  })\n  .passthrough();\n\nexport const CallToolResultSchema = ResultSchema.extend({\n  content: z.array(\n    z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema]),\n  ),\n  isError: z.boolean().default(false).optional(),\n}).or(\n  ResultSchema.extend({\n    toolResult: z.unknown(),\n  }),\n);\nexport type CallToolResult = z.infer<typeof CallToolResultSchema>;\n", "import { MCPClientError } from '../../../errors';\nimport { JSONRPCMessage } from './json-rpc-message';\nimport { SseMCPTransport } from './mcp-sse-transport';\n\n/**\n * Transport interface for MCP (Model Context Protocol) communication.\n * Maps to the `Transport` interface in the MCP spec.\n */\nexport interface MCPTransport {\n  /**\n   * Initialize and start the transport\n   */\n  start(): Promise<void>;\n\n  /**\n   * Send a JSON-RPC message through the transport\n   * @param message The JSON-RPC message to send\n   */\n  send(message: JSONRPCMessage): Promise<void>;\n\n  /**\n   * Clean up and close the transport\n   */\n  close(): Promise<void>;\n\n  /**\n   * Event handler for transport closure\n   */\n  onclose?: () => void;\n\n  /**\n   * Event handler for transport errors\n   */\n  onerror?: (error: Error) => void;\n\n  /**\n   * Event handler for received messages\n   */\n  onmessage?: (message: JSONRPCMessage) => void;\n}\n\nexport type MCPTransportConfig = {\n  type: 'sse';\n\n  /**\n   * The URL of the MCP server.\n   */\n  url: string;\n\n  /**\n   * Additional HTTP headers to be sent with requests.\n   */\n  headers?: Record<string, string>;\n};\n\nexport function createMcpTransport(config: MCPTransportConfig): MCPTransport {\n  if (config.type !== 'sse') {\n    throw new MCPClientError({\n      message:\n        'Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.',\n    });\n  }\n\n  return new SseMCPTransport(config);\n}\n\nexport function isCustomMcpTransport(\n  transport: MCPTransportConfig | MCPTransport,\n): transport is MCPTransport {\n  return (\n    'start' in transport &&\n    typeof transport.start === 'function' &&\n    'send' in transport &&\n    typeof transport.send === 'function' &&\n    'close' in transport &&\n    typeof transport.close === 'function'\n  );\n}\n", "import { InvalidArgumentError } from '../../errors/invalid-argument-error';\n\n/**\n * Calculates the cosine similarity between two vectors. This is a useful metric for\n * comparing the similarity of two vectors such as embeddings.\n *\n * @param vector1 - The first vector.\n * @param vector2 - The second vector.\n * @param options - Optional configuration.\n * @param options.throwErrorForEmptyVectors - If true, throws an error for empty vectors. Default: false.\n *\n * @returns The cosine similarity between vector1 and vector2.\n * @returns 0 if either vector is the zero vector.\n *\n * @throws {InvalidArgumentError} If throwErrorForEmptyVectors is true and vectors are empty.\n * @throws {InvalidArgumentError} If the vectors do not have the same length.\n */\nexport function cosineSimilarity(\n  vector1: number[],\n  vector2: number[],\n  // TODO remove throw option in 5.0\n  options?: {\n    /**\n     * @deprecated will be removed in 5.0\n     */\n    throwErrorForEmptyVectors?: boolean;\n  },\n): number {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: 'vector1,vector2',\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`,\n    });\n  }\n\n  const n = vector1.length;\n\n  if (n === 0) {\n    if (options?.throwErrorForEmptyVectors) {\n      throw new InvalidArgumentError({\n        parameter: 'vector1',\n        value: vector1,\n        message: 'Vectors cannot be empty',\n      });\n    }\n\n    return 0; // Return 0 for empty vectors if no error is thrown\n  }\n\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0\n    ? 0\n    : dotProduct /\n        (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n", "import { delay as delayFunction } from '@ai-sdk/provider-utils';\n\n/**\n * Creates a ReadableStream that emits the provided values with an optional delay between each value.\n *\n * @param options - The configuration options\n * @param options.chunks - Array of values to be emitted by the stream\n * @param options.initialDelayInMs - Optional initial delay in milliseconds before emitting the first value (default: 0). Can be set to `null` to skip the initial delay. The difference between `initialDelayInMs: null` and `initialDelayInMs: 0` is that `initialDelayInMs: null` will emit the values without any delay, while `initialDelayInMs: 0` will emit the values with a delay of 0 milliseconds.\n * @param options.chunkDelayInMs - Optional delay in milliseconds between emitting each value (default: 0). Can be set to `null` to skip the delay. The difference between `chunkDelayInMs: null` and `chunkDelayInMs: 0` is that `chunkDelayInMs: null` will emit the values without any delay, while `chunkDelayInMs: 0` will emit the values with a delay of 0 milliseconds.\n * @returns A ReadableStream that emits the provided values\n */\nexport function simulateReadableStream<T>({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal,\n}: {\n  chunks: T[];\n  initialDelayInMs?: number | null;\n  chunkDelayInMs?: number | null;\n  _internal?: {\n    delay?: (ms: number | null) => Promise<void>;\n  };\n}): ReadableStream<T> {\n  const delay = _internal?.delay ?? delayFunction;\n\n  let index = 0;\n\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    },\n  });\n}\n", "import {\n  AssistantMessage,\n  DataMessage,\n  formatAssistantStreamPart,\n} from '@ai-sdk/ui-utils';\n\n/**\nYou can pass the thread and the latest message into the `AssistantResponse`. This establishes the context for the response.\n */\ntype AssistantResponseSettings = {\n  /**\nThe thread ID that the response is associated with.\n   */\n  threadId: string;\n\n  /**\nThe ID of the latest message that the response is associated with.\n */\n  messageId: string;\n};\n\n/**\nThe process parameter is a callback in which you can run the assistant on threads, and send messages and data messages to the client.\n */\ntype AssistantResponseCallback = (options: {\n  /**\nForwards an assistant message (non-streaming) to the client.\n   */\n  sendMessage: (message: AssistantMessage) => void;\n\n  /**\nSend a data message to the client. You can use this to provide information for rendering custom UIs while the assistant is processing the thread.\n */\n  sendDataMessage: (message: DataMessage) => void;\n\n  /**\nForwards the assistant response stream to the client. Returns the `Run` object after it completes, or when it requires an action.\n   */\n  forwardStream: (stream: any) => Promise<any | undefined>;\n}) => Promise<void>;\n\n/**\nThe `AssistantResponse` allows you to send a stream of assistant update to `useAssistant`.\nIt is designed to facilitate streaming assistant responses to the `useAssistant` hook.\nIt receives an assistant thread and a current message, and can send messages and data messages to the client.\n */\nexport function AssistantResponse(\n  { threadId, messageId }: AssistantResponseSettings,\n  process: AssistantResponseCallback,\n): Response {\n  const stream = new ReadableStream({\n    async start(controller) {\n      const textEncoder = new TextEncoder();\n\n      const sendMessage = (message: AssistantMessage) => {\n        controller.enqueue(\n          textEncoder.encode(\n            formatAssistantStreamPart('assistant_message', message),\n          ),\n        );\n      };\n\n      const sendDataMessage = (message: DataMessage) => {\n        controller.enqueue(\n          textEncoder.encode(\n            formatAssistantStreamPart('data_message', message),\n          ),\n        );\n      };\n\n      const sendError = (errorMessage: string) => {\n        controller.enqueue(\n          textEncoder.encode(formatAssistantStreamPart('error', errorMessage)),\n        );\n      };\n\n      const forwardStream = async (stream: any) => {\n        let result: any | undefined = undefined;\n\n        for await (const value of stream) {\n          switch (value.event) {\n            case 'thread.message.created': {\n              controller.enqueue(\n                textEncoder.encode(\n                  formatAssistantStreamPart('assistant_message', {\n                    id: value.data.id,\n                    role: 'assistant',\n                    content: [{ type: 'text', text: { value: '' } }],\n                  }),\n                ),\n              );\n              break;\n            }\n\n            case 'thread.message.delta': {\n              const content = value.data.delta.content?.[0];\n\n              if (content?.type === 'text' && content.text?.value != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    formatAssistantStreamPart('text', content.text.value),\n                  ),\n                );\n              }\n\n              break;\n            }\n\n            case 'thread.run.completed':\n            case 'thread.run.requires_action': {\n              result = value.data;\n              break;\n            }\n          }\n        }\n\n        return result;\n      };\n\n      // send the threadId and messageId as the first message:\n      controller.enqueue(\n        textEncoder.encode(\n          formatAssistantStreamPart('assistant_control_data', {\n            threadId,\n            messageId,\n          }),\n        ),\n      );\n\n      try {\n        await process({\n          sendMessage,\n          sendDataMessage,\n          forwardStream,\n        });\n      } catch (error) {\n        sendError((error as any).message ?? `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {},\n    cancel() {},\n  });\n\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      'Content-Type': 'text/plain; charset=utf-8',\n    },\n  });\n}\n", "import { formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from '../core/data-stream/data-stream-writer';\nimport { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  createCallbacksTransformer,\n  StreamCallbacks,\n} from './stream-callbacks';\nimport { StreamData } from './stream-data';\n\ntype LangChainImageDetail = 'auto' | 'low' | 'high';\n\ntype LangChainMessageContentText = {\n  type: 'text';\n  text: string;\n};\n\ntype LangChainMessageContentImageUrl = {\n  type: 'image_url';\n  image_url:\n    | string\n    | {\n        url: string;\n        detail?: LangChainImageDetail;\n      };\n};\n\ntype LangChainMessageContentComplex =\n  | LangChainMessageContentText\n  | LangChainMessageContentImageUrl\n  | (Record<string, any> & {\n      type?: 'text' | 'image_url' | string;\n    })\n  | (Record<string, any> & {\n      type?: never;\n    });\n\ntype LangChainMessageContent = string | LangChainMessageContentComplex[];\n\ntype LangChainAIMessageChunk = {\n  content: LangChainMessageContent;\n};\n\n// LC stream event v2\ntype LangChainStreamEvent = {\n  event: string;\n  data: any;\n};\n\nfunction toDataStreamInternal(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: StreamCallbacks,\n) {\n  return stream\n    .pipeThrough(\n      new TransformStream<\n        LangChainStreamEvent | LangChainAIMessageChunk | string\n      >({\n        transform: async (value, controller) => {\n          // text stream:\n          if (typeof value === 'string') {\n            controller.enqueue(value);\n            return;\n          }\n\n          // LC stream events v2:\n          if ('event' in value) {\n            // chunk is AIMessage Chunk for on_chat_model_stream event:\n            if (value.event === 'on_chat_model_stream') {\n              forwardAIMessageChunk(\n                value.data?.chunk as LangChainAIMessageChunk,\n                controller,\n              );\n            }\n            return;\n          }\n\n          // AI Message chunk stream:\n          forwardAIMessageChunk(value, controller);\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          controller.enqueue(formatDataStreamPart('text', chunk));\n        },\n      }),\n    );\n}\n\n/**\nConverts LangChain output streams to an AI SDK Data Stream.\n\nThe following streams are supported:\n- `LangChainAIMessageChunk` streams (LangChain `model.stream` output)\n- `string` streams (LangChain `StringOutputParser` output)\n */\nexport function toDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  callbacks?: StreamCallbacks,\n) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n}\n\nexport function toDataStreamResponse(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options?: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: StreamCallbacks;\n  },\n) {\n  const dataStream = toDataStreamInternal(\n    stream,\n    options?.callbacks,\n  ).pipeThrough(new TextEncoderStream());\n  const data = options?.data;\n  const init = options?.init;\n\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init?.headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nexport function mergeIntoDataStream(\n  stream:\n    | ReadableStream<LangChainStreamEvent>\n    | ReadableStream<LangChainAIMessageChunk>\n    | ReadableStream<string>,\n  options: { dataStream: DataStreamWriter; callbacks?: StreamCallbacks },\n) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\n\nfunction forwardAIMessageChunk(\n  chunk: LangChainAIMessageChunk,\n  controller: TransformStreamDefaultController<any>,\n) {\n  if (typeof chunk.content === 'string') {\n    controller.enqueue(chunk.content);\n  } else {\n    const content: LangChainMessageContentComplex[] = chunk.content;\n    for (const item of content) {\n      if (item.type === 'text') {\n        controller.enqueue(item.text);\n      }\n    }\n  }\n}\n", "/**\n * Configuration options and helper callback methods for stream lifecycle events.\n */\nexport interface StreamCallbacks {\n  /** `onStart`: Called once when the stream is initialized. */\n  onStart?: () => Promise<void> | void;\n\n  /**\n   * `onCompletion`: Called for each tokenized message.\n   *\n   * @deprecated Use `onFinal` instead.\n   */\n  onCompletion?: (completion: string) => Promise<void> | void;\n\n  /** `onFinal`: Called once when the stream is closed with the final completion message. */\n  onFinal?: (completion: string) => Promise<void> | void;\n\n  /** `onToken`: Called for each tokenized message. */\n  onToken?: (token: string) => Promise<void> | void;\n\n  /** `onText`: Called for each text chunk. */\n  onText?: (text: string) => Promise<void> | void;\n}\n\n/**\n * Creates a transform stream that encodes input messages and invokes optional callback functions.\n * The transform stream uses the provided callbacks to execute custom logic at different stages of the stream's lifecycle.\n * - `onStart`: Called once when the stream is initialized.\n * - `onToken`: Called for each tokenized message.\n * - `onCompletion`: Called every time a completion message is received. This can occur multiple times when using e.g. OpenAI functions\n * - `onFinal`: Called once when the stream is closed with the final completion message.\n *\n * This function is useful when you want to process a stream of messages and perform specific actions during the stream's lifecycle.\n *\n * @param {StreamCallbacks} [callbacks] - An object containing the callback functions.\n * @return {TransformStream<string, Uint8Array>} A transform stream that encodes input messages as Uint8Array and allows the execution of custom logic through callbacks.\n *\n * @example\n * const callbacks = {\n *   onStart: async () => console.log('Stream started'),\n *   onToken: async (token) => console.log(`Token: ${token}`),\n *   onCompletion: async (completion) => console.log(`Completion: ${completion}`)\n *   onFinal: async () => data.close()\n * };\n * const transformer = createCallbacksTransformer(callbacks);\n */\nexport function createCallbacksTransformer(\n  callbacks: StreamCallbacks | undefined = {},\n): TransformStream<string, Uint8Array> {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = '';\n\n  return new TransformStream({\n    async start(): Promise<void> {\n      if (callbacks.onStart) await callbacks.onStart();\n    },\n\n    async transform(message, controller): Promise<void> {\n      controller.enqueue(textEncoder.encode(message));\n\n      aggregatedResponse += message;\n\n      if (callbacks.onToken) await callbacks.onToken(message);\n      if (callbacks.onText && typeof message === 'string') {\n        await callbacks.onText(message);\n      }\n    },\n\n    async flush(): Promise<void> {\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    },\n  });\n}\n", "import { convertAsyncIteratorToReadableStream } from '@ai-sdk/provider-utils';\nimport { formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { DataStreamWriter } from '../core/data-stream/data-stream-writer';\nimport { mergeStreams } from '../core/util/merge-streams';\nimport { prepareResponseHeaders } from '../core/util/prepare-response-headers';\nimport {\n  createCallbacksTransformer,\n  StreamCallbacks,\n} from './stream-callbacks';\nimport { StreamData } from './stream-data';\n\ntype EngineResponse = {\n  delta: string;\n};\n\nfunction toDataStreamInternal(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: StreamCallbacks,\n) {\n  const trimStart = trimStartOfStream();\n\n  return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]())\n    .pipeThrough(\n      new TransformStream({\n        async transform(message, controller): Promise<void> {\n          controller.enqueue(trimStart(message.delta));\n        },\n      }),\n    )\n    .pipeThrough(createCallbacksTransformer(callbacks))\n    .pipeThrough(new TextDecoderStream())\n    .pipeThrough(\n      new TransformStream({\n        transform: async (chunk, controller) => {\n          controller.enqueue(formatDataStreamPart('text', chunk));\n        },\n      }),\n    );\n}\n\nexport function toDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  callbacks?: StreamCallbacks,\n) {\n  return toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n}\n\nexport function toDataStreamResponse(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    init?: ResponseInit;\n    data?: StreamData;\n    callbacks?: StreamCallbacks;\n  } = {},\n) {\n  const { init, data, callbacks } = options;\n  const dataStream = toDataStreamInternal(stream, callbacks).pipeThrough(\n    new TextEncoderStream(),\n  );\n  const responseStream = data\n    ? mergeStreams(data.stream, dataStream)\n    : dataStream;\n\n  return new Response(responseStream, {\n    status: init?.status ?? 200,\n    statusText: init?.statusText,\n    headers: prepareResponseHeaders(init?.headers, {\n      contentType: 'text/plain; charset=utf-8',\n      dataStreamVersion: 'v1',\n    }),\n  });\n}\n\nexport function mergeIntoDataStream(\n  stream: AsyncIterable<EngineResponse>,\n  options: {\n    dataStream: DataStreamWriter;\n    callbacks?: StreamCallbacks;\n  },\n) {\n  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));\n}\n\nfunction trimStartOfStream(): (text: string) => string {\n  let isStreamStart = true;\n\n  return (text: string): string => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text) isStreamStart = false;\n    }\n    return text;\n  };\n}\n", "import { JSONValue, formatDataStreamPart } from '@ai-sdk/ui-utils';\nimport { HANGING_STREAM_WARNING_TIME_MS } from '../util/constants';\n\n/**\n * A stream wrapper to send custom JSON-encoded data back to the client.\n *\n * @deprecated Please use `createDataStream`, `createDataStreamResponse`, and `pipeDataStreamToResponse` instead.\n */\nexport class StreamData {\n  private encoder = new TextEncoder();\n\n  private controller: ReadableStreamController<Uint8Array> | null = null;\n  public stream: ReadableStream<Uint8Array>;\n\n  private isClosed: boolean = false;\n  private warningTimeout: NodeJS.Timeout | null = null;\n\n  constructor() {\n    const self = this;\n\n    this.stream = new ReadableStream({\n      start: async controller => {\n        self.controller = controller;\n\n        // Set a timeout to show a warning if the stream is not closed within 3 seconds\n        if (process.env.NODE_ENV === 'development') {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              'The data stream is hanging. Did you forget to close it with `data.close()`?',\n            );\n          }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n      },\n      pull: controller => {\n        // No-op: we don't need to do anything special on pull\n      },\n      cancel: reason => {\n        this.isClosed = true;\n      },\n    });\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.close();\n    this.isClosed = true;\n\n    // Clear the warning timeout if the stream is closed\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n\n  append(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatDataStreamPart('data', [value])),\n    );\n  }\n\n  appendMessageAnnotation(value: JSONValue): void {\n    if (this.isClosed) {\n      throw new Error('Data Stream has already been closed.');\n    }\n\n    if (!this.controller) {\n      throw new Error('Stream controller is not initialized.');\n    }\n\n    this.controller.enqueue(\n      this.encoder.encode(formatDataStreamPart('message_annotations', [value])),\n    );\n  }\n}\n", "/**\n * Warning time for notifying developers that a stream is hanging in dev mode\n * using a console.warn.\n */\nexport const HANGING_STREAM_WARNING_TIME_MS = 15 * 1000;\n", "/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n", "export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "import {\n  SSEClientTransport,\n  type SSEClientTransportOptions,\n} from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\n\nexport class SSEEdgeClientTransport extends SSEClientTransport {\n  private authProvider: OAuthClientProvider | undefined;\n  /**\n   * Creates a new EdgeSSEClientTransport, which overrides fetch to be compatible with the CF workers environment\n   */\n  constructor(url: URL, options: SSEClientTransportOptions) {\n    const fetchOverride: typeof fetch = async (\n      fetchUrl: RequestInfo | URL,\n      fetchInit: RequestInit = {}\n    ) => {\n      // add auth headers\n      const headers = await this.authHeaders();\n      const workerOptions = {\n        ...fetchInit,\n        headers: {\n          ...options.requestInit?.headers,\n          ...fetchInit?.headers,\n          ...headers,\n        },\n      };\n\n      // Remove unsupported properties\n      // biome-ignore lint/performance/noDelete: workaround for workers environment\n      delete workerOptions.mode;\n\n      // Call the original fetch with fixed options\n      return (\n        (options.eventSourceInit?.fetch?.(\n          fetchUrl as URL | string,\n          // @ts-expect-error Expects FetchLikeInit from EventSource but is compatible with RequestInit\n          workerOptions\n        ) as Promise<Response>) || fetch(fetchUrl, workerOptions)\n      );\n    };\n\n    super(url, {\n      ...options,\n      eventSourceInit: {\n        ...options.eventSourceInit,\n        fetch: fetchOverride,\n      },\n    });\n    this.authProvider = options.authProvider;\n  }\n\n  async authHeaders() {\n    if (this.authProvider) {\n      const tokens = await this.authProvider.tokens();\n      if (tokens) {\n        return {\n          Authorization: `Bearer ${tokens.access_token}`,\n        };\n      }\n    }\n  }\n}\n", "import { SSEEdgeClientTransport } from \"./sse-edge\";\n\nimport {\n  ToolListChangedNotificationSchema,\n  type ClientCapabilities,\n  type Resource,\n  type Tool,\n  type Prompt,\n  ResourceListChangedNotificationSchema,\n  PromptListChangedNotificationSchema,\n  type ListToolsResult,\n  type ListResourcesResult,\n  type ListPromptsResult,\n  type ServerCapabilities,\n  type ResourceTemplate,\n  type ListResourceTemplatesResult,\n  type Notification,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { AgentsOAuthProvider } from \"./do-oauth-client-provider\";\n\nexport class MCPClientConnection {\n  client: Client;\n  connectionState:\n    | \"authenticating\"\n    | \"connecting\"\n    | \"ready\"\n    | \"discovering\"\n    | \"failed\" = \"connecting\";\n  instructions?: string;\n  tools: Tool[] = [];\n  prompts: Prompt[] = [];\n  resources: Resource[] = [];\n  resourceTemplates: ResourceTemplate[] = [];\n  serverCapabilities: ServerCapabilities | undefined;\n\n  constructor(\n    public url: URL,\n    info: ConstructorParameters<typeof Client>[0],\n    public options: {\n      transport: SSEClientTransportOptions & {\n        authProvider?: AgentsOAuthProvider;\n      };\n      client: ConstructorParameters<typeof Client>[1];\n    } = { transport: {}, client: {} }\n  ) {\n    this.client = new Client(info, options.client);\n  }\n\n  /**\n   * Initialize a client connection\n   *\n   * @param code Optional OAuth code to initialize the connection with if auth hasn't been initialized\n   * @returns\n   */\n  async init(code?: string) {\n    try {\n      const transport = new SSEEdgeClientTransport(\n        this.url,\n        this.options.transport\n      );\n\n      if (code) {\n        await transport.finishAuth(code);\n      }\n\n      await this.client.connect(transport);\n      // biome-ignore lint/suspicious/noExplicitAny: allow for the error check here\n    } catch (e: any) {\n      if (e.toString().includes(\"Unauthorized\")) {\n        // unauthorized, we should wait for the user to authenticate\n        this.connectionState = \"authenticating\";\n        return;\n      }\n      this.connectionState = \"failed\";\n      throw e;\n    }\n\n    this.connectionState = \"discovering\";\n\n    this.serverCapabilities = await this.client.getServerCapabilities();\n    if (!this.serverCapabilities) {\n      throw new Error(\"The MCP Server failed to return server capabilities\");\n    }\n\n    const [instructions, tools, resources, prompts, resourceTemplates] =\n      await Promise.all([\n        this.client.getInstructions(),\n        this.registerTools(),\n        this.registerResources(),\n        this.registerPrompts(),\n        this.registerResourceTemplates(),\n      ]);\n\n    this.instructions = instructions;\n    this.tools = tools;\n    this.resources = resources;\n    this.prompts = prompts;\n    this.resourceTemplates = resourceTemplates;\n\n    this.connectionState = \"ready\";\n  }\n\n  /**\n   * Notification handler registration\n   */\n  async registerTools(): Promise<Tool[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.tools) {\n      return [];\n    }\n\n    if (this.serverCapabilities.tools.listChanged) {\n      this.client.setNotificationHandler(\n        ToolListChangedNotificationSchema,\n        async (_notification) => {\n          this.tools = await this.fetchTools();\n        }\n      );\n    }\n\n    return this.fetchTools();\n  }\n\n  async registerResources(): Promise<Resource[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.resources) {\n      return [];\n    }\n\n    if (this.serverCapabilities.resources.listChanged) {\n      this.client.setNotificationHandler(\n        ResourceListChangedNotificationSchema,\n        async (_notification) => {\n          this.resources = await this.fetchResources();\n        }\n      );\n    }\n\n    return this.fetchResources();\n  }\n\n  async registerPrompts(): Promise<Prompt[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.prompts) {\n      return [];\n    }\n\n    if (this.serverCapabilities.prompts.listChanged) {\n      this.client.setNotificationHandler(\n        PromptListChangedNotificationSchema,\n        async (_notification) => {\n          this.prompts = await this.fetchPrompts();\n        }\n      );\n    }\n\n    return this.fetchPrompts();\n  }\n\n  async registerResourceTemplates(): Promise<ResourceTemplate[]> {\n    if (!this.serverCapabilities || !this.serverCapabilities.resources) {\n      return [];\n    }\n\n    return this.fetchResourceTemplates();\n  }\n\n  async fetchTools() {\n    let toolsAgg: Tool[] = [];\n    let toolsResult: ListToolsResult = { tools: [] };\n    do {\n      toolsResult = await this.client\n        .listTools({\n          cursor: toolsResult.nextCursor,\n        })\n        .catch(capabilityErrorHandler({ tools: [] }, \"tools/list\"));\n      toolsAgg = toolsAgg.concat(toolsResult.tools);\n    } while (toolsResult.nextCursor);\n    return toolsAgg;\n  }\n\n  async fetchResources() {\n    let resourcesAgg: Resource[] = [];\n    let resourcesResult: ListResourcesResult = { resources: [] };\n    do {\n      resourcesResult = await this.client\n        .listResources({\n          cursor: resourcesResult.nextCursor,\n        })\n        .catch(capabilityErrorHandler({ resources: [] }, \"resources/list\"));\n      resourcesAgg = resourcesAgg.concat(resourcesResult.resources);\n    } while (resourcesResult.nextCursor);\n    return resourcesAgg;\n  }\n\n  async fetchPrompts() {\n    let promptsAgg: Prompt[] = [];\n    let promptsResult: ListPromptsResult = { prompts: [] };\n    do {\n      promptsResult = await this.client\n        .listPrompts({\n          cursor: promptsResult.nextCursor,\n        })\n        .catch(capabilityErrorHandler({ prompts: [] }, \"prompts/list\"));\n      promptsAgg = promptsAgg.concat(promptsResult.prompts);\n    } while (promptsResult.nextCursor);\n    return promptsAgg;\n  }\n\n  async fetchResourceTemplates() {\n    let templatesAgg: ResourceTemplate[] = [];\n    let templatesResult: ListResourceTemplatesResult = {\n      resourceTemplates: [],\n    };\n    do {\n      templatesResult = await this.client\n        .listResourceTemplates({\n          cursor: templatesResult.nextCursor,\n        })\n        .catch(\n          capabilityErrorHandler(\n            { resourceTemplates: [] },\n            \"resources/templates/list\"\n          )\n        );\n      templatesAgg = templatesAgg.concat(templatesResult.resourceTemplates);\n    } while (templatesResult.nextCursor);\n    return templatesAgg;\n  }\n}\n\nfunction capabilityErrorHandler<T>(empty: T, method: string) {\n  return (e: { code: number }) => {\n    // server is badly behaved and returning invalid capabilities. This commonly occurs for resource templates\n    if (e.code === -32601) {\n      console.error(\n        `The server advertised support for the capability ${method.split(\"/\")[0]}, but returned \"Method not found\" for '${method}'.`\n      );\n      return empty;\n    }\n    throw e;\n  };\n}\n", "import { MCPClientConnection } from \"./client-connection\";\n\nimport type {\n  CallToolRequest,\n  CallToolResultSchema,\n  CompatibilityCallToolResultSchema,\n  ReadResourceRequest,\n  GetPromptRequest,\n  Tool,\n  Resource,\n  Prompt,\n  ResourceTemplate,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { RequestOptions } from \"@modelcontextprotocol/sdk/shared/protocol.js\";\nimport type { AgentsOAuthProvider } from \"./do-oauth-client-provider\";\nimport { jsonSchema, type ToolSet } from \"ai\";\nimport { nanoid } from \"nanoid\";\n\n/**\n * Utility class that aggregates multiple MCP clients into one\n */\nexport class MCPClientManager {\n  public mcpConnections: Record<string, MCPClientConnection> = {};\n  private callbackUrls: string[] = [];\n\n  /**\n   * @param name Name of the MCP client\n   * @param version Version of the MCP Client\n   * @param auth Auth paramters if being used to create a DurableObjectOAuthClientProvider\n   */\n  constructor(\n    private name: string,\n    private version: string\n  ) {}\n\n  /**\n   * Connect to and register an MCP server\n   *\n   * @param transportConfig Transport config\n   * @param clientConfig Client config\n   * @param capabilities Client capabilities (i.e. if the client supports roots/sampling)\n   */\n  async connect(\n    url: string,\n    options: {\n      // Allows you to reconnect to a server (in the case of a auth reconnect)\n      reconnect?: {\n        id: string;\n        oauthClientId?: string;\n        oauthCode?: string;\n      };\n      // we're overriding authProvider here because we want to be able to access the auth URL\n      transport?: SSEClientTransportOptions & {\n        authProvider?: AgentsOAuthProvider;\n      };\n      client?: ConstructorParameters<typeof Client>[1];\n    } = {}\n  ): Promise<{\n    id: string;\n    authUrl?: string;\n    clientId?: string;\n  }> {\n    const id = options.reconnect?.id ?? nanoid(8);\n\n    if (!options.transport?.authProvider) {\n      console.warn(\n        \"No authProvider provided in the transport options. This client will only support unauthenticated remote MCP Servers\"\n      );\n    } else {\n      // reconnect with auth\n      options.transport.authProvider.serverId = id;\n      if (options.reconnect?.oauthClientId) {\n        options.transport.authProvider.clientId =\n          options.reconnect?.oauthClientId;\n      }\n    }\n\n    this.mcpConnections[id] = new MCPClientConnection(\n      new URL(url),\n      {\n        name: this.name,\n        version: this.version,\n      },\n      {\n        transport: options.transport ?? {},\n        client: options.client ?? {},\n      }\n    );\n\n    await this.mcpConnections[id].init(options.reconnect?.oauthCode);\n\n    const authUrl = options.transport?.authProvider?.authUrl;\n    if (authUrl && options.transport?.authProvider?.redirectUrl) {\n      this.callbackUrls.push(\n        options.transport.authProvider.redirectUrl.toString()\n      );\n      return {\n        id,\n        authUrl,\n        clientId: options.transport?.authProvider?.clientId,\n      };\n    }\n\n    return {\n      id,\n    };\n  }\n\n  isCallbackRequest(req: Request): boolean {\n    return (\n      req.method === \"GET\" &&\n      !!this.callbackUrls.find((url) => {\n        return req.url.startsWith(url);\n      })\n    );\n  }\n\n  async handleCallbackRequest(req: Request) {\n    const url = new URL(req.url);\n    const urlMatch = this.callbackUrls.find((url) => {\n      return req.url.startsWith(url);\n    });\n    if (!urlMatch) {\n      throw new Error(\n        `No callback URI match found for the request url: ${req.url}. Was the request matched with \\`isCallbackRequest()\\`?`\n      );\n    }\n    const code = url.searchParams.get(\"code\");\n    const clientId = url.searchParams.get(\"state\");\n    const urlParams = urlMatch.split(\"/\");\n    const serverId = urlParams[urlParams.length - 1];\n    if (!code) {\n      throw new Error(\"Unauthorized: no code provided\");\n    }\n    if (!clientId) {\n      throw new Error(\"Unauthorized: no state provided\");\n    }\n\n    if (this.mcpConnections[serverId] === undefined) {\n      throw new Error(`Could not find serverId: ${serverId}`);\n    }\n\n    if (this.mcpConnections[serverId].connectionState !== \"authenticating\") {\n      throw new Error(\n        \"Failed to authenticate: the client isn't in the `authenticating` state\"\n      );\n    }\n\n    const conn = this.mcpConnections[serverId];\n    if (!conn.options.transport.authProvider) {\n      throw new Error(\n        \"Trying to finalize authentication for a server connection without an authProvider\"\n      );\n    }\n\n    conn.options.transport.authProvider.clientId = clientId;\n    conn.options.transport.authProvider.serverId = serverId;\n\n    // reconnect to server with authorization\n    const serverUrl = conn.url.toString();\n    await this.connect(serverUrl, {\n      reconnect: {\n        id: serverId,\n        oauthClientId: clientId,\n        oauthCode: code,\n      },\n      ...conn.options,\n    });\n\n    if (this.mcpConnections[serverId].connectionState === \"authenticating\") {\n      throw new Error(\"Failed to authenticate: client failed to initialize\");\n    }\n\n    return { serverId };\n  }\n\n  /**\n   * @returns namespaced list of tools\n   */\n  listTools(): NamespacedData[\"tools\"] {\n    return getNamespacedData(this.mcpConnections, \"tools\");\n  }\n\n  /**\n   * @returns a set of tools that you can use with the AI SDK\n   */\n  unstable_getAITools(): ToolSet {\n    return Object.fromEntries(\n      getNamespacedData(this.mcpConnections, \"tools\").map((tool) => {\n        return [\n          `${tool.serverId}_${tool.name}`,\n          {\n            parameters: jsonSchema(tool.inputSchema),\n            description: tool.description,\n            execute: async (args) => {\n              const result = await this.callTool({\n                name: tool.name,\n                arguments: args,\n                serverId: tool.serverId,\n              });\n              if (result.isError) {\n                // @ts-expect-error TODO we should fix this\n                throw new Error(result.content[0].text);\n              }\n              return result;\n            },\n          },\n        ];\n      })\n    );\n  }\n\n  /**\n   * Closes all connections to MCP servers\n   */\n  async closeAllConnections() {\n    return Promise.all(\n      Object.values(this.mcpConnections).map(async (connection) => {\n        await connection.client.close();\n      })\n    );\n  }\n\n  /**\n   * Closes a connection to an MCP server\n   * @param id The id of the connection to close\n   */\n  async closeConnection(id: string) {\n    if (!this.mcpConnections[id]) {\n      throw new Error(`Connection with id \"${id}\" does not exist.`);\n    }\n    await this.mcpConnections[id].client.close();\n  }\n\n  /**\n   * @returns namespaced list of prompts\n   */\n  listPrompts(): NamespacedData[\"prompts\"] {\n    return getNamespacedData(this.mcpConnections, \"prompts\");\n  }\n\n  /**\n   * @returns namespaced list of tools\n   */\n  listResources(): NamespacedData[\"resources\"] {\n    return getNamespacedData(this.mcpConnections, \"resources\");\n  }\n\n  /**\n   * @returns namespaced list of resource templates\n   */\n  listResourceTemplates(): NamespacedData[\"resourceTemplates\"] {\n    return getNamespacedData(this.mcpConnections, \"resourceTemplates\");\n  }\n\n  /**\n   * Namespaced version of callTool\n   */\n  callTool(\n    params: CallToolRequest[\"params\"] & { serverId: string },\n    resultSchema?:\n      | typeof CallToolResultSchema\n      | typeof CompatibilityCallToolResultSchema,\n    options?: RequestOptions\n  ) {\n    const unqualifiedName = params.name.replace(`${params.serverId}.`, \"\");\n    return this.mcpConnections[params.serverId].client.callTool(\n      {\n        ...params,\n        name: unqualifiedName,\n      },\n      resultSchema,\n      options\n    );\n  }\n\n  /**\n   * Namespaced version of readResource\n   */\n  readResource(\n    params: ReadResourceRequest[\"params\"] & { serverId: string },\n    options: RequestOptions\n  ) {\n    return this.mcpConnections[params.serverId].client.readResource(\n      params,\n      options\n    );\n  }\n\n  /**\n   * Namespaced version of getPrompt\n   */\n  getPrompt(\n    params: GetPromptRequest[\"params\"] & { serverId: string },\n    options: RequestOptions\n  ) {\n    return this.mcpConnections[params.serverId].client.getPrompt(\n      params,\n      options\n    );\n  }\n}\n\ntype NamespacedData = {\n  tools: (Tool & { serverId: string })[];\n  prompts: (Prompt & { serverId: string })[];\n  resources: (Resource & { serverId: string })[];\n  resourceTemplates: (ResourceTemplate & { serverId: string })[];\n};\n\nexport function getNamespacedData<T extends keyof NamespacedData>(\n  mcpClients: Record<string, MCPClientConnection>,\n  type: T\n): NamespacedData[T] {\n  const sets = Object.entries(mcpClients).map(([name, conn]) => {\n    return { name, data: conn[type] };\n  });\n\n  const namespacedData = sets.flatMap(({ name: serverId, data }) => {\n    return data.map((item) => {\n      return {\n        ...item,\n        // we add a serverId so we can easily pull it out and send the tool call to the right server\n        serverId,\n      };\n    });\n  });\n\n  return namespacedData as NamespacedData[T]; // Type assertion needed due to TS limitations with conditional return types\n}\n", "// rethink error handling, how to pass it on to the client\n// rethink oBC/oBR\n// push for durable.setState (in addition to connection.setState)\n\nimport { DurableObject } from \"cloudflare:workers\";\nimport { nanoid } from \"nanoid\";\n\nimport {\n  createLazyConnection,\n  HibernatingConnectionManager,\n  InMemoryConnectionManager\n} from \"./connection\";\n\nimport type { ConnectionManager } from \"./connection\";\nimport type {\n  Connection,\n  ConnectionContext,\n  ConnectionSetStateFn,\n  ConnectionState\n} from \"./types\";\n\nexport * from \"./types\";\n\nexport type WSMessage = ArrayBuffer | ArrayBufferView | string;\n\n// Let's cache the server namespace map\n// so we don't call it on every request\nconst serverMapCache = new WeakMap<\n  Record<string, unknown>,\n  Record<string, DurableObjectNamespace>\n>();\n\n/**\n * For a given server namespace, create a server with a name.\n */\nexport async function getServerByName<Env, T extends Server<Env>>(\n  serverNamespace: DurableObjectNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n  }\n): Promise<DurableObjectStub<T>> {\n  if (options?.jurisdiction) {\n    serverNamespace = serverNamespace.jurisdiction(options.jurisdiction);\n  }\n\n  const id = serverNamespace.idFromName(name);\n  const stub = serverNamespace.get(id, options);\n\n  // TODO: fix this to use RPC\n\n  const req = new Request(\n    \"http://dummy-example.cloudflare.com/cdn-cgi/partyserver/set-name/\"\n  );\n\n  req.headers.set(\"x-partykit-room\", name);\n\n  // unfortunately we have to await this\n  await stub.fetch(req).catch((e) => {\n    console.error(\"Could not set server name:\", e);\n  });\n\n  return stub;\n}\n\nfunction camelCaseToKebabCase(str: string): string {\n  // If string is all uppercase, convert to lowercase\n  if (str === str.toUpperCase() && str !== str.toLowerCase()) {\n    return str.toLowerCase().replace(/_/g, \"-\");\n  }\n\n  // Otherwise handle camelCase to kebab-case\n  let kebabified = str.replace(\n    /[A-Z]/g,\n    (letter) => `-${letter.toLowerCase()}`\n  );\n  kebabified = kebabified.startsWith(\"-\") ? kebabified.slice(1) : kebabified;\n  // Convert any remaining underscores to hyphens and remove trailing -'s\n  return kebabified.replace(/_/g, \"-\").replace(/-$/, \"\");\n}\nexport interface PartyServerOptions<Env> {\n  prefix?: string;\n  jurisdiction?: DurableObjectJurisdiction;\n  locationHint?: DurableObjectLocationHint;\n  onBeforeConnect?: (\n    req: Request,\n    lobby: {\n      party: keyof Env;\n      name: string;\n    }\n  ) => Response | Request | void | Promise<Response | Request | void>;\n  onBeforeRequest?: (\n    req: Request,\n    lobby: {\n      party: keyof Env;\n      name: string;\n    }\n  ) =>\n    | Response\n    | Request\n    | void\n    | Promise<Response | Request | undefined | void>;\n}\n/**\n * A utility function for PartyKit style routing.\n */\nexport async function routePartykitRequest<\n  Env = unknown,\n  T extends Server<Env> = Server<Env>\n>(\n  req: Request,\n  env: Record<string, unknown>,\n  options?: PartyServerOptions<typeof env>\n): Promise<Response | null> {\n  if (!serverMapCache.has(env)) {\n    serverMapCache.set(\n      env,\n      Object.entries(env).reduce((acc, [k, v]) => {\n        if (\n          v &&\n          typeof v === \"object\" &&\n          \"idFromName\" in v &&\n          typeof v.idFromName === \"function\"\n        ) {\n          Object.assign(acc, { [camelCaseToKebabCase(k)]: v });\n          return acc;\n        }\n        return acc;\n      }, {})\n    );\n  }\n  const map = serverMapCache.get(env) as unknown as Record<\n    string,\n    DurableObjectNamespace<T>\n  >;\n\n  const prefix = options?.prefix || \"parties\";\n  const prefixParts = prefix.split(\"/\");\n\n  const url = new URL(req.url);\n  const parts = url.pathname.split(\"/\").filter(Boolean); // Remove empty strings\n\n  // Check if the URL starts with the prefix\n  const prefixMatches = prefixParts.every(\n    (part, index) => parts[index] === part\n  );\n  if (!prefixMatches || parts.length < prefixParts.length + 2) {\n    return null;\n  }\n\n  const namespace = parts[prefixParts.length];\n  const name = parts[prefixParts.length + 1];\n\n  if (name && namespace) {\n    if (!map[namespace]) {\n      if (namespace === \"main\") {\n        console.warn(\n          \"You appear to be migrating a PartyKit project to PartyServer.\"\n        );\n        console.warn(`PartyServer doesn't have a \"main\" party by default. Try adding this to your PartySocket client:\\n \nparty: \"${camelCaseToKebabCase(Object.keys(map)[0])}\"`);\n      } else {\n        console.error(`The url ${req.url} does not match any server namespace. \nDid you forget to add a durable object binding to the class in your wrangler.toml?`);\n      }\n    }\n\n    let doNamespace = map[namespace];\n    if (options?.jurisdiction) {\n      doNamespace = doNamespace.jurisdiction(options.jurisdiction);\n    }\n\n    const id = doNamespace.idFromName(name);\n    const stub = doNamespace.get(id, options);\n\n    // const stub = await getServerByName(map[namespace], name, options); // TODO: fix this\n    // make a new request with additional headers\n\n    req = new Request(req);\n    req.headers.set(\"x-partykit-room\", name);\n    req.headers.set(\"x-partykit-namespace\", namespace);\n    if (options?.jurisdiction) {\n      req.headers.set(\"x-partykit-jurisdiction\", options.jurisdiction);\n    }\n\n    if (req.headers.get(\"Upgrade\")?.toLowerCase() === \"websocket\") {\n      if (options?.onBeforeConnect) {\n        const reqOrRes = await options.onBeforeConnect(req, {\n          party: namespace,\n          name\n        });\n        if (reqOrRes instanceof Request) {\n          req = reqOrRes;\n        } else if (reqOrRes instanceof Response) {\n          return reqOrRes;\n        }\n      }\n    } else {\n      if (options?.onBeforeRequest) {\n        const reqOrRes = await options.onBeforeRequest(req, {\n          party: namespace,\n          name\n        });\n        if (reqOrRes instanceof Request) {\n          req = reqOrRes;\n        } else if (reqOrRes instanceof Response) {\n          return reqOrRes;\n        }\n      }\n    }\n\n    return stub.fetch(req);\n  } else {\n    return null;\n  }\n}\n\nexport class Server<Env = unknown> extends DurableObject<Env> {\n  static options = {\n    hibernate: false\n  };\n\n  #status: \"zero\" | \"starting\" | \"started\" = \"zero\";\n\n  #ParentClass: typeof Server = Object.getPrototypeOf(this).constructor;\n\n  #connectionManager: ConnectionManager = this.#ParentClass.options.hibernate\n    ? new HibernatingConnectionManager(this.ctx)\n    : new InMemoryConnectionManager();\n\n  // biome-ignore lint/complexity/noUselessConstructor: <explanation>\n  constructor(ctx: DurableObjectState, env: Env) {\n    super(ctx, env);\n\n    // this.ctx\n    //   .blockConcurrencyWhile(async () => {\n    //     await this.#initialize();\n    //   })\n    //   .catch((e) => {\n    //     console.error(`Error while initilaizing ${this.#ParentClass.name}:`, e);\n    //   });\n\n    // TODO: throw error if any of\n    // broadcast/getConnection/getConnections/getConnectionTags\n    // fetch/webSocketMessage/webSocketClose/webSocketError/alarm\n    // have been overridden\n  }\n\n  /**\n   * Handle incoming requests to the server.\n   */\n  async fetch(request: Request): Promise<Response> {\n    if (!this.#_name) {\n      // This is temporary while we solve https://github.com/cloudflare/workerd/issues/2240\n\n      // get namespace and room from headers\n      // const namespace = request.headers.get(\"x-partykit-namespace\");\n      const room = request.headers.get(\"x-partykit-room\");\n      if (\n        // !namespace ||\n        !room\n      ) {\n        throw new Error(`Missing namespace or room headers when connecting to ${this.#ParentClass.name}.\nDid you try connecting directly to this Durable Object? Try using getServerByName(namespace, id) instead.`);\n      }\n      await this.setName(room);\n    }\n\n    try {\n      const url = new URL(request.url);\n\n      // TODO: this is a hack to set the server name,\n      // it'll be replaced with RPC later\n      if (url.pathname === \"/cdn-cgi/partyserver/set-name/\") {\n        // we can just return a 200 for now\n        return Response.json({ ok: true });\n      }\n\n      if (request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n        return await this.onRequest(request);\n      } else {\n        // Create the websocket pair for the client\n        const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair();\n        let connectionId = url.searchParams.get(\"_pk\");\n        if (!connectionId) {\n          connectionId = nanoid();\n        }\n\n        let connection: Connection = Object.assign(serverWebSocket, {\n          id: connectionId,\n          server: this.name,\n          state: null as unknown as ConnectionState<unknown>,\n          setState<T = unknown>(setState: T | ConnectionSetStateFn<T>) {\n            let state: T;\n            if (setState instanceof Function) {\n              state = setState(this.state as ConnectionState<T>);\n            } else {\n              state = setState;\n            }\n\n            // TODO: deepFreeze object?\n            this.state = state as ConnectionState<T>;\n            return this.state;\n          }\n        });\n\n        const ctx = { request };\n\n        const tags = await this.getConnectionTags(connection, ctx);\n\n        // Accept the websocket connection\n        connection = this.#connectionManager.accept(connection, {\n          tags,\n          server: this.name\n        });\n\n        if (!this.#ParentClass.options.hibernate) {\n          this.#attachSocketEventHandlers(connection);\n        }\n        await this.onConnect(connection, ctx);\n\n        return new Response(null, { status: 101, webSocket: clientWebSocket });\n      }\n    } catch (err) {\n      console.error(\n        `Error in ${this.#ParentClass.name}:${this.name} fetch:`,\n        err\n      );\n      if (!(err instanceof Error)) throw err;\n      if (request.headers.get(\"Upgrade\") === \"websocket\") {\n        // Annoyingly, if we return an HTTP error in response to a WebSocket request, Chrome devtools\n        // won't show us the response body! So... let's send a WebSocket response with an error\n        // frame instead.\n        const pair = new WebSocketPair();\n        pair[1].accept();\n        pair[1].send(JSON.stringify({ error: err.stack }));\n        pair[1].close(1011, \"Uncaught exception during session setup\");\n        return new Response(null, { status: 101, webSocket: pair[0] });\n      } else {\n        return new Response(err.stack, { status: 500 });\n      }\n    }\n  }\n\n  async webSocketMessage(ws: WebSocket, message: WSMessage): Promise<void> {\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's wiken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n\n    return this.onMessage(connection, message);\n  }\n\n  async webSocketClose(\n    ws: WebSocket,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): Promise<void> {\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's wiken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return this.onClose(connection, code, reason, wasClean);\n  }\n\n  async webSocketError(ws: WebSocket, error: unknown): Promise<void> {\n    const connection = createLazyConnection(ws);\n\n    // rehydrate the server name if it's wiken up\n    await this.setName(connection.server);\n    // TODO: ^ this shouldn't be async\n\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return this.onError(connection, error);\n  }\n\n  async #initialize(): Promise<void> {\n    await this.ctx.blockConcurrencyWhile(async () => {\n      this.#status = \"starting\";\n      await this.onStart();\n      this.#status = \"started\";\n    });\n  }\n\n  #attachSocketEventHandlers(connection: Connection) {\n    const handleMessageFromClient = (event: MessageEvent) => {\n      this.onMessage(connection, event.data)?.catch<void>((e) => {\n        console.error(\"onMessage error:\", e);\n      });\n    };\n\n    const handleCloseFromClient = (event: CloseEvent) => {\n      connection.removeEventListener(\"message\", handleMessageFromClient);\n      connection.removeEventListener(\"close\", handleCloseFromClient);\n      this.onClose(connection, event.code, event.reason, event.wasClean)?.catch(\n        (e) => {\n          console.error(\"onClose error:\", e);\n        }\n      );\n    };\n\n    const handleErrorFromClient = (e: ErrorEvent) => {\n      connection.removeEventListener(\"message\", handleMessageFromClient);\n      connection.removeEventListener(\"error\", handleErrorFromClient);\n      this.onError(connection, e.error)?.catch((e) => {\n        console.error(\"onError error:\", e);\n      });\n    };\n\n    connection.addEventListener(\"close\", handleCloseFromClient);\n    connection.addEventListener(\"error\", handleErrorFromClient);\n    connection.addEventListener(\"message\", handleMessageFromClient);\n  }\n\n  // Public API\n\n  #_name: string | undefined;\n\n  #_longErrorAboutNameThrown = false;\n  /**\n   * The name for this server. Write-once-only.\n   */\n  get name(): string {\n    if (!this.#_name) {\n      if (!this.#_longErrorAboutNameThrown) {\n        this.#_longErrorAboutNameThrown = true;\n        throw new Error(\n          `Attempting to read .name on ${this.#ParentClass.name} before it was set. The name can be set by explicitly calling .setName(name) on the stub, or by using routePartyKitRequest(). This is a known issue and will be fixed soon. Follow https://github.com/cloudflare/workerd/issues/2240 for more updates.`\n        );\n      } else {\n        throw new Error(\n          `Attempting to read .name on ${this.#ParentClass.name} before it was set.`\n        );\n      }\n    }\n    return this.#_name;\n  }\n\n  // We won't have an await inside this function\n  // but it will be called remotely,\n  // so we need to mark it as async\n  async setName(name: string) {\n    if (!name) {\n      throw new Error(\"A name is required.\");\n    }\n    if (this.#_name && this.#_name !== name) {\n      throw new Error(\"This server already has a name.\");\n    }\n    this.#_name = name;\n\n    if (this.#status !== \"started\") {\n      await this.ctx.blockConcurrencyWhile(async () => {\n        await this.#initialize();\n      });\n    }\n  }\n\n  #sendMessageToConnection(connection: Connection, message: WSMessage): void {\n    try {\n      connection.send(message);\n    } catch (_e) {\n      // close connection\n      connection.close(1011, \"Unexpected error\");\n    }\n  }\n\n  /** Send a message to all connected clients, except connection ids listed in `without` */\n  broadcast(\n    msg: string | ArrayBuffer | ArrayBufferView,\n    without?: string[] | undefined\n  ): void {\n    for (const connection of this.#connectionManager.getConnections()) {\n      if (!without || !without.includes(connection.id)) {\n        this.#sendMessageToConnection(connection, msg);\n      }\n    }\n  }\n\n  /** Get a connection by connection id */\n  getConnection<TState = unknown>(id: string): Connection<TState> | undefined {\n    return this.#connectionManager.getConnection<TState>(id);\n  }\n\n  /**\n   * Get all connections. Optionally, you can provide a tag to filter returned connections.\n   * Use `Server#getConnectionTags` to tag the connection on connect.\n   */\n  getConnections<TState = unknown>(tag?: string): Iterable<Connection<TState>> {\n    return this.#connectionManager.getConnections<TState>(tag);\n  }\n\n  /**\n   * You can tag a connection to filter them in Server#getConnections.\n   * Each connection supports up to 9 tags, each tag max length is 256 characters.\n   */\n  getConnectionTags(\n    connection: Connection,\n    context: ConnectionContext\n  ): string[] | Promise<string[]> {\n    return [];\n  }\n\n  // Implemented by the user\n\n  /**\n   * Called when the server is started for the first time.\n   */\n  onStart(): void | Promise<void> {}\n\n  /**\n   * Called when a new connection is made to the server.\n   */\n  onConnect(\n    connection: Connection,\n    ctx: ConnectionContext\n  ): void | Promise<void> {\n    console.log(\n      `Connection ${connection.id} connected to ${this.#ParentClass.name}:${this.name}`\n    );\n    // console.log(\n    //   `Implement onConnect on ${this.#ParentClass.name} to handle websocket connections.`\n    // );\n  }\n\n  /**\n   * Called when a message is received from a connection.\n   */\n  onMessage(connection: Connection, message: WSMessage): void | Promise<void> {\n    console.log(\n      `Received message on connection ${this.#ParentClass.name}:${connection.id}`\n    );\n    console.info(\n      `Implement onMessage on ${this.#ParentClass.name} to handle this message.`\n    );\n  }\n\n  /**\n   * Called when a connection is closed.\n   */\n  onClose(\n    connection: Connection,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): void | Promise<void> {}\n\n  /**\n   * Called when an error occurs on a connection.\n   */\n  onError(connection: Connection, error: unknown): void | Promise<void> {\n    console.error(\n      `Error on connection ${connection.id} in ${this.#ParentClass.name}:${this.name}:`,\n      error\n    );\n    console.info(\n      `Implement onError on ${this.#ParentClass.name} to handle this error.`\n    );\n  }\n\n  /**\n   * Called when a request is made to the server.\n   */\n  onRequest(request: Request): Response | Promise<Response> {\n    // default to 404\n\n    console.warn(\n      `onRequest hasn't been implemented on ${this.#ParentClass.name}:${this.name} responding to ${request.url}`\n    );\n\n    return new Response(\"Not implemented\", { status: 404 });\n  }\n\n  onAlarm(): void | Promise<void> {\n    console.log(\n      `Implement onAlarm on ${this.#ParentClass.name} to handle alarms.`\n    );\n  }\n\n  async alarm(): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    await this.onAlarm();\n  }\n}\n", "// Polyfill WebSocket status code constants for environments that don't have them\n// in order to support libraries that expect standards-compatible WebSocket\n// implementations (e.g. PartySocket)\n\nimport type {\n  Connection,\n  ConnectionSetStateFn,\n  ConnectionState\n} from \"./types\";\n\nif (!(\"OPEN\" in WebSocket)) {\n  const WebSocketStatus = {\n    // @ts-expect-error\n    CONNECTING: WebSocket.READY_STATE_CONNECTING,\n    // @ts-expect-error\n    OPEN: WebSocket.READY_STATE_OPEN,\n    // @ts-expect-error\n    CLOSING: WebSocket.READY_STATE_CLOSING,\n    // @ts-expect-error\n    CLOSED: WebSocket.READY_STATE_CLOSED\n  };\n\n  Object.assign(WebSocket, WebSocketStatus);\n  // @ts-expect-error\n  Object.assign(WebSocket.prototype, WebSocketStatus);\n}\n\n/**\n * Store both platform attachments and user attachments in different namespaces\n */\ntype ConnectionAttachments = {\n  __pk: {\n    id: string;\n    // TODO: remove this once we have\n    // durable object level setState\n    server: string;\n  };\n  __user?: unknown;\n};\n\n/**\n * Cache websocket attachments to avoid having to rehydrate them on every property access.\n */\nclass AttachmentCache {\n  #cache = new WeakMap<WebSocket, ConnectionAttachments>();\n\n  get(ws: WebSocket): ConnectionAttachments {\n    let attachment = this.#cache.get(ws);\n    if (!attachment) {\n      attachment = WebSocket.prototype.deserializeAttachment.call(\n        ws\n      ) as ConnectionAttachments;\n      if (attachment !== undefined) {\n        this.#cache.set(ws, attachment);\n      } else {\n        throw new Error(\n          \"Missing websocket attachment. This is most likely an issue in PartyServer, please open an issue at https://github.com/threepointone/partyserver/issues\"\n        );\n      }\n    }\n\n    return attachment;\n  }\n\n  set(ws: WebSocket, attachment: ConnectionAttachments) {\n    this.#cache.set(ws, attachment);\n    WebSocket.prototype.serializeAttachment.call(ws, attachment);\n  }\n}\n\nconst attachments = new AttachmentCache();\nconst connections = new WeakSet<Connection>();\nconst isWrapped = (ws: WebSocket): ws is Connection => {\n  return connections.has(ws as Connection);\n};\n\n/**\n * Wraps a WebSocket with Connection fields that rehydrate the\n * socket attachments lazily only when requested.\n */\nexport const createLazyConnection = (\n  ws: WebSocket | Connection\n): Connection => {\n  if (isWrapped(ws)) {\n    return ws;\n  }\n\n  // if state was set on the socket before initializing the connection,\n  // capture it here so we can persist it again\n  let initialState = undefined;\n  if (\"state\" in ws) {\n    initialState = ws.state;\n    // biome-ignore lint/performance/noDelete: <explanation>\n    delete ws.state;\n  }\n\n  const connection = Object.defineProperties(ws, {\n    id: {\n      get() {\n        return attachments.get(ws).__pk.id;\n      }\n    },\n    server: {\n      get() {\n        return attachments.get(ws).__pk.server;\n      }\n    },\n    socket: {\n      get() {\n        return ws;\n      }\n    },\n    state: {\n      get() {\n        return ws.deserializeAttachment() as ConnectionState<unknown>;\n      }\n    },\n    setState: {\n      value: function setState<T>(setState: T | ConnectionSetStateFn<T>) {\n        let state: T;\n        if (setState instanceof Function) {\n          state = setState((this as Connection<T>).state);\n        } else {\n          state = setState;\n        }\n\n        ws.serializeAttachment(state);\n        return state as ConnectionState<T>;\n      }\n    },\n\n    deserializeAttachment: {\n      value: function deserializeAttachment<T = unknown>() {\n        const attachment = attachments.get(ws);\n        return (attachment.__user ?? null) as T;\n      }\n    },\n\n    serializeAttachment: {\n      value: function serializeAttachment<T = unknown>(attachment: T) {\n        const setting = {\n          ...attachments.get(ws),\n          __user: attachment ?? null\n        };\n\n        attachments.set(ws, setting);\n      }\n    }\n  }) as Connection;\n\n  if (initialState) {\n    connection.setState(initialState);\n  }\n\n  connections.add(connection);\n  return connection;\n};\n\nclass HibernatingConnectionIterator<T>\n  implements IterableIterator<Connection<T>>\n{\n  private index = 0;\n  private sockets: WebSocket[] | undefined;\n  constructor(\n    private state: DurableObjectState,\n    private tag?: string\n  ) {}\n\n  [Symbol.iterator](): IterableIterator<Connection<T>> {\n    return this;\n  }\n\n  next(): IteratorResult<Connection<T>, number | undefined> {\n    const sockets =\n      // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n      this.sockets ?? (this.sockets = this.state.getWebSockets(this.tag));\n\n    let socket: WebSocket;\n    // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n    while ((socket = sockets[this.index++])) {\n      // only yield open sockets to match non-hibernating behaviour\n      if (socket.readyState === WebSocket.READY_STATE_OPEN) {\n        const value = createLazyConnection(socket) as Connection<T>;\n        return { done: false, value };\n      }\n    }\n\n    // reached the end of the iteratee\n    return { done: true, value: undefined };\n  }\n}\n\nexport interface ConnectionManager {\n  getCount(): number;\n  getConnection<TState>(id: string): Connection<TState> | undefined;\n  getConnections<TState>(tag?: string): IterableIterator<Connection<TState>>;\n  accept(\n    connection: Connection,\n    options: { tags: string[]; server: string }\n  ): Connection;\n}\n\n/**\n * When not using hibernation, we track active connections manually.\n */\nexport class InMemoryConnectionManager<TState> implements ConnectionManager {\n  #connections: Map<string, Connection> = new Map();\n  tags: WeakMap<Connection, string[]> = new WeakMap();\n\n  getCount() {\n    return this.#connections.size;\n  }\n\n  getConnection<T = TState>(id: string) {\n    return this.#connections.get(id) as Connection<T> | undefined;\n  }\n\n  *getConnections<T = TState>(tag?: string): IterableIterator<Connection<T>> {\n    if (!tag) {\n      yield* this.#connections\n        .values()\n        .filter(\n          (c) => c.readyState === WebSocket.READY_STATE_OPEN\n        ) as IterableIterator<Connection<T>>;\n      return;\n    }\n\n    // simulate DurableObjectState.getWebSockets(tag) behaviour\n    for (const connection of this.#connections.values()) {\n      const connectionTags = this.tags.get(connection) ?? [];\n      if (connectionTags.includes(tag)) {\n        yield connection as Connection<T>;\n      }\n    }\n  }\n\n  accept(connection: Connection, options: { tags: string[]; server: string }) {\n    connection.accept();\n\n    this.#connections.set(connection.id, connection);\n    this.tags.set(connection, [\n      // make sure we have id tag\n      connection.id,\n      ...options.tags.filter((t) => t !== connection.id)\n    ]);\n\n    const removeConnection = () => {\n      this.#connections.delete(connection.id);\n      connection.removeEventListener(\"close\", removeConnection);\n      connection.removeEventListener(\"error\", removeConnection);\n    };\n    connection.addEventListener(\"close\", removeConnection);\n    connection.addEventListener(\"error\", removeConnection);\n\n    return connection;\n  }\n}\n\n/**\n * When opting into hibernation, the platform tracks connections for us.\n */\nexport class HibernatingConnectionManager<TState> implements ConnectionManager {\n  constructor(private controller: DurableObjectState) {}\n\n  getCount() {\n    return Number(this.controller.getWebSockets().length);\n  }\n\n  getConnection<T = TState>(id: string) {\n    // TODO: Should we cache the connections?\n    const sockets = this.controller.getWebSockets(id);\n    if (sockets.length === 0) return undefined;\n    if (sockets.length === 1)\n      return createLazyConnection(sockets[0]) as Connection<T>;\n\n    throw new Error(\n      `More than one connection found for id ${id}. Did you mean to use getConnections(tag) instead?`\n    );\n  }\n\n  getConnections<T = TState>(tag?: string | undefined) {\n    return new HibernatingConnectionIterator<T>(this.controller, tag);\n  }\n\n  accept(connection: Connection, options: { tags: string[]; server: string }) {\n    // dedupe tags in case user already provided id tag\n    const tags = [\n      connection.id,\n      ...options.tags.filter((t) => t !== connection.id)\n    ];\n\n    // validate tags against documented restrictions\n    // shttps://developers.cloudflare.com/durable-objects/api/hibernatable-websockets-api/#state-methods-for-websockets\n    if (tags.length > 10) {\n      throw new Error(\n        \"A connection can only have 10 tags, including the default id tag.\"\n      );\n    }\n\n    for (const tag of tags) {\n      if (typeof tag !== \"string\") {\n        throw new Error(`A connection tag must be a string. Received: ${tag}`);\n      }\n      if (tag === \"\") {\n        throw new Error(\"A connection tag must not be an empty string.\");\n      }\n      if (tag.length > 256) {\n        throw new Error(\"A connection tag must not exceed 256 characters\");\n      }\n    }\n\n    this.controller.acceptWebSocket(connection, tags);\n    connection.serializeAttachment({\n      __pk: {\n        id: connection.id,\n        server: options.server\n      },\n      __user: null\n    });\n\n    return createLazyConnection(connection);\n  }\n}\n", null, null, null, "import {\n  asyncWrapProviders,\n  createHook,\n  executionAsyncId,\n  executionAsyncResource,\n  triggerAsyncId\n} from \"unenv/node/async_hooks\";\nexport {\n  asyncWrapProviders,\n  createHook,\n  executionAsyncId,\n  executionAsyncResource,\n  triggerAsyncId\n} from \"unenv/node/async_hooks\";\nconst workerdAsyncHooks = process.getBuiltinModule(\"node:async_hooks\");\nexport const { AsyncLocalStorage, AsyncResource } = workerdAsyncHooks;\nexport default {\n  /**\n   * manually unroll unenv-polyfilled-symbols to make it tree-shakeable\n   */\n  // @ts-expect-error @types/node is missing this one - this is a bug in typings\n  asyncWrapProviders,\n  createHook,\n  executionAsyncId,\n  executionAsyncResource,\n  triggerAsyncId,\n  /**\n   * manually unroll workerd-polyfilled-symbols to make it tree-shakeable\n   */\n  AsyncLocalStorage,\n  AsyncResource\n};\n", "import {\n  Server,\n  routePartykitRequest,\n  type PartyServerOptions,\n  getServerByName,\n  type Connection,\n  type ConnectionContext,\n  type WSMessage,\n} from \"partyserver\";\n\nimport { parseCronExpression } from \"cron-schedule\";\nimport { nanoid } from \"nanoid\";\n\nimport { AsyncLocalStorage } from \"node:async_hooks\";\nimport { MCPClientManager } from \"./mcp/client\";\nimport {\n  DurableObjectOAuthClientProvider,\n  type AgentsOAuthProvider,\n} from \"./mcp/do-oauth-client-provider\";\nimport type {\n  Tool,\n  Resource,\n  Prompt,\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nimport type { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport type { SSEClientTransportOptions } from \"@modelcontextprotocol/sdk/client/sse.js\";\n\nimport { camelCaseToKebabCase } from \"./client\";\n\nexport type { Connection, WSMessage, ConnectionContext } from \"partyserver\";\n\n/**\n * RPC request message from client\n */\nexport type RPCRequest = {\n  type: \"rpc\";\n  id: string;\n  method: string;\n  args: unknown[];\n};\n\n/**\n * State update message from client\n */\nexport type StateUpdateMessage = {\n  type: \"cf_agent_state\";\n  state: unknown;\n};\n\n/**\n * RPC response message to client\n */\nexport type RPCResponse = {\n  type: \"rpc\";\n  id: string;\n} & (\n  | {\n      success: true;\n      result: unknown;\n      done?: false;\n    }\n  | {\n      success: true;\n      result: unknown;\n      done: true;\n    }\n  | {\n      success: false;\n      error: string;\n    }\n);\n\n/**\n * Type guard for RPC request messages\n */\nfunction isRPCRequest(msg: unknown): msg is RPCRequest {\n  return (\n    typeof msg === \"object\" &&\n    msg !== null &&\n    \"type\" in msg &&\n    msg.type === \"rpc\" &&\n    \"id\" in msg &&\n    typeof msg.id === \"string\" &&\n    \"method\" in msg &&\n    typeof msg.method === \"string\" &&\n    \"args\" in msg &&\n    Array.isArray((msg as RPCRequest).args)\n  );\n}\n\n/**\n * Type guard for state update messages\n */\nfunction isStateUpdateMessage(msg: unknown): msg is StateUpdateMessage {\n  return (\n    typeof msg === \"object\" &&\n    msg !== null &&\n    \"type\" in msg &&\n    msg.type === \"cf_agent_state\" &&\n    \"state\" in msg\n  );\n}\n\n/**\n * Metadata for a callable method\n */\nexport type CallableMetadata = {\n  /** Optional description of what the method does */\n  description?: string;\n  /** Whether the method supports streaming responses */\n  streaming?: boolean;\n};\n\n// biome-ignore lint/complexity/noBannedTypes: <explanation>\nconst callableMetadata = new Map<Function, CallableMetadata>();\n\n/**\n * Decorator that marks a method as callable by clients\n * @param metadata Optional metadata about the callable method\n */\nexport function unstable_callable(metadata: CallableMetadata = {}) {\n  return function callableDecorator<This, Args extends unknown[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    context: ClassMethodDecoratorContext\n  ) {\n    if (!callableMetadata.has(target)) {\n      callableMetadata.set(target, metadata);\n    }\n\n    return target;\n  };\n}\n\n/**\n * Represents a scheduled task within an Agent\n * @template T Type of the payload data\n */\nexport type Schedule<T = string> = {\n  /** Unique identifier for the schedule */\n  id: string;\n  /** Name of the method to be called */\n  callback: string;\n  /** Data to be passed to the callback */\n  payload: T;\n} & (\n  | {\n      /** Type of schedule for one-time execution at a specific time */\n      type: \"scheduled\";\n      /** Timestamp when the task should execute */\n      time: number;\n    }\n  | {\n      /** Type of schedule for delayed execution */\n      type: \"delayed\";\n      /** Timestamp when the task should execute */\n      time: number;\n      /** Number of seconds to delay execution */\n      delayInSeconds: number;\n    }\n  | {\n      /** Type of schedule for recurring execution based on cron expression */\n      type: \"cron\";\n      /** Timestamp for the next execution */\n      time: number;\n      /** Cron expression defining the schedule */\n      cron: string;\n    }\n);\n\nfunction getNextCronTime(cron: string) {\n  const interval = parseCronExpression(cron);\n  return interval.getNextDate();\n}\n\n/**\n * MCP Server state update message from server -> Client\n */\nexport type MCPServerMessage = {\n  type: \"cf_agent_mcp_servers\";\n  mcp: MCPServersState;\n};\n\nexport type MCPServersState = {\n  servers: {\n    [id: string]: MCPServer;\n  };\n  tools: Tool[];\n  prompts: Prompt[];\n  resources: Resource[];\n};\n\nexport type MCPServer = {\n  name: string;\n  server_url: string;\n  auth_url: string | null;\n  state: \"authenticating\" | \"connecting\" | \"ready\" | \"discovering\" | \"failed\";\n};\n\n/**\n * MCP Server data stored in DO SQL for resuming MCP Server connections\n */\ntype MCPServerRow = {\n  id: string;\n  name: string;\n  server_url: string;\n  client_id: string | null;\n  auth_url: string | null;\n  callback_url: string;\n  server_options: string;\n};\n\nconst STATE_ROW_ID = \"cf_state_row_id\";\nconst STATE_WAS_CHANGED = \"cf_state_was_changed\";\n\nconst DEFAULT_STATE = {} as unknown;\n\nconst agentContext = new AsyncLocalStorage<{\n  agent: Agent<unknown>;\n  connection: Connection | undefined;\n  request: Request | undefined;\n}>();\n\nexport function getCurrentAgent<\n  T extends Agent<unknown, unknown> = Agent<unknown, unknown>,\n>(): {\n  agent: T | undefined;\n  connection: Connection | undefined;\n  request: Request<unknown, CfProperties<unknown>> | undefined;\n} {\n  const store = agentContext.getStore() as\n    | {\n        agent: T;\n        connection: Connection | undefined;\n        request: Request<unknown, CfProperties<unknown>> | undefined;\n      }\n    | undefined;\n  if (!store) {\n    return {\n      agent: undefined,\n      connection: undefined,\n      request: undefined,\n    };\n  }\n  return store;\n}\n\n/**\n * Base class for creating Agent implementations\n * @template Env Environment type containing bindings\n * @template State State type to store within the Agent\n */\nexport class Agent<Env, State = unknown> extends Server<Env> {\n  #state = DEFAULT_STATE as State;\n\n  #ParentClass: typeof Agent<Env, State> =\n    Object.getPrototypeOf(this).constructor;\n\n  mcp: MCPClientManager = new MCPClientManager(this.#ParentClass.name, \"0.0.1\");\n\n  /**\n   * Initial state for the Agent\n   * Override to provide default state values\n   */\n  initialState: State = DEFAULT_STATE as State;\n\n  /**\n   * Current state of the Agent\n   */\n  get state(): State {\n    if (this.#state !== DEFAULT_STATE) {\n      // state was previously set, and populated internal state\n      return this.#state;\n    }\n    // looks like this is the first time the state is being accessed\n    // check if the state was set in a previous life\n    const wasChanged = this.sql<{ state: \"true\" | undefined }>`\n        SELECT state FROM cf_agents_state WHERE id = ${STATE_WAS_CHANGED}\n      `;\n\n    // ok, let's pick up the actual state from the db\n    const result = this.sql<{ state: State | undefined }>`\n      SELECT state FROM cf_agents_state WHERE id = ${STATE_ROW_ID}\n    `;\n\n    if (\n      wasChanged[0]?.state === \"true\" ||\n      // we do this check for people who updated their code before we shipped wasChanged\n      result[0]?.state\n    ) {\n      const state = result[0]?.state as string; // could be null?\n\n      this.#state = JSON.parse(state);\n      return this.#state;\n    }\n\n    // ok, this is the first time the state is being accessed\n    // and the state was not set in a previous life\n    // so we need to set the initial state (if provided)\n    if (this.initialState === DEFAULT_STATE) {\n      // no initial state provided, so we return undefined\n      return undefined as State;\n    }\n    // initial state provided, so we set the state,\n    // update db and return the initial state\n    this.setState(this.initialState);\n    return this.initialState;\n  }\n\n  /**\n   * Agent configuration options\n   */\n  static options = {\n    /** Whether the Agent should hibernate when inactive */\n    hibernate: true, // default to hibernate\n  };\n\n  /**\n   * Execute SQL queries against the Agent's database\n   * @template T Type of the returned rows\n   * @param strings SQL query template strings\n   * @param values Values to be inserted into the query\n   * @returns Array of query results\n   */\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    let query = \"\";\n    try {\n      // Construct the SQL query with placeholders\n      query = strings.reduce(\n        (acc, str, i) => acc + str + (i < values.length ? \"?\" : \"\"),\n        \"\"\n      );\n\n      // Execute the SQL query with the provided values\n      return [...this.ctx.storage.sql.exec(query, ...values)] as T[];\n    } catch (e) {\n      console.error(`failed to execute sql query: ${query}`, e);\n      throw this.onError(e);\n    }\n  }\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_state (\n        id TEXT PRIMARY KEY NOT NULL,\n        state TEXT\n      )\n    `;\n\n    void this.ctx.blockConcurrencyWhile(async () => {\n      return this.#tryCatch(async () => {\n        // Create alarms table if it doesn't exist\n        this.sql`\n        CREATE TABLE IF NOT EXISTS cf_agents_schedules (\n          id TEXT PRIMARY KEY NOT NULL DEFAULT (randomblob(9)),\n          callback TEXT,\n          payload TEXT,\n          type TEXT NOT NULL CHECK(type IN ('scheduled', 'delayed', 'cron')),\n          time INTEGER,\n          delayInSeconds INTEGER,\n          cron TEXT,\n          created_at INTEGER DEFAULT (unixepoch())\n        )\n      `;\n\n        // execute any pending alarms and schedule the next alarm\n        await this.alarm();\n      });\n    });\n\n    this.sql`\n      CREATE TABLE IF NOT EXISTS cf_agents_mcp_servers (\n        id TEXT PRIMARY KEY NOT NULL,\n        name TEXT NOT NULL,\n        server_url TEXT NOT NULL,\n        callback_url TEXT NOT NULL,\n        client_id TEXT,\n        auth_url TEXT,\n        server_options TEXT\n      )\n    `;\n\n    const _onRequest = this.onRequest.bind(this);\n    this.onRequest = (request: Request) => {\n      return agentContext.run(\n        { agent: this, connection: undefined, request },\n        async () => {\n          if (this.mcp.isCallbackRequest(request)) {\n            await this.mcp.handleCallbackRequest(request);\n\n            // after the MCP connection handshake, we can send updated mcp state\n            this.broadcast(\n              JSON.stringify({\n                type: \"cf_agent_mcp_servers\",\n                mcp: this.#getMcpServerStateInternal(),\n              })\n            );\n\n            // We probably should let the user configure this response/redirect, but this is fine for now.\n            return new Response(\"<script>window.close();</script>\", {\n              status: 200,\n              headers: { \"content-type\": \"text/html\" },\n            });\n          }\n\n          return this.#tryCatch(() => _onRequest(request));\n        }\n      );\n    };\n\n    const _onMessage = this.onMessage.bind(this);\n    this.onMessage = async (connection: Connection, message: WSMessage) => {\n      return agentContext.run(\n        { agent: this, connection, request: undefined },\n        async () => {\n          if (typeof message !== \"string\") {\n            return this.#tryCatch(() => _onMessage(connection, message));\n          }\n\n          let parsed: unknown;\n          try {\n            parsed = JSON.parse(message);\n          } catch (e) {\n            // silently fail and let the onMessage handler handle it\n            return this.#tryCatch(() => _onMessage(connection, message));\n          }\n\n          if (isStateUpdateMessage(parsed)) {\n            this.#setStateInternal(parsed.state as State, connection);\n            return;\n          }\n\n          if (isRPCRequest(parsed)) {\n            try {\n              const { id, method, args } = parsed;\n\n              // Check if method exists and is callable\n              const methodFn = this[method as keyof this];\n              if (typeof methodFn !== \"function\") {\n                throw new Error(`Method ${method} does not exist`);\n              }\n\n              if (!this.#isCallable(method)) {\n                throw new Error(`Method ${method} is not callable`);\n              }\n\n              // biome-ignore lint/complexity/noBannedTypes: <explanation>\n              const metadata = callableMetadata.get(methodFn as Function);\n\n              // For streaming methods, pass a StreamingResponse object\n              if (metadata?.streaming) {\n                const stream = new StreamingResponse(connection, id);\n                await methodFn.apply(this, [stream, ...args]);\n                return;\n              }\n\n              // For regular methods, execute and send response\n              const result = await methodFn.apply(this, args);\n              const response: RPCResponse = {\n                type: \"rpc\",\n                id,\n                success: true,\n                result,\n                done: true,\n              };\n              connection.send(JSON.stringify(response));\n            } catch (e) {\n              // Send error response\n              const response: RPCResponse = {\n                type: \"rpc\",\n                id: parsed.id,\n                success: false,\n                error:\n                  e instanceof Error ? e.message : \"Unknown error occurred\",\n              };\n              connection.send(JSON.stringify(response));\n              console.error(\"RPC error:\", e);\n            }\n            return;\n          }\n\n          return this.#tryCatch(() => _onMessage(connection, message));\n        }\n      );\n    };\n\n    const _onConnect = this.onConnect.bind(this);\n    this.onConnect = (connection: Connection, ctx: ConnectionContext) => {\n      // TODO: This is a hack to ensure the state is sent after the connection is established\n      // must fix this\n      return agentContext.run(\n        { agent: this, connection, request: ctx.request },\n        async () => {\n          setTimeout(() => {\n            if (this.state) {\n              connection.send(\n                JSON.stringify({\n                  type: \"cf_agent_state\",\n                  state: this.state,\n                })\n              );\n            }\n\n            connection.send(\n              JSON.stringify({\n                type: \"cf_agent_mcp_servers\",\n                mcp: this.#getMcpServerStateInternal(),\n              })\n            );\n\n            return this.#tryCatch(() => _onConnect(connection, ctx));\n          }, 20);\n        }\n      );\n    };\n\n    const _onStart = this.onStart.bind(this);\n    this.onStart = async () => {\n      return agentContext.run(\n        { agent: this, connection: undefined, request: undefined },\n        async () => {\n          const servers = this.sql<MCPServerRow>`\n            SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;\n          `;\n\n          // from DO storage, reconnect to all servers using our saved auth information\n          await Promise.allSettled(\n            servers.map((server) => {\n              return this.#connectToMcpServerInternal(\n                server.name,\n                server.server_url,\n                server.callback_url,\n                server.server_options\n                  ? JSON.parse(server.server_options)\n                  : undefined,\n                {\n                  id: server.id,\n                  oauthClientId: server.client_id ?? undefined,\n                }\n              );\n            })\n          );\n\n          this.broadcast(\n            JSON.stringify({\n              type: \"cf_agent_mcp_servers\",\n              mcp: this.#getMcpServerStateInternal(),\n            })\n          );\n\n          await this.#tryCatch(() => _onStart());\n        }\n      );\n    };\n  }\n\n  #setStateInternal(state: State, source: Connection | \"server\" = \"server\") {\n    this.#state = state;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_ROW_ID}, ${JSON.stringify(state)})\n  `;\n    this.sql`\n    INSERT OR REPLACE INTO cf_agents_state (id, state)\n    VALUES (${STATE_WAS_CHANGED}, ${JSON.stringify(true)})\n  `;\n    this.broadcast(\n      JSON.stringify({\n        type: \"cf_agent_state\",\n        state: state,\n      }),\n      source !== \"server\" ? [source.id] : []\n    );\n    return this.#tryCatch(() => {\n      const { connection, request } = agentContext.getStore() || {};\n      return agentContext.run(\n        { agent: this, connection, request },\n        async () => {\n          return this.onStateUpdate(state, source);\n        }\n      );\n    });\n  }\n\n  /**\n   * Update the Agent's state\n   * @param state New state to set\n   */\n  setState(state: State) {\n    this.#setStateInternal(state, \"server\");\n  }\n\n  /**\n   * Called when the Agent's state is updated\n   * @param state Updated state\n   * @param source Source of the state update (\"server\" or a client connection)\n   */\n  onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n    // override this to handle state updates\n  }\n\n  /**\n   * Called when the Agent receives an email\n   * @param email Email message to process\n   */\n  onEmail(email: ForwardableEmailMessage) {\n    return agentContext.run(\n      { agent: this, connection: undefined, request: undefined },\n      async () => {\n        console.error(\"onEmail not implemented\");\n      }\n    );\n  }\n\n  async #tryCatch<T>(fn: () => T | Promise<T>) {\n    try {\n      return await fn();\n    } catch (e) {\n      throw this.onError(e);\n    }\n  }\n\n  override onError(\n    connection: Connection,\n    error: unknown\n  ): void | Promise<void>;\n  override onError(error: unknown): void | Promise<void>;\n  override onError(connectionOrError: Connection | unknown, error?: unknown) {\n    let theError: unknown;\n    if (connectionOrError && error) {\n      theError = error;\n      // this is a websocket connection error\n      console.error(\n        \"Error on websocket connection:\",\n        (connectionOrError as Connection).id,\n        theError\n      );\n      console.error(\n        \"Override onError(connection, error) to handle websocket connection errors\"\n      );\n    } else {\n      theError = connectionOrError;\n      // this is a server error\n      console.error(\"Error on server:\", theError);\n      console.error(\"Override onError(error) to handle server errors\");\n    }\n    throw theError;\n  }\n\n  /**\n   * Render content (not implemented in base class)\n   */\n  render() {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Schedule a task to be executed in the future\n   * @template T Type of the payload data\n   * @param when When to execute the task (Date, seconds delay, or cron expression)\n   * @param callback Name of the method to call\n   * @param payload Data to pass to the callback\n   * @returns Schedule object representing the scheduled task\n   */\n  async schedule<T = string>(\n    when: Date | string | number,\n    callback: keyof this,\n    payload?: T\n  ): Promise<Schedule<T>> {\n    const id = nanoid(9);\n\n    if (typeof callback !== \"string\") {\n      throw new Error(\"Callback must be a string\");\n    }\n\n    if (typeof this[callback] !== \"function\") {\n      throw new Error(`this.${callback} is not a function`);\n    }\n\n    if (when instanceof Date) {\n      const timestamp = Math.floor(when.getTime() / 1000);\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'scheduled', ${timestamp})\n      `;\n\n      await this.#scheduleNextAlarm();\n\n      return {\n        id,\n        callback: callback,\n        payload: payload as T,\n        time: timestamp,\n        type: \"scheduled\",\n      };\n    }\n    if (typeof when === \"number\") {\n      const time = new Date(Date.now() + when * 1000);\n      const timestamp = Math.floor(time.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, delayInSeconds, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'delayed', ${when}, ${timestamp})\n      `;\n\n      await this.#scheduleNextAlarm();\n\n      return {\n        id,\n        callback: callback,\n        payload: payload as T,\n        delayInSeconds: when,\n        time: timestamp,\n        type: \"delayed\",\n      };\n    }\n    if (typeof when === \"string\") {\n      const nextExecutionTime = getNextCronTime(when);\n      const timestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n      this.sql`\n        INSERT OR REPLACE INTO cf_agents_schedules (id, callback, payload, type, cron, time)\n        VALUES (${id}, ${callback}, ${JSON.stringify(\n          payload\n        )}, 'cron', ${when}, ${timestamp})\n      `;\n\n      await this.#scheduleNextAlarm();\n\n      return {\n        id,\n        callback: callback,\n        payload: payload as T,\n        cron: when,\n        time: timestamp,\n        type: \"cron\",\n      };\n    }\n    throw new Error(\"Invalid schedule type\");\n  }\n\n  /**\n   * Get a scheduled task by ID\n   * @template T Type of the payload data\n   * @param id ID of the scheduled task\n   * @returns The Schedule object or undefined if not found\n   */\n  async getSchedule<T = string>(id: string): Promise<Schedule<T> | undefined> {\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE id = ${id}\n    `;\n    if (!result) {\n      console.error(`schedule ${id} not found`);\n      return undefined;\n    }\n\n    return { ...result[0], payload: JSON.parse(result[0].payload) as T };\n  }\n\n  /**\n   * Get scheduled tasks matching the given criteria\n   * @template T Type of the payload data\n   * @param criteria Criteria to filter schedules\n   * @returns Array of matching Schedule objects\n   */\n  getSchedules<T = string>(\n    criteria: {\n      id?: string;\n      type?: \"scheduled\" | \"delayed\" | \"cron\";\n      timeRange?: { start?: Date; end?: Date };\n    } = {}\n  ): Schedule<T>[] {\n    let query = \"SELECT * FROM cf_agents_schedules WHERE 1=1\";\n    const params = [];\n\n    if (criteria.id) {\n      query += \" AND id = ?\";\n      params.push(criteria.id);\n    }\n\n    if (criteria.type) {\n      query += \" AND type = ?\";\n      params.push(criteria.type);\n    }\n\n    if (criteria.timeRange) {\n      query += \" AND time >= ? AND time <= ?\";\n      const start = criteria.timeRange.start || new Date(0);\n      const end = criteria.timeRange.end || new Date(999999999999999);\n      params.push(\n        Math.floor(start.getTime() / 1000),\n        Math.floor(end.getTime() / 1000)\n      );\n    }\n\n    const result = this.ctx.storage.sql\n      .exec(query, ...params)\n      .toArray()\n      .map((row) => ({\n        ...row,\n        payload: JSON.parse(row.payload as string) as T,\n      })) as Schedule<T>[];\n\n    return result;\n  }\n\n  /**\n   * Cancel a scheduled task\n   * @param id ID of the task to cancel\n   * @returns true if the task was cancelled, false otherwise\n   */\n  async cancelSchedule(id: string): Promise<boolean> {\n    this.sql`DELETE FROM cf_agents_schedules WHERE id = ${id}`;\n\n    await this.#scheduleNextAlarm();\n    return true;\n  }\n\n  async #scheduleNextAlarm() {\n    // Find the next schedule that needs to be executed\n    const result = this.sql`\n      SELECT time FROM cf_agents_schedules \n      WHERE time > ${Math.floor(Date.now() / 1000)}\n      ORDER BY time ASC \n      LIMIT 1\n    `;\n    if (!result) return;\n\n    if (result.length > 0 && \"time\" in result[0]) {\n      const nextTime = (result[0].time as number) * 1000;\n      await this.ctx.storage.setAlarm(nextTime);\n    }\n  }\n\n  /**\n   * Method called when an alarm fires.\n   * Executes any scheduled tasks that are due.\n   *\n   * @remarks\n   * To schedule a task, please use the `this.schedule` method instead.\n   * See {@link https://developers.cloudflare.com/agents/api-reference/schedule-tasks/}\n   */\n  public readonly alarm = async () => {\n    const now = Math.floor(Date.now() / 1000);\n\n    // Get all schedules that should be executed now\n    const result = this.sql<Schedule<string>>`\n      SELECT * FROM cf_agents_schedules WHERE time <= ${now}\n    `;\n\n    for (const row of result || []) {\n      const callback = this[row.callback as keyof Agent<Env>];\n      if (!callback) {\n        console.error(`callback ${row.callback} not found`);\n        continue;\n      }\n      await agentContext.run(\n        { agent: this, connection: undefined, request: undefined },\n        async () => {\n          try {\n            await (\n              callback as (\n                payload: unknown,\n                schedule: Schedule<unknown>\n              ) => Promise<void>\n            ).bind(this)(JSON.parse(row.payload as string), row);\n          } catch (e) {\n            console.error(`error executing callback \"${row.callback}\"`, e);\n          }\n        }\n      );\n      if (row.type === \"cron\") {\n        // Update next execution time for cron schedules\n        const nextExecutionTime = getNextCronTime(row.cron);\n        const nextTimestamp = Math.floor(nextExecutionTime.getTime() / 1000);\n\n        this.sql`\n          UPDATE cf_agents_schedules SET time = ${nextTimestamp} WHERE id = ${row.id}\n        `;\n      } else {\n        // Delete one-time schedules after execution\n        this.sql`\n          DELETE FROM cf_agents_schedules WHERE id = ${row.id}\n        `;\n      }\n    }\n\n    // Schedule the next alarm\n    await this.#scheduleNextAlarm();\n  };\n\n  /**\n   * Destroy the Agent, removing all state and scheduled tasks\n   */\n  async destroy() {\n    // drop all tables\n    this.sql`DROP TABLE IF EXISTS cf_agents_state`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_schedules`;\n    this.sql`DROP TABLE IF EXISTS cf_agents_mcp_servers`;\n\n    // delete all alarms\n    await this.ctx.storage.deleteAlarm();\n    await this.ctx.storage.deleteAll();\n  }\n\n  /**\n   * Get all methods marked as callable on this Agent\n   * @returns A map of method names to their metadata\n   */\n  #isCallable(method: string): boolean {\n    // biome-ignore lint/complexity/noBannedTypes: <explanation>\n    return callableMetadata.has(this[method as keyof this] as Function);\n  }\n\n  /**\n   * Connect to a new MCP Server\n   *\n   * @param url MCP Server SSE URL\n   * @param callbackHost Base host for the agent, used for the redirect URI.\n   * @param agentsPrefix agents routing prefix if not using `agents`\n   * @param options MCP client and transport (header) options\n   * @returns authUrl\n   */\n  async addMcpServer(\n    serverName: string,\n    url: string,\n    callbackHost: string,\n    agentsPrefix = \"agents\",\n    options?: {\n      client?: ConstructorParameters<typeof Client>[1];\n      transport?: {\n        headers: HeadersInit;\n      };\n    }\n  ): Promise<{ id: string; authUrl: string | undefined }> {\n    const callbackUrl = `${callbackHost}/${agentsPrefix}/${camelCaseToKebabCase(this.#ParentClass.name)}/${this.name}/callback`;\n\n    const result = await this.#connectToMcpServerInternal(\n      serverName,\n      url,\n      callbackUrl,\n      options\n    );\n\n    this.broadcast(\n      JSON.stringify({\n        type: \"cf_agent_mcp_servers\",\n        mcp: this.#getMcpServerStateInternal(),\n      })\n    );\n\n    return result;\n  }\n\n  async #connectToMcpServerInternal(\n    serverName: string,\n    url: string,\n    callbackUrl: string,\n    // it's important that any options here are serializable because we put them into our sqlite DB for reconnection purposes\n    options?: {\n      client?: ConstructorParameters<typeof Client>[1];\n      /**\n       * We don't expose the normal set of transport options because:\n       * 1) we can't serialize things like the auth provider or a fetch function into the DB for reconnection purposes\n       * 2) We probably want these options to be agnostic to the transport type (SSE vs Streamable)\n       *\n       * This has the limitation that you can't override fetch, but I think headers should handle nearly all cases needed (i.e. non-standard bearer auth).\n       */\n      transport?: {\n        headers?: HeadersInit;\n      };\n    },\n    reconnect?: {\n      id: string;\n      oauthClientId?: string;\n    }\n  ): Promise<{ id: string; authUrl: string | undefined }> {\n    const authProvider = new DurableObjectOAuthClientProvider(\n      this.ctx.storage,\n      this.name,\n      callbackUrl\n    );\n\n    if (reconnect) {\n      authProvider.serverId = reconnect.id;\n      if (reconnect.oauthClientId) {\n        authProvider.clientId = reconnect.oauthClientId;\n      }\n    }\n\n    // allows passing through transport headers if necessary\n    // this handles some non-standard bearer auth setups (i.e. MCP server behind CF access instead of OAuth)\n    let headerTransportOpts: SSEClientTransportOptions = {};\n    if (options?.transport?.headers) {\n      headerTransportOpts = {\n        eventSourceInit: {\n          fetch: (url, init) =>\n            fetch(url, {\n              ...init,\n              headers: options?.transport?.headers,\n            }),\n        },\n        requestInit: {\n          headers: options?.transport?.headers,\n        },\n      };\n    }\n\n    const { id, authUrl, clientId } = await this.mcp.connect(url, {\n      reconnect,\n      transport: {\n        ...headerTransportOpts,\n        authProvider,\n      },\n      client: options?.client,\n    });\n\n    this.sql`\n      INSERT OR REPLACE INTO cf_agents_mcp_servers (id, name, server_url, client_id, auth_url, callback_url, server_options)\n      VALUES (\n        ${id},\n        ${serverName},\n        ${url},\n        ${clientId ?? null},\n        ${authUrl ?? null},\n        ${callbackUrl},\n        ${options ? JSON.stringify(options) : null}\n      );\n    `;\n\n    return {\n      id,\n      authUrl,\n    };\n  }\n\n  async removeMcpServer(id: string) {\n    this.mcp.closeConnection(id);\n    this.sql`\n      DELETE FROM cf_agents_mcp_servers WHERE id = ${id};\n    `;\n    this.broadcast(\n      JSON.stringify({\n        type: \"cf_agent_mcp_servers\",\n        mcp: this.#getMcpServerStateInternal(),\n      })\n    );\n  }\n\n  #getMcpServerStateInternal(): MCPServersState {\n    const mcpState: MCPServersState = {\n      servers: {},\n      tools: this.mcp.listTools(),\n      prompts: this.mcp.listPrompts(),\n      resources: this.mcp.listResources(),\n    };\n\n    const servers = this.sql<MCPServerRow>`\n      SELECT id, name, server_url, client_id, auth_url, callback_url, server_options FROM cf_agents_mcp_servers;\n    `;\n\n    for (const server of servers) {\n      mcpState.servers[server.id] = {\n        name: server.name,\n        server_url: server.server_url,\n        auth_url: server.auth_url,\n        state: this.mcp.mcpConnections[server.id].connectionState,\n      };\n    }\n\n    return mcpState;\n  }\n}\n\n/**\n * Namespace for creating Agent instances\n * @template Agentic Type of the Agent class\n */\nexport type AgentNamespace<Agentic extends Agent<unknown>> =\n  DurableObjectNamespace<Agentic>;\n\n/**\n * Agent's durable context\n */\nexport type AgentContext = DurableObjectState;\n\n/**\n * Configuration options for Agent routing\n */\nexport type AgentOptions<Env> = PartyServerOptions<Env> & {\n  /**\n   * Whether to enable CORS for the Agent\n   */\n  cors?: boolean | HeadersInit | undefined;\n};\n\n/**\n * Route a request to the appropriate Agent\n * @param request Request to route\n * @param env Environment containing Agent bindings\n * @param options Routing options\n * @returns Response from the Agent or undefined if no route matched\n */\nexport async function routeAgentRequest<Env>(\n  request: Request,\n  env: Env,\n  options?: AgentOptions<Env>\n) {\n  const corsHeaders =\n    options?.cors === true\n      ? {\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Allow-Methods\": \"GET, POST, HEAD, OPTIONS\",\n          \"Access-Control-Allow-Credentials\": \"true\",\n          \"Access-Control-Max-Age\": \"86400\",\n        }\n      : options?.cors;\n\n  if (request.method === \"OPTIONS\") {\n    if (corsHeaders) {\n      return new Response(null, {\n        headers: corsHeaders,\n      });\n    }\n    console.warn(\n      \"Received an OPTIONS request, but cors was not enabled. Pass `cors: true` or `cors: { ...custom cors headers }` to routeAgentRequest to enable CORS.\"\n    );\n  }\n\n  let response = await routePartykitRequest(\n    request,\n    env as Record<string, unknown>,\n    {\n      prefix: \"agents\",\n      ...(options as PartyServerOptions<Record<string, unknown>>),\n    }\n  );\n\n  if (\n    response &&\n    corsHeaders &&\n    request.headers.get(\"upgrade\")?.toLowerCase() !== \"websocket\" &&\n    request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\"\n  ) {\n    response = new Response(response.body, {\n      headers: {\n        ...response.headers,\n        ...corsHeaders,\n      },\n    });\n  }\n  return response;\n}\n\n/**\n * Route an email to the appropriate Agent\n * @param email Email message to route\n * @param env Environment containing Agent bindings\n * @param options Routing options\n */\nexport async function routeAgentEmail<Env>(\n  email: ForwardableEmailMessage,\n  env: Env,\n  options?: AgentOptions<Env>\n): Promise<void> {}\n\n/**\n * Get or create an Agent by name\n * @template Env Environment type containing bindings\n * @template T Type of the Agent class\n * @param namespace Agent namespace\n * @param name Name of the Agent instance\n * @param options Options for Agent creation\n * @returns Promise resolving to an Agent instance stub\n */\nexport async function getAgentByName<Env, T extends Agent<Env>>(\n  namespace: AgentNamespace<T>,\n  name: string,\n  options?: {\n    jurisdiction?: DurableObjectJurisdiction;\n    locationHint?: DurableObjectLocationHint;\n  }\n) {\n  return getServerByName<Env, T>(namespace, name, options);\n}\n\n/**\n * A wrapper for streaming responses in callable methods\n */\nexport class StreamingResponse {\n  #connection: Connection;\n  #id: string;\n  #closed = false;\n\n  constructor(connection: Connection, id: string) {\n    this.#connection = connection;\n    this.#id = id;\n  }\n\n  /**\n   * Send a chunk of data to the client\n   * @param chunk The data to send\n   */\n  send(chunk: unknown) {\n    if (this.#closed) {\n      throw new Error(\"StreamingResponse is already closed\");\n    }\n    const response: RPCResponse = {\n      type: \"rpc\",\n      id: this.#id,\n      success: true,\n      result: chunk,\n      done: false,\n    };\n    this.#connection.send(JSON.stringify(response));\n  }\n\n  /**\n   * End the stream and send the final chunk (if any)\n   * @param finalChunk Optional final chunk of data to send\n   */\n  end(finalChunk?: unknown) {\n    if (this.#closed) {\n      throw new Error(\"StreamingResponse is already closed\");\n    }\n    this.#closed = true;\n    const response: RPCResponse = {\n      type: \"rpc\",\n      id: this.#id,\n      success: true,\n      result: finalChunk,\n      done: true,\n    };\n    this.#connection.send(JSON.stringify(response));\n  }\n}\n", "import { DurableObject } from \"cloudflare:workers\";\nimport type { Connection, WSMessage } from \"../\";\nimport { Agent } from \"../\";\nimport type { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport type { JSONRPCMessage } from \"@modelcontextprotocol/sdk/types.js\";\nimport {\n  InitializeRequestSchema,\n  isJSONRPCError,\n  isJSONRPCNotification,\n  isJSONRPCRequest,\n  isJSONRPCResponse,\n  JSONRPCMessageSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport type { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport type { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\n\nconst MAXIMUM_MESSAGE_SIZE_BYTES = 4 * 1024 * 1024; // 4MB\n\n// CORS helper functions\nfunction corsHeaders(request: Request, corsOptions: CORSOptions = {}) {\n  const origin = \"*\";\n  return {\n    \"Access-Control-Allow-Origin\": corsOptions.origin || origin,\n    \"Access-Control-Allow-Methods\": corsOptions.methods || \"GET, POST, OPTIONS\",\n    \"Access-Control-Allow-Headers\":\n      corsOptions.headers || \"Content-Type, mcp-session-id\",\n    \"Access-Control-Max-Age\": (corsOptions.maxAge || 86400).toString(),\n    \"Access-Control-Expose-Headers\":\n      corsOptions.exposeHeaders || \"mcp-session-id\",\n  };\n}\n\nfunction handleCORS(\n  request: Request,\n  corsOptions?: CORSOptions\n): Response | null {\n  if (request.method === \"OPTIONS\") {\n    return new Response(null, { headers: corsHeaders(request, corsOptions) });\n  }\n\n  return null;\n}\n\ninterface CORSOptions {\n  origin?: string;\n  methods?: string;\n  headers?: string;\n  maxAge?: number;\n  exposeHeaders?: string;\n}\n\nclass McpSSETransport implements Transport {\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n  sessionId?: string;\n\n  #getWebSocket: () => WebSocket | null;\n  #started = false;\n  constructor(getWebSocket: () => WebSocket | null) {\n    this.#getWebSocket = getWebSocket;\n  }\n\n  async start() {\n    // The transport does not manage the WebSocket connection since it's terminated\n    // by the Durable Object in order to allow hibernation. There's nothing to initialize.\n    if (this.#started) {\n      throw new Error(\"Transport already started\");\n    }\n    this.#started = true;\n  }\n\n  async send(message: JSONRPCMessage) {\n    if (!this.#started) {\n      throw new Error(\"Transport not started\");\n    }\n    const websocket = this.#getWebSocket();\n    if (!websocket) {\n      throw new Error(\"WebSocket not connected\");\n    }\n    try {\n      websocket.send(JSON.stringify(message));\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n\n  async close() {\n    // Similar to start, the only thing to do is to pass the event on to the server\n    this.onclose?.();\n  }\n}\n\ntype TransportType = \"sse\" | \"streamable-http\" | \"unset\";\n\nclass McpStreamableHttpTransport implements Transport {\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n  sessionId?: string;\n\n  // TODO: If there is an open connection to send server-initiated messages\n  // back, we should use that connection\n  #getWebSocketForGetRequest: () => WebSocket | null;\n\n  // Get the appropriate websocket connection for a given message id\n  #getWebSocketForMessageID: (id: string) => WebSocket | null;\n\n  // Notify the server that a response has been sent for a given message id\n  // so that it may clean up it's mapping of message ids to connections\n  // once they are no longer needed\n  #notifyResponseIdSent: (id: string) => void;\n\n  #started = false;\n  constructor(\n    getWebSocketForMessageID: (id: string) => WebSocket | null,\n    notifyResponseIdSent: (id: string | number) => void\n  ) {\n    this.#getWebSocketForMessageID = getWebSocketForMessageID;\n    this.#notifyResponseIdSent = notifyResponseIdSent;\n    // TODO\n    this.#getWebSocketForGetRequest = () => null;\n  }\n\n  async start() {\n    // The transport does not manage the WebSocket connection since it's terminated\n    // by the Durable Object in order to allow hibernation. There's nothing to initialize.\n    if (this.#started) {\n      throw new Error(\"Transport already started\");\n    }\n    this.#started = true;\n  }\n\n  async send(message: JSONRPCMessage) {\n    if (!this.#started) {\n      throw new Error(\"Transport not started\");\n    }\n\n    let websocket: WebSocket | null = null;\n\n    if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n      websocket = this.#getWebSocketForMessageID(message.id.toString());\n      if (!websocket) {\n        throw new Error(\n          `Could not find WebSocket for message id: ${message.id}`\n        );\n      }\n    } else if (isJSONRPCRequest(message)) {\n      // requests originating from the server must be sent over the\n      // the connection created by a GET request\n      websocket = this.#getWebSocketForGetRequest();\n    } else if (isJSONRPCNotification(message)) {\n      // notifications do not have an id\n      // but do have a relatedRequestId field\n      // so that they can be sent to the correct connection\n      websocket = null;\n    }\n\n    try {\n      websocket?.send(JSON.stringify(message));\n      if (isJSONRPCResponse(message)) {\n        this.#notifyResponseIdSent(message.id.toString());\n      }\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n\n  async close() {\n    // Similar to start, the only thing to do is to pass the event on to the server\n    this.onclose?.();\n  }\n}\n\ntype MaybePromise<T> = T | Promise<T>;\n\nexport abstract class McpAgent<\n  Env = unknown,\n  State = unknown,\n  Props extends Record<string, unknown> = Record<string, unknown>,\n> extends DurableObject<Env> {\n  #status: \"zero\" | \"starting\" | \"started\" = \"zero\";\n  #transport?: Transport;\n  #transportType: TransportType = \"unset\";\n  #requestIdToConnectionId: Map<string | number, string> = new Map();\n\n  /**\n   * Since McpAgent's _aren't_ yet real \"Agents\", let's only expose a couple of the methods\n   * to the outer class: initialState/state/setState/onStateUpdate/sql\n   */\n  #agent: Agent<Env, State>;\n\n  get mcp() {\n    return this.#agent.mcp;\n  }\n\n  protected constructor(ctx: DurableObjectState, env: Env) {\n    super(ctx, env);\n    const self = this;\n\n    this.#agent = new (class extends Agent<Env, State> {\n      static options = {\n        hibernate: true,\n      };\n\n      onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n        return self.onStateUpdate(state, source);\n      }\n\n      async onMessage(\n        connection: Connection,\n        message: WSMessage\n      ): Promise<void> {\n        return self.onMessage(connection, message);\n      }\n    })(ctx, env);\n  }\n\n  /**\n   * Agents API allowlist\n   */\n  initialState!: State;\n  get state() {\n    return this.#agent.state;\n  }\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ) {\n    return this.#agent.sql<T>(strings, ...values);\n  }\n\n  setState(state: State) {\n    return this.#agent.setState(state);\n  }\n  onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n    // override this to handle state updates\n  }\n  async onStart() {\n    const self = this;\n\n    this.#agent = new (class extends Agent<Env, State> {\n      initialState: State = self.initialState;\n      static options = {\n        hibernate: true,\n      };\n\n      onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n        return self.onStateUpdate(state, source);\n      }\n\n      async onMessage(connection: Connection, event: WSMessage) {\n        return self.onMessage(connection, event);\n      }\n    })(this.ctx, this.env);\n\n    this.props = (await this.ctx.storage.get(\"props\")) as Props;\n    this.#transportType = (await this.ctx.storage.get(\n      \"transportType\"\n    )) as TransportType;\n    await this._init(this.props);\n\n    const server = await this.server;\n\n    // Connect to the MCP server\n    if (this.#transportType === \"sse\") {\n      this.#transport = new McpSSETransport(() => this.getWebSocket());\n      await server.connect(this.#transport);\n    } else if (this.#transportType === \"streamable-http\") {\n      this.#transport = new McpStreamableHttpTransport(\n        (id) => this.getWebSocketForResponseID(id),\n        (id) => this.#requestIdToConnectionId.delete(id)\n      );\n      await server.connect(this.#transport);\n    }\n  }\n\n  /**\n   * McpAgent API\n   */\n  abstract server: MaybePromise<McpServer | Server>;\n  props!: Props;\n  initRun = false;\n\n  abstract init(): Promise<void>;\n\n  async _init(props: Props) {\n    await this.ctx.storage.put(\"props\", props ?? {});\n    if (!this.ctx.storage.get(\"transportType\")) {\n      await this.ctx.storage.put(\"transportType\", \"unset\");\n    }\n    this.props = props;\n    if (!this.initRun) {\n      this.initRun = true;\n      await this.init();\n    }\n  }\n\n  async setInitialized() {\n    await this.ctx.storage.put(\"initialized\", true);\n  }\n\n  async isInitialized() {\n    return (await this.ctx.storage.get(\"initialized\")) === true;\n  }\n\n  async #initialize(): Promise<void> {\n    await this.ctx.blockConcurrencyWhile(async () => {\n      this.#status = \"starting\";\n      await this.onStart();\n      this.#status = \"started\";\n    });\n  }\n\n  // Allow the worker to fetch a websocket connection to the agent\n  async fetch(request: Request): Promise<Response> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n\n    // Only handle WebSocket upgrade requests\n    if (request.headers.get(\"Upgrade\") !== \"websocket\") {\n      return new Response(\"Expected WebSocket Upgrade request\", {\n        status: 400,\n      });\n    }\n\n    // This request does not come from the user. The worker generates this\n    // request to generate a websocket connection to the agent.\n    const url = new URL(request.url);\n    // This is not the path that the user requested, but the path that the worker\n    // generated. We'll use this path to determine which transport to use.\n    const path = url.pathname;\n    const server = await this.server;\n\n    switch (path) {\n      case \"/sse\": {\n        // For SSE connections, we can only have one open connection per session\n        // If we get an upgrade while already connected, we should error\n        const websockets = this.ctx.getWebSockets();\n        if (websockets.length > 0) {\n          return new Response(\"Websocket already connected\", { status: 400 });\n        }\n\n        // This session must always use the SSE transporo\n        await this.ctx.storage.put(\"transportType\", \"sse\");\n        this.#transportType = \"sse\";\n\n        if (!this.#transport) {\n          this.#transport = new McpSSETransport(() => this.getWebSocket());\n          await server.connect(this.#transport);\n        }\n\n        // Defer to the Agent's fetch method to handle the WebSocket connection\n        return this.#agent.fetch(request);\n      }\n      case \"/streamable-http\": {\n        if (!this.#transport) {\n          this.#transport = new McpStreamableHttpTransport(\n            (id) => this.getWebSocketForResponseID(id),\n            (id) => this.#requestIdToConnectionId.delete(id)\n          );\n          await server.connect(this.#transport);\n        }\n\n        // This session must always use the streamable-http transport\n        await this.ctx.storage.put(\"transportType\", \"streamable-http\");\n        this.#transportType = \"streamable-http\";\n\n        return this.#agent.fetch(request);\n      }\n      default:\n        return new Response(\n          \"Internal Server Error: Expected /sse or /streamable-http path\",\n          {\n            status: 500,\n          }\n        );\n    }\n  }\n\n  getWebSocket() {\n    const websockets = this.ctx.getWebSockets();\n    if (websockets.length === 0) {\n      return null;\n    }\n    return websockets[0];\n  }\n\n  getWebSocketForResponseID(id: string): WebSocket | null {\n    const connectionId = this.#requestIdToConnectionId.get(id);\n    if (connectionId === undefined) {\n      return null;\n    }\n    return this.#agent.getConnection(connectionId) ?? null;\n  }\n\n  // All messages received here. This is currently never called\n  async onMessage(connection: Connection, event: WSMessage) {\n    // Since we address the DO via both the protocol and the session id,\n    // this should never happen, but let's enforce it just in case\n    if (this.#transportType !== \"streamable-http\") {\n      const err = new Error(\n        \"Internal Server Error: Expected streamable-http protocol\"\n      );\n      this.#transport?.onerror?.(err);\n      return;\n    }\n\n    let message: JSONRPCMessage;\n    try {\n      // Ensure event is a string\n      const data =\n        typeof event === \"string\" ? event : new TextDecoder().decode(event);\n      message = JSONRPCMessageSchema.parse(JSON.parse(data));\n    } catch (error) {\n      this.#transport?.onerror?.(error as Error);\n      return;\n    }\n\n    // We need to map every incoming message to the connection that it came in on\n    // so that we can send relevant responses and notifications back on the same connection\n    if (isJSONRPCRequest(message)) {\n      this.#requestIdToConnectionId.set(message.id.toString(), connection.id);\n    }\n\n    this.#transport?.onmessage?.(message);\n  }\n\n  // All messages received over SSE after the initial connection has been established\n  // will be passed here\n  async onSSEMcpMessage(\n    sessionId: string,\n    request: Request\n  ): Promise<Error | null> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n\n    // Since we address the DO via both the protocol and the session id,\n    // this should never happen, but let's enforce it just in case\n    if (this.#transportType !== \"sse\") {\n      return new Error(\"Internal Server Error: Expected SSE protocol\");\n    }\n\n    try {\n      const message = await request.json();\n      let parsedMessage: JSONRPCMessage;\n      try {\n        parsedMessage = JSONRPCMessageSchema.parse(message);\n      } catch (error) {\n        this.#transport?.onerror?.(error as Error);\n        throw error;\n      }\n\n      this.#transport?.onmessage?.(parsedMessage);\n      return null;\n    } catch (error) {\n      console.error(\"Error forwarding message to SSE:\", error);\n      this.#transport?.onerror?.(error as Error);\n      return error as Error;\n    }\n  }\n\n  // Delegate all websocket events to the underlying agent\n  async webSocketMessage(\n    ws: WebSocket,\n    event: ArrayBuffer | string\n  ): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return await this.#agent.webSocketMessage(ws, event);\n  }\n\n  // WebSocket event handlers for hibernation support\n  async webSocketError(ws: WebSocket, error: unknown): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return await this.#agent.webSocketError(ws, error);\n  }\n\n  async webSocketClose(\n    ws: WebSocket,\n    code: number,\n    reason: string,\n    wasClean: boolean\n  ): Promise<void> {\n    if (this.#status !== \"started\") {\n      // This means the server \"woke up\" after hibernation\n      // so we need to hydrate it again\n      await this.#initialize();\n    }\n    return await this.#agent.webSocketClose(ws, code, reason, wasClean);\n  }\n\n  static mount(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n    }: {\n      binding?: string;\n      corsOptions?: CORSOptions;\n    } = {}\n  ) {\n    return McpAgent.serveSSE(path, { binding, corsOptions });\n  }\n\n  static serveSSE(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n    }: {\n      binding?: string;\n      corsOptions?: CORSOptions;\n    } = {}\n  ) {\n    let pathname = path;\n    if (path === \"/\") {\n      pathname = \"/*\";\n    }\n    const basePattern = new URLPattern({ pathname });\n    const messagePattern = new URLPattern({ pathname: `${pathname}/message` });\n\n    return {\n      async fetch<Env>(\n        this: void,\n        request: Request,\n        env: Env,\n        ctx: ExecutionContext\n      ): Promise<Response> {\n        // Handle CORS preflight\n        const corsResponse = handleCORS(request, corsOptions);\n        if (corsResponse) return corsResponse;\n\n        const url = new URL(request.url);\n        const bindingValue = env[binding as keyof typeof env] as unknown;\n\n        // Ensure we have a binding of some sort\n        if (bindingValue == null || typeof bindingValue !== \"object\") {\n          console.error(\n            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`\n          );\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        // Ensure that the biding is to a DurableObject\n        if (bindingValue.toString() !== \"[object DurableObjectNamespace]\") {\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        const namespace = bindingValue as DurableObjectNamespace<McpAgent>;\n\n        // Handle initial SSE connection\n        if (request.method === \"GET\" && basePattern.test(url)) {\n          // Use a session ID if one is passed in, or create a unique\n          // session ID for this connection\n          const sessionId =\n            url.searchParams.get(\"sessionId\") ||\n            namespace.newUniqueId().toString();\n\n          // Create a Transform Stream for SSE\n          const { readable, writable } = new TransformStream();\n          const writer = writable.getWriter();\n          const encoder = new TextEncoder();\n\n          // Send the endpoint event\n          const endpointUrl = new URL(request.url);\n          endpointUrl.pathname = encodeURI(`${pathname}/message`);\n          endpointUrl.searchParams.set(\"sessionId\", sessionId);\n          const relativeUrlWithSession =\n            endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;\n          const endpointMessage = `event: endpoint\\ndata: ${relativeUrlWithSession}\\n\\n`;\n          writer.write(encoder.encode(endpointMessage));\n\n          // Get the Durable Object\n          const id = namespace.idFromName(`sse:${sessionId}`);\n          const doStub = namespace.get(id);\n\n          // Initialize the object\n          await doStub._init(ctx.props);\n\n          // Connect to the Durable Object via WebSocket\n          const upgradeUrl = new URL(request.url);\n          // enforce that the path that the DO receives is always /sse\n          upgradeUrl.pathname = \"/sse\";\n          const response = await doStub.fetch(\n            new Request(upgradeUrl, {\n              headers: {\n                Upgrade: \"websocket\",\n                // Required by PartyServer\n                \"x-partykit-room\": sessionId,\n              },\n            })\n          );\n\n          // Get the WebSocket\n          const ws = response.webSocket;\n          if (!ws) {\n            console.error(\"Failed to establish WebSocket connection\");\n            await writer.close();\n            return new Response(\"Failed to establish WebSocket connection\", {\n              status: 500,\n            });\n          }\n\n          // Accept the WebSocket\n          ws.accept();\n\n          // Handle messages from the Durable Object\n          ws.addEventListener(\"message\", (event) => {\n            async function onMessage(event: MessageEvent) {\n              try {\n                const message = JSON.parse(event.data);\n\n                // validate that the message is a valid JSONRPC message\n                const result = JSONRPCMessageSchema.safeParse(message);\n                if (!result.success) {\n                  // The message was not a valid JSONRPC message, so we will drop it\n                  // PartyKit will broadcast state change messages to all connected clients\n                  // and we need to filter those out so they are not passed to MCP clients\n                  return;\n                }\n\n                // Send the message as an SSE event\n                const messageText = `event: message\\ndata: ${JSON.stringify(result.data)}\\n\\n`;\n                await writer.write(encoder.encode(messageText));\n              } catch (error) {\n                console.error(\"Error forwarding message to SSE:\", error);\n              }\n            }\n            onMessage(event).catch(console.error);\n          });\n\n          // Handle WebSocket errors\n          ws.addEventListener(\"error\", (error) => {\n            async function onError(error: Event) {\n              try {\n                await writer.close();\n              } catch (e) {\n                // Ignore errors when closing\n              }\n            }\n            onError(error).catch(console.error);\n          });\n\n          // Handle WebSocket closure\n          ws.addEventListener(\"close\", () => {\n            async function onClose() {\n              try {\n                await writer.close();\n              } catch (error) {\n                console.error(\"Error closing SSE connection:\", error);\n              }\n            }\n            onClose().catch(console.error);\n          });\n\n          // Return the SSE response\n          return new Response(readable, {\n            headers: {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache\",\n              Connection: \"keep-alive\",\n              ...corsHeaders(request, corsOptions),\n            },\n          });\n        }\n\n        // Handle incoming MCP messages. These will be passed to McpAgent\n        // but the response will be sent back via the open SSE connection\n        // so we only need to return a 202 Accepted response for success\n        if (request.method === \"POST\" && messagePattern.test(url)) {\n          const sessionId = url.searchParams.get(\"sessionId\");\n          if (!sessionId) {\n            return new Response(\n              `Missing sessionId. Expected POST to ${pathname} to initiate new one`,\n              { status: 400 }\n            );\n          }\n\n          const contentType = request.headers.get(\"content-type\") || \"\";\n          if (!contentType.includes(\"application/json\")) {\n            return new Response(`Unsupported content-type: ${contentType}`, {\n              status: 400,\n            });\n          }\n\n          // check if the request body is too large\n          const contentLength = Number.parseInt(\n            request.headers.get(\"content-length\") || \"0\",\n            10\n          );\n          if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {\n            return new Response(\n              `Request body too large: ${contentLength} bytes`,\n              {\n                status: 400,\n              }\n            );\n          }\n\n          // Get the Durable Object\n          const id = namespace.idFromName(`sse:${sessionId}`);\n          const doStub = namespace.get(id);\n\n          // Forward the request to the Durable Object\n          const error = await doStub.onSSEMcpMessage(sessionId, request);\n\n          if (error) {\n            return new Response(error.message, {\n              status: 400,\n              headers: {\n                \"Content-Type\": \"text/event-stream\",\n                \"Cache-Control\": \"no-cache\",\n                Connection: \"keep-alive\",\n                ...corsHeaders(request, corsOptions),\n              },\n            });\n          }\n\n          return new Response(\"Accepted\", {\n            status: 202,\n            headers: {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache\",\n              Connection: \"keep-alive\",\n              ...corsHeaders(request, corsOptions),\n            },\n          });\n        }\n\n        return new Response(\"Not Found\", { status: 404 });\n      },\n    };\n  }\n\n  static serve(\n    path: string,\n    {\n      binding = \"MCP_OBJECT\",\n      corsOptions,\n    }: { binding?: string; corsOptions?: CORSOptions } = {}\n  ) {\n    let pathname = path;\n    if (path === \"/\") {\n      pathname = \"/*\";\n    }\n    const basePattern = new URLPattern({ pathname });\n\n    return {\n      async fetch<Env>(\n        this: void,\n        request: Request,\n        env: Env,\n        ctx: ExecutionContext\n      ): Promise<Response> {\n        // Handle CORS preflight\n        const corsResponse = handleCORS(request, corsOptions);\n        if (corsResponse) {\n          return corsResponse;\n        }\n\n        const url = new URL(request.url);\n        const bindingValue = env[binding as keyof typeof env] as unknown;\n\n        // Ensure we have a binding of some sort\n        if (bindingValue == null || typeof bindingValue !== \"object\") {\n          console.error(\n            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`\n          );\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        // Ensure that the biding is to a DurableObject\n        if (bindingValue.toString() !== \"[object DurableObjectNamespace]\") {\n          return new Response(\"Invalid binding\", { status: 500 });\n        }\n\n        const namespace = bindingValue as DurableObjectNamespace<McpAgent>;\n\n        if (request.method === \"POST\" && basePattern.test(url)) {\n          // validate the Accept header\n          const acceptHeader = request.headers.get(\"accept\");\n          // The client MUST include an Accept header, listing both application/json and text/event-stream as supported content types.\n          if (\n            !acceptHeader?.includes(\"application/json\") ||\n            !acceptHeader.includes(\"text/event-stream\")\n          ) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message:\n                  \"Not Acceptable: Client must accept both application/json and text/event-stream\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 406 });\n          }\n\n          const ct = request.headers.get(\"content-type\");\n          if (!ct || !ct.includes(\"application/json\")) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message:\n                  \"Unsupported Media Type: Content-Type must be application/json\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 415 });\n          }\n\n          // Check content length against maximum allowed size\n          const contentLength = Number.parseInt(\n            request.headers.get(\"content-length\") ?? \"0\",\n            10\n          );\n          if (contentLength > MAXIMUM_MESSAGE_SIZE_BYTES) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message: `Request body too large. Maximum size is ${MAXIMUM_MESSAGE_SIZE_BYTES} bytes`,\n              },\n              id: null,\n            });\n            return new Response(body, { status: 413 });\n          }\n\n          let sessionId = request.headers.get(\"mcp-session-id\");\n          let rawMessage: unknown;\n\n          try {\n            rawMessage = await request.json();\n          } catch (error) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32700,\n                message: \"Parse error: Invalid JSON\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // Make sure the message is an array to simplify logic\n          let arrayMessage: unknown[];\n          if (Array.isArray(rawMessage)) {\n            arrayMessage = rawMessage;\n          } else {\n            arrayMessage = [rawMessage];\n          }\n\n          let messages: JSONRPCMessage[] = [];\n\n          // Try to parse each message as JSON RPC. Fail if any message is invalid\n          for (const msg of arrayMessage) {\n            if (!JSONRPCMessageSchema.safeParse(msg).success) {\n              const body = JSON.stringify({\n                jsonrpc: \"2.0\",\n                error: {\n                  code: -32700,\n                  message: \"Parse error: Invalid JSON-RPC message\",\n                },\n                id: null,\n              });\n              return new Response(body, { status: 400 });\n            }\n          }\n\n          messages = arrayMessage.map((msg) => JSONRPCMessageSchema.parse(msg));\n\n          // Before we pass the messages to the agent, there's another error condition we need to enforce\n          // Check if this is an initialization request\n          // https://spec.modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle/\n          const isInitializationRequest = messages.some(\n            (msg) => InitializeRequestSchema.safeParse(msg).success\n          );\n\n          if (isInitializationRequest && sessionId) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32600,\n                message:\n                  \"Invalid Request: Initialization requests must not include a sessionId\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // The initialization request must be the only request in the batch\n          if (isInitializationRequest && messages.length > 1) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32600,\n                message:\n                  \"Invalid Request: Only one initialization request is allowed\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // If an Mcp-Session-Id is returned by the server during initialization,\n          // clients using the Streamable HTTP transport MUST include it\n          // in the Mcp-Session-Id header on all of their subsequent HTTP requests.\n          if (!isInitializationRequest && !sessionId) {\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32000,\n                message: \"Bad Request: Mcp-Session-Id header is required\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 400 });\n          }\n\n          // If we don't have a sessionId, we are serving an initialization request\n          // and need to generate a new sessionId\n          sessionId = sessionId ?? namespace.newUniqueId().toString();\n\n          // fetch the agent DO\n          const id = namespace.idFromName(`streamable-http:${sessionId}`);\n          const doStub = namespace.get(id);\n          const isInitialized = await doStub.isInitialized();\n\n          if (isInitializationRequest) {\n            await doStub._init(ctx.props);\n            await doStub.setInitialized();\n          } else if (!isInitialized) {\n            // if we have gotten here, then a session id that was never initialized\n            // was provided\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32001,\n                message: \"Session not found\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 404 });\n          }\n\n          // We've evaluated all the error conditions! Now it's time to establish\n          // all the streams\n\n          // Create a Transform Stream for SSE\n          const { readable, writable } = new TransformStream();\n          const writer = writable.getWriter();\n          const encoder = new TextEncoder();\n\n          // Connect to the Durable Object via WebSocket\n          const upgradeUrl = new URL(request.url);\n          upgradeUrl.pathname = \"/streamable-http\";\n          const response = await doStub.fetch(\n            new Request(upgradeUrl, {\n              headers: {\n                Upgrade: \"websocket\",\n                // Required by PartyServer\n                \"x-partykit-room\": sessionId,\n              },\n            })\n          );\n\n          // Get the WebSocket\n          const ws = response.webSocket;\n          if (!ws) {\n            console.error(\"Failed to establish WebSocket connection\");\n\n            await writer.close();\n            const body = JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32001,\n                message: \"Failed to establish WebSocket connection\",\n              },\n              id: null,\n            });\n            return new Response(body, { status: 500 });\n          }\n\n          // Keep track of the request ids that we have sent to the server\n          // so that we can close the connection once we have received\n          // all the responses\n          const requestIds: Set<string | number> = new Set();\n\n          // Accept the WebSocket\n          ws.accept();\n\n          // Handle messages from the Durable Object\n          ws.addEventListener(\"message\", (event) => {\n            async function onMessage(event: MessageEvent) {\n              try {\n                const data =\n                  typeof event.data === \"string\"\n                    ? event.data\n                    : new TextDecoder().decode(event.data);\n                const message = JSON.parse(data);\n\n                // validate that the message is a valid JSONRPC message\n                const result = JSONRPCMessageSchema.safeParse(message);\n                if (!result.success) {\n                  // The message was not a valid JSONRPC message, so we will drop it\n                  // PartyKit will broadcast state change messages to all connected clients\n                  // and we need to filter those out so they are not passed to MCP clients\n                  return;\n                }\n\n                // If the message is a response or an error, remove the id from the set of\n                // request ids\n                if (\n                  isJSONRPCResponse(result.data) ||\n                  isJSONRPCError(result.data)\n                ) {\n                  requestIds.delete(result.data.id);\n                }\n\n                // Send the message as an SSE event\n                const messageText = `event: message\\ndata: ${JSON.stringify(result.data)}\\n\\n`;\n                await writer.write(encoder.encode(messageText));\n\n                // If we have received all the responses, close the connection\n                if (requestIds.size === 0) {\n                  ws!.close();\n                }\n              } catch (error) {\n                console.error(\"Error forwarding message to SSE:\", error);\n              }\n            }\n            onMessage(event).catch(console.error);\n          });\n\n          // Handle WebSocket errors\n          ws.addEventListener(\"error\", (error) => {\n            async function onError(error: Event) {\n              try {\n                await writer.close();\n              } catch (e) {\n                // Ignore errors when closing\n              }\n            }\n            onError(error).catch(console.error);\n          });\n\n          // Handle WebSocket closure\n          ws.addEventListener(\"close\", () => {\n            async function onClose() {\n              try {\n                await writer.close();\n              } catch (error) {\n                console.error(\"Error closing SSE connection:\", error);\n              }\n            }\n            onClose().catch(console.error);\n          });\n\n          // If there are no requests, we send the messages to the agent and acknowledge the request with a 202\n          // since we don't expect any responses back through this connection\n          const hasOnlyNotificationsOrResponses = messages.every(\n            (msg) => isJSONRPCNotification(msg) || isJSONRPCResponse(msg)\n          );\n          if (hasOnlyNotificationsOrResponses) {\n            for (const message of messages) {\n              ws.send(JSON.stringify(message));\n            }\n\n            // closing the websocket will also close the SSE connection\n            ws.close();\n\n            return new Response(null, {\n              status: 202,\n              headers: corsHeaders(request, corsOptions),\n            });\n          }\n\n          for (const message of messages) {\n            if (isJSONRPCRequest(message)) {\n              // add each request id that we send off to a set\n              // so that we can keep track of which requests we\n              // still need a response for\n              requestIds.add(message.id);\n            }\n            ws.send(JSON.stringify(message));\n          }\n\n          // Return the SSE response. We handle closing the stream in the ws \"message\"\n          // handler\n          return new Response(readable, {\n            headers: {\n              \"Content-Type\": \"text/event-stream\",\n              \"Cache-Control\": \"no-cache\",\n              Connection: \"keep-alive\",\n              \"mcp-session-id\": sessionId,\n              ...corsHeaders(request, corsOptions),\n            },\n            status: 200,\n          });\n        }\n\n        // We don't yet support GET or DELETE requests\n        const body = JSON.stringify({\n          jsonrpc: \"2.0\",\n          error: {\n            code: -32000,\n            message: \"Method not allowed\",\n          },\n          id: null,\n        });\n        return new Response(body, { status: 405 });\n      },\n    };\n  }\n}\n", null, null, null, null, "import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\r\nimport { z } from \"zod\";\r\nimport { getFunctionCategory } from \"./rhino-script-categories\";\r\nimport { sendRhinoCommand } from \"./index\";\r\nimport type { Env } from \"./index\";\r\n\r\n// Define the Rhino tools class\r\nexport class RhinoTools {\r\n  constructor(private server: McpServer) {\r\n    this.initializeTools();\r\n  }\r\n\r\n  private initializeTools() {\r\n    // Get Rhino scene info\r\n    this.server.tool(\r\n      \"get_rhino_scene_info\",\r\n      \"Get basic information about the current Rhino scene\",\r\n      async (extra) => {\r\n        const result = await sendRhinoCommand(\r\n          extra.requestId as unknown as Env,\r\n          \"get_rhino_scene_info\"\r\n        );\r\n        return {\r\n          content: [{ type: \"text\", text: JSON.stringify(result, null, 2) }],\r\n        };\r\n      }\r\n    );\r\n\r\n    // Get Rhino layers\r\n    this.server.tool(\r\n      \"get_rhino_layers\",\r\n      \"Get list of layers in Rhino\",\r\n      async (extra) => {\r\n        const result = await sendRhinoCommand(\r\n          extra.requestId as unknown as Env,\r\n          \"get_rhino_layers\"\r\n        );\r\n        return {\r\n          content: [{ type: \"text\", text: JSON.stringify(result, null, 2) }],\r\n        };\r\n      }\r\n    );\r\n\r\n    // Get Rhino objects with metadata\r\n    this.server.tool(\r\n      \"get_rhino_objects_with_metadata\",\r\n      {\r\n        filters: z.record(z.any()).optional(),\r\n        metadata_fields: z.array(z.string()).optional(),\r\n      },\r\n      async (args, extra) => {\r\n        const result = await sendRhinoCommand(\r\n          extra.requestId as unknown as Env,\r\n          \"get_rhino_objects_with_metadata\",\r\n          {\r\n            filters: args.filters || {},\r\n            metadata_fields: args.metadata_fields,\r\n          }\r\n        );\r\n        return {\r\n          content: [{ type: \"text\", text: JSON.stringify(result, null, 2) }],\r\n        };\r\n      }\r\n    );\r\n\r\n    // Capture Rhino viewport\r\n    this.server.tool(\r\n      \"capture_rhino_viewport\",\r\n      {\r\n        layer: z.string().optional(),\r\n        show_annotations: z.boolean().optional(),\r\n        max_size: z.number().optional(),\r\n      },\r\n      async (args: any, extra: any) => {\r\n        const result = await sendRhinoCommand(\r\n          extra.requestId as unknown as Env,\r\n          \"capture_rhino_viewport\",\r\n          {\r\n            layer: args.layer,\r\n            show_annotations: args.show_annotations,\r\n            max_size: args.max_size,\r\n          }\r\n        );\r\n\r\n        if (result.type === \"image\") {\r\n          return {\r\n            content: [\r\n              {\r\n                type: \"image\",\r\n                data: result.source.data,\r\n                mimeType: \"image/jpeg\",\r\n              },\r\n            ],\r\n          };\r\n        }\r\n\r\n        throw new Error(result.text || \"Failed to capture viewport\");\r\n      }\r\n    );\r\n\r\n    // Execute Rhino code\r\n    this.server.tool(\r\n      \"execute_rhino_code\",\r\n      {\r\n        code: z.string(),\r\n      },\r\n      async (args: any, extra: any) => {\r\n        const result = await sendRhinoCommand(\r\n          extra.requestId as unknown as Env,\r\n          \"execute_code\",\r\n          { code: args.code }\r\n        );\r\n\r\n        if (result.status === \"error\") {\r\n          const errorMsg = `Error: ${result.message}`;\r\n          const printedOutput = result.printed_output || [];\r\n          return {\r\n            content: [\r\n              {\r\n                type: \"text\",\r\n                text:\r\n                  printedOutput.length > 0\r\n                    ? `${errorMsg}\\n\\nPrinted output before error:\\n${printedOutput.join(\r\n                        \"\\n\"\r\n                      )}`\r\n                    : errorMsg,\r\n              },\r\n            ],\r\n          };\r\n        }\r\n\r\n        const response = result.result || \"Code executed successfully\";\r\n        const printedOutput = result.printed_output || [];\r\n        return {\r\n          content: [\r\n            {\r\n              type: \"text\",\r\n              text:\r\n                printedOutput.length > 0\r\n                  ? `${response}\\n\\nPrinted output:\\n${printedOutput.join(\r\n                      \"\\n\"\r\n                    )}`\r\n                  : response,\r\n            },\r\n          ],\r\n        };\r\n      }\r\n    );\r\n\r\n    // Get selected Rhino objects\r\n    this.server.tool(\r\n      \"get_rhino_selected_objects\",\r\n      {\r\n        include_lights: z.boolean().optional(),\r\n        include_grips: z.boolean().optional(),\r\n      },\r\n      async (args: any, extra: any) => {\r\n        const result = await sendRhinoCommand(\r\n          extra.requestId as unknown as Env,\r\n          \"get_rhino_selected_objects\",\r\n          {\r\n            include_lights: args.include_lights,\r\n            include_grips: args.include_grips,\r\n          }\r\n        );\r\n        return {\r\n          content: [{ type: \"text\", text: JSON.stringify(result, null, 2) }],\r\n        };\r\n      }\r\n    );\r\n\r\n    // Look up RhinoScriptSyntax documentation\r\n    this.server.tool(\r\n      \"look_up_RhinoScriptSyntax\",\r\n      {\r\n        function_name: z.string(),\r\n      },\r\n      async (args: any, extra: any) => {\r\n        // Get the category for the function\r\n        const category = getFunctionCategory(args.function_name);\r\n        if (!category) {\r\n          return {\r\n            content: [\r\n              {\r\n                type: \"text\",\r\n                text: `Function '${args.function_name}' not found in RhinoScriptSyntax categories`,\r\n              },\r\n            ],\r\n          };\r\n        }\r\n\r\n        const result = await sendRhinoCommand(\r\n          extra.requestId as unknown as Env,\r\n          \"look_up_RhinoScriptSyntax\",\r\n          {\r\n            function_name: args.function_name,\r\n            category,\r\n          }\r\n        );\r\n        return {\r\n          content: [{ type: \"text\", text: JSON.stringify(result) }],\r\n        };\r\n      }\r\n    );\r\n  }\r\n}\r\n", "/**\r\n * Maps RhinoScriptSyntax functions to their categories\r\n */\r\n\r\nexport function getFunctionCategory(functionName: string): string | null {\r\n  if (functionName in FUNCTION_CATEGORY_MAP) {\r\n    return FUNCTION_CATEGORY_MAP[functionName];\r\n  }\r\n  return null;\r\n}\r\n\r\n// Dictionary mapping function names to their categories\r\nexport const FUNCTION_CATEGORY_MAP: { [key: string]: string } = {\r\n  // application\r\n  AddAlias: \"application\",\r\n  AddSearchPath: \"application\",\r\n  AliasCount: \"application\",\r\n  AliasMacro: \"application\",\r\n  AliasNames: \"application\",\r\n  AppearanceColor: \"application\",\r\n  AutosaveFile: \"application\",\r\n  AutosaveInterval: \"application\",\r\n  BuildDate: \"application\",\r\n  ClearCommandHistory: \"application\",\r\n  Command: \"application\",\r\n  CommandHistory: \"application\",\r\n  DefaultRenderer: \"application\",\r\n  DeleteAlias: \"application\",\r\n  DeleteSearchPath: \"application\",\r\n  DisplayOleAlerts: \"application\",\r\n  EdgeAnalysisColor: \"application\",\r\n  EdgeAnalysisMode: \"application\",\r\n  EnableAutosave: \"application\",\r\n  EnablePlugIn: \"application\",\r\n  ExeFolder: \"application\",\r\n  ExePlatform: \"application\",\r\n  ExeServiceRelease: \"application\",\r\n  ExeVersion: \"application\",\r\n  Exit: \"application\",\r\n  FindFile: \"application\",\r\n  GetPlugInObject: \"application\",\r\n  InCommand: \"application\",\r\n  InstallFolder: \"application\",\r\n  IsAlias: \"application\",\r\n  IsCommand: \"application\",\r\n  IsPlugIn: \"application\",\r\n  IsRunningOnWindows: \"application\",\r\n  LastCommandName: \"application\",\r\n  LastCommandResult: \"application\",\r\n  LocaleID: \"application\",\r\n  Ortho: \"application\",\r\n  Osnap: \"application\",\r\n  OsnapDialog: \"application\",\r\n  OsnapMode: \"application\",\r\n  Planar: \"application\",\r\n  PlugInId: \"application\",\r\n  PlugIns: \"application\",\r\n  ProjectOsnaps: \"application\",\r\n  Prompt: \"application\",\r\n  ScreenSize: \"application\",\r\n  SdkVersion: \"application\",\r\n  SearchPathCount: \"application\",\r\n  SearchPathList: \"application\",\r\n  SendKeystrokes: \"application\",\r\n  Snap: \"application\",\r\n  StatusBarDistance: \"application\",\r\n  StatusBarMessage: \"application\",\r\n  StatusBarPoint: \"application\",\r\n  StatusBarProgressMeterShow: \"application\",\r\n  StatusBarProgressMeterUpdate: \"application\",\r\n  StatusBarProgressMeterHide: \"application\",\r\n  TemplateFile: \"application\",\r\n  TemplateFolder: \"application\",\r\n  WindowHandle: \"application\",\r\n  WorkingFolder: \"application\",\r\n\r\n  // block\r\n  AddBlock: \"block\",\r\n  BlockContainerCount: \"block\",\r\n  BlockContainers: \"block\",\r\n  BlockCount: \"block\",\r\n  BlockDescription: \"block\",\r\n  BlockInstanceCount: \"block\",\r\n  BlockInstanceInsertPoint: \"block\",\r\n  BlockInstanceName: \"block\",\r\n  BlockInstances: \"block\",\r\n  BlockInstanceXform: \"block\",\r\n  BlockNames: \"block\",\r\n  BlockObjectCount: \"block\",\r\n  BlockObjects: \"block\",\r\n  BlockPath: \"block\",\r\n  BlockStatus: \"block\",\r\n  DeleteBlock: \"block\",\r\n  ExplodeBlockInstance: \"block\",\r\n  InsertBlock: \"block\",\r\n  InsertBlock2: \"block\",\r\n  IsBlock: \"block\",\r\n  IsBlockEmbedded: \"block\",\r\n  IsBlockInstance: \"block\",\r\n  IsBlockInUse: \"block\",\r\n  IsBlockReference: \"block\",\r\n  RenameBlock: \"block\",\r\n\r\n  // curve\r\n  AddArc: \"curve\",\r\n  AddArc3Pt: \"curve\",\r\n  AddArcPtTanPt: \"curve\",\r\n  AddBlendCurve: \"curve\",\r\n  AddCircle: \"curve\",\r\n  AddCircle3Pt: \"curve\",\r\n  AddCurve: \"curve\",\r\n  AddEllipse: \"curve\",\r\n  AddEllipse3Pt: \"curve\",\r\n  AddFilletCurve: \"curve\",\r\n  AddInterpCrvOnSrf: \"curve\",\r\n  AddInterpCrvOnSrfUV: \"curve\",\r\n  AddInterpCurve: \"curve\",\r\n  AddLine: \"curve\",\r\n  AddNurbsCurve: \"curve\",\r\n  AddPolyline: \"curve\",\r\n  AddRectangle: \"curve\",\r\n  AddSpiral: \"curve\",\r\n  AddSubCrv: \"curve\",\r\n  ArcAngle: \"curve\",\r\n  ArcCenterPoint: \"curve\",\r\n  ArcMidPoint: \"curve\",\r\n  ArcRadius: \"curve\",\r\n  CircleCenterPoint: \"curve\",\r\n  CircleCircumference: \"curve\",\r\n  CircleRadius: \"curve\",\r\n  CloseCurve: \"curve\",\r\n  ClosedCurveOrientation: \"curve\",\r\n  ConvertCurveToPolyline: \"curve\",\r\n  CurveArcLengthPoint: \"curve\",\r\n  CurveArea: \"curve\",\r\n  CurveAreaCentroid: \"curve\",\r\n  CurveArrows: \"curve\",\r\n  CurveBooleanDifference: \"curve\",\r\n  CurveBooleanIntersection: \"curve\",\r\n  CurveBooleanUnion: \"curve\",\r\n  CurveBrepIntersect: \"curve\",\r\n  CurveClosestObject: \"curve\",\r\n  CurveClosestPoint: \"curve\",\r\n  CurveContourPoints: \"curve\",\r\n  CurveCurvature: \"curve\",\r\n  CurveCurveIntersection: \"curve\",\r\n  CurveDegree: \"curve\",\r\n  CurveDeviation: \"curve\",\r\n  CurveDim: \"curve\",\r\n  CurveDirectionsMatch: \"curve\",\r\n  CurveDiscontinuity: \"curve\",\r\n  CurveDomain: \"curve\",\r\n  CurveEditPoints: \"curve\",\r\n  CurveEndPoint: \"curve\",\r\n  CurveFilletPoints: \"curve\",\r\n  CurveFrame: \"curve\",\r\n  CurveKnotCount: \"curve\",\r\n  CurveKnots: \"curve\",\r\n  CurveLength: \"curve\",\r\n  CurveMidPoint: \"curve\",\r\n  CurveNormal: \"curve\",\r\n  CurveNormalizedParameter: \"curve\",\r\n  CurveParameter: \"curve\",\r\n  CurvePerpFrame: \"curve\",\r\n  CurvePlane: \"curve\",\r\n  CurvePointCount: \"curve\",\r\n  CurvePoints: \"curve\",\r\n  CurveRadius: \"curve\",\r\n  CurveSeam: \"curve\",\r\n  CurveStartPoint: \"curve\",\r\n  CurveSurfaceIntersection: \"curve\",\r\n  CurveTangent: \"curve\",\r\n  CurveWeights: \"curve\",\r\n  DivideCurve: \"curve\",\r\n  DivideCurveEquidistant: \"curve\",\r\n  DivideCurveLength: \"curve\",\r\n  EllipseCenterPoint: \"curve\",\r\n  EllipseQuadPoints: \"curve\",\r\n  EvaluateCurve: \"curve\",\r\n  ExplodeCurves: \"curve\",\r\n  ExtendCurve: \"curve\",\r\n  ExtendCurveLength: \"curve\",\r\n  ExtendCurvePoint: \"curve\",\r\n  FairCurve: \"curve\",\r\n  FitCurve: \"curve\",\r\n  InsertCurveKnot: \"curve\",\r\n  IsArc: \"curve\",\r\n  IsCircle: \"curve\",\r\n  IsCurve: \"curve\",\r\n  IsCurveClosable: \"curve\",\r\n  IsCurveClosed: \"curve\",\r\n  IsCurveInPlane: \"curve\",\r\n  IsCurveLinear: \"curve\",\r\n  IsCurvePeriodic: \"curve\",\r\n  IsCurvePlanar: \"curve\",\r\n  IsCurveRational: \"curve\",\r\n  IsEllipse: \"curve\",\r\n  IsLine: \"curve\",\r\n  IsPointOnCurve: \"curve\",\r\n  IsPolyCurve: \"curve\",\r\n  IsPolyline: \"curve\",\r\n  JoinCurves: \"curve\",\r\n  LineFitFromPoints: \"curve\",\r\n  MakeCurveNonPeriodic: \"curve\",\r\n  MeanCurve: \"curve\",\r\n  MeshPolyline: \"curve\",\r\n  OffsetCurve: \"curve\",\r\n  OffsetCurveOnSurface: \"curve\",\r\n  PlanarClosedCurveContainment: \"curve\",\r\n  PlanarCurveCollision: \"curve\",\r\n  PointInPlanarClosedCurve: \"curve\",\r\n  PolyCurveCount: \"curve\",\r\n  PolylineVertices: \"curve\",\r\n  ProjectCurveToMesh: \"curve\",\r\n  ProjectCurveToSurface: \"curve\",\r\n  RebuildCurve: \"curve\",\r\n  RemoveCurveKnot: \"curve\",\r\n  ReverseCurve: \"curve\",\r\n  SimplifyCurve: \"curve\",\r\n  SplitCurve: \"curve\",\r\n  TrimCurve: \"curve\",\r\n  ChangeCurveDegree: \"curve\",\r\n  AddTweenCurves: \"curve\",\r\n\r\n  // dimension\r\n  AddAlignedDimension: \"dimension\",\r\n  AddDimStyle: \"dimension\",\r\n  AddLeader: \"dimension\",\r\n  AddLinearDimension: \"dimension\",\r\n  CurrentDimStyle: \"dimension\",\r\n  DeleteDimStyle: \"dimension\",\r\n  DimensionStyle: \"dimension\",\r\n  DimensionText: \"dimension\",\r\n  DimensionUserText: \"dimension\",\r\n  DimensionValue: \"dimension\",\r\n  DimStyleAnglePrecision: \"dimension\",\r\n  DimStyleArrowSize: \"dimension\",\r\n  DimStyleCount: \"dimension\",\r\n  DimStyleExtension: \"dimension\",\r\n  DimStyleFont: \"dimension\",\r\n  DimStyleLeaderArrowSize: \"dimension\",\r\n  DimStyleLengthFactor: \"dimension\",\r\n  DimStyleLinearPrecision: \"dimension\",\r\n  DimStyleNames: \"dimension\",\r\n  DimStyleNumberFormat: \"dimension\",\r\n  DimStyleOffset: \"dimension\",\r\n  DimStylePrefix: \"dimension\",\r\n  DimStyleScale: \"dimension\",\r\n  DimStyleSuffix: \"dimension\",\r\n  DimStyleTextAlignment: \"dimension\",\r\n  DimStyleTextGap: \"dimension\",\r\n  DimStyleTextHeight: \"dimension\",\r\n  IsAlignedDimension: \"dimension\",\r\n  IsAngularDimension: \"dimension\",\r\n  IsDiameterDimension: \"dimension\",\r\n  IsDimension: \"dimension\",\r\n  IsDimStyle: \"dimension\",\r\n  IsDimStyleReference: \"dimension\",\r\n  IsLeader: \"dimension\",\r\n  IsLinearDimension: \"dimension\",\r\n  IsOrdinateDimension: \"dimension\",\r\n  IsRadialDimension: \"dimension\",\r\n  LeaderText: \"dimension\",\r\n  RenameDimStyle: \"dimension\",\r\n\r\n  // document\r\n  CreatePreviewImage: \"document\",\r\n  DocumentModified: \"document\",\r\n  DocumentName: \"document\",\r\n  DocumentPath: \"document\",\r\n  EnableRedraw: \"document\",\r\n  ExtractPreviewImage: \"document\",\r\n  IsDocumentModified: \"document\",\r\n  Notes: \"document\",\r\n  ReadFileVersion: \"document\",\r\n  Redraw: \"document\",\r\n  RenderAntialias: \"document\",\r\n  RenderColor: \"document\",\r\n  RenderResolution: \"document\",\r\n  RenderMeshDensity: \"document\",\r\n  RenderMeshMaxAngle: \"document\",\r\n  RenderMeshMaxAspectRatio: \"document\",\r\n  RenderMeshMaxDistEdgeToSrf: \"document\",\r\n  RenderMeshMaxEdgeLength: \"document\",\r\n  RenderMeshMinEdgeLength: \"document\",\r\n  RenderMeshMinInitialGridQuads: \"document\",\r\n  RenderMeshQuality: \"document\",\r\n  RenderMeshSettings: \"document\",\r\n  RenderSettings: \"document\",\r\n  UnitAbsoluteTolerance: \"document\",\r\n  UnitAngleTolerance: \"document\",\r\n  UnitDistanceDisplayPrecision: \"document\",\r\n  UnitRelativeTolerance: \"document\",\r\n  UnitScale: \"document\",\r\n  UnitSystem: \"document\",\r\n  UnitSystemName: \"document\",\r\n\r\n  // geometry\r\n  AddClippingPlane: \"geometry\",\r\n  AddPictureFrame: \"geometry\",\r\n  AddPoint: \"geometry\",\r\n  AddPointCloud: \"geometry\",\r\n  AddPoints: \"geometry\",\r\n  AddText: \"geometry\",\r\n  AddTextDot: \"geometry\",\r\n  Area: \"geometry\",\r\n  BoundingBox: \"geometry\",\r\n  CompareGeometry: \"geometry\",\r\n  ExplodeText: \"geometry\",\r\n  IsClippingPlane: \"geometry\",\r\n  IsPoint: \"geometry\",\r\n  IsPointCloud: \"geometry\",\r\n  IsText: \"geometry\",\r\n  IsTextDot: \"geometry\",\r\n  PointCloudCount: \"geometry\",\r\n  PointCloudHasHiddenPoints: \"geometry\",\r\n  PointCloudHasPointColors: \"geometry\",\r\n  PointCloudHidePoints: \"geometry\",\r\n  PointCloudPointColors: \"geometry\",\r\n  PointCloudPoints: \"geometry\",\r\n  PointCloudKNeighbors: \"geometry\",\r\n  PointCloudClosestPoints: \"geometry\",\r\n  PointCoordinates: \"geometry\",\r\n  TextDotFont: \"geometry\",\r\n  TextDotHeight: \"geometry\",\r\n  TextDotPoint: \"geometry\",\r\n  TextDotText: \"geometry\",\r\n  TextObjectFont: \"geometry\",\r\n  TextObjectHeight: \"geometry\",\r\n  TextObjectPlane: \"geometry\",\r\n  TextObjectPoint: \"geometry\",\r\n  TextObjectStyle: \"geometry\",\r\n  TextObjectText: \"geometry\",\r\n\r\n  // grips\r\n  EnableObjectGrips: \"grips\",\r\n  GetObjectGrip: \"grips\",\r\n  GetObjectGrips: \"grips\",\r\n  NextObjectGrip: \"grips\",\r\n  ObjectGripCount: \"grips\",\r\n  ObjectGripLocation: \"grips\",\r\n  ObjectGripLocations: \"grips\",\r\n  ObjectGripsOn: \"grips\",\r\n  ObjectGripsSelected: \"grips\",\r\n  PrevObjectGrip: \"grips\",\r\n  SelectedObjectGrips: \"grips\",\r\n  SelectObjectGrip: \"grips\",\r\n  SelectObjectGrips: \"grips\",\r\n  UnselectObjectGrip: \"grips\",\r\n  UnselectObjectGrips: \"grips\",\r\n\r\n  // group\r\n  AddGroup: \"group\",\r\n  AddObjectsToGroup: \"group\",\r\n  AddObjectToGroup: \"group\",\r\n  DeleteGroup: \"group\",\r\n  GroupCount: \"group\",\r\n  GroupNames: \"group\",\r\n  HideGroup: \"group\",\r\n  IsGroup: \"group\",\r\n  IsGroupEmpty: \"group\",\r\n  LockGroup: \"group\",\r\n  RemoveObjectFromAllGroups: \"group\",\r\n  RemoveObjectFromGroup: \"group\",\r\n  RemoveObjectsFromGroup: \"group\",\r\n  RenameGroup: \"group\",\r\n  ShowGroup: \"group\",\r\n  UnlockGroup: \"group\",\r\n  ObjectTopGroup: \"group\",\r\n\r\n  // hatch\r\n  AddHatch: \"hatch\",\r\n  AddHatches: \"hatch\",\r\n  AddHatchPatterns: \"hatch\",\r\n  CurrentHatchPattern: \"hatch\",\r\n  ExplodeHatch: \"hatch\",\r\n  HatchPattern: \"hatch\",\r\n  HatchPatternCount: \"hatch\",\r\n  HatchPatternDescription: \"hatch\",\r\n  HatchPatternFillType: \"hatch\",\r\n  HatchPatternNames: \"hatch\",\r\n  HatchRotation: \"hatch\",\r\n  HatchScale: \"hatch\",\r\n  IsHatch: \"hatch\",\r\n  IsHatchPattern: \"hatch\",\r\n  IsHatchPatternCurrent: \"hatch\",\r\n  IsHatchPatternReference: \"hatch\",\r\n\r\n  // layer\r\n  AddLayer: \"layer\",\r\n  CurrentLayer: \"layer\",\r\n  DeleteLayer: \"layer\",\r\n  ExpandLayer: \"layer\",\r\n  IsLayer: \"layer\",\r\n  IsLayerChangeable: \"layer\",\r\n  IsLayerChildOf: \"layer\",\r\n  IsLayerCurrent: \"layer\",\r\n  IsLayerEmpty: \"layer\",\r\n  IsLayerExpanded: \"layer\",\r\n  IsLayerLocked: \"layer\",\r\n  IsLayerOn: \"layer\",\r\n  IsLayerSelectable: \"layer\",\r\n  IsLayerParentOf: \"layer\",\r\n  IsLayerReference: \"layer\",\r\n  IsLayerVisible: \"layer\",\r\n  LayerChildCount: \"layer\",\r\n  LayerChildren: \"layer\",\r\n  LayerColor: \"layer\",\r\n  LayerCount: \"layer\",\r\n  LayerIds: \"layer\",\r\n  LayerLinetype: \"layer\",\r\n  LayerLocked: \"layer\",\r\n  LayerMaterialIndex: \"layer\",\r\n  LayerId: \"layer\",\r\n  LayerName: \"layer\",\r\n  LayerNames: \"layer\",\r\n  LayerOrder: \"layer\",\r\n  LayerPrintColor: \"layer\",\r\n  LayerPrintWidth: \"layer\",\r\n  LayerVisible: \"layer\",\r\n  ParentLayer: \"layer\",\r\n  PurgeLayer: \"layer\",\r\n  RenameLayer: \"layer\",\r\n\r\n  // light\r\n  AddDirectionalLight: \"light\",\r\n  AddLinearLight: \"light\",\r\n  AddPointLight: \"light\",\r\n  AddRectangularLight: \"light\",\r\n  AddSpotLight: \"light\",\r\n  EnableLight: \"light\",\r\n  IsDirectionalLight: \"light\",\r\n  IsLight: \"light\",\r\n  IsLightEnabled: \"light\",\r\n  IsLightReference: \"light\",\r\n  IsLinearLight: \"light\",\r\n  IsPointLight: \"light\",\r\n  IsRectangularLight: \"light\",\r\n  IsSpotLight: \"light\",\r\n  LightColor: \"light\",\r\n  LightCount: \"light\",\r\n  LightDirection: \"light\",\r\n  LightLocation: \"light\",\r\n  LightName: \"light\",\r\n  LightObjects: \"light\",\r\n  RectangularLightPlane: \"light\",\r\n  SpotLightHardness: \"light\",\r\n  SpotLightRadius: \"light\",\r\n  SpotLightShadowIntensity: \"light\",\r\n\r\n  // line\r\n  LineClosestPoint: \"line\",\r\n  LineCylinderIntersection: \"line\",\r\n  LineIsFartherThan: \"line\",\r\n  LineLineIntersection: \"line\",\r\n  LineMaxDistanceTo: \"line\",\r\n  LineMinDistanceTo: \"line\",\r\n  LinePlane: \"line\",\r\n  LinePlaneIntersection: \"line\",\r\n  LineSphereIntersection: \"line\",\r\n  LineTransform: \"line\",\r\n\r\n  // linetype\r\n  IsLinetype: \"linetype\",\r\n  IsLinetypeReference: \"linetype\",\r\n  LinetypeCount: \"linetype\",\r\n  LinetypeNames: \"linetype\",\r\n\r\n  // material\r\n  AddMaterialToLayer: \"material\",\r\n  AddMaterialToObject: \"material\",\r\n  CopyMaterial: \"material\",\r\n  IsMaterialDefault: \"material\",\r\n  IsMaterialReference: \"material\",\r\n  MatchMaterial: \"material\",\r\n  MaterialBump: \"material\",\r\n  MaterialColor: \"material\",\r\n  MaterialEnvironmentMap: \"material\",\r\n  MaterialName: \"material\",\r\n  MaterialReflectiveColor: \"material\",\r\n  MaterialShine: \"material\",\r\n  MaterialTexture: \"material\",\r\n  MaterialTransparency: \"material\",\r\n  MaterialTransparencyMap: \"material\",\r\n  ResetMaterial: \"material\",\r\n\r\n  // mesh\r\n  AddMesh: \"mesh\",\r\n  AddPlanarMesh: \"mesh\",\r\n  CurveMeshIntersection: \"mesh\",\r\n  DisjointMeshCount: \"mesh\",\r\n  DuplicateMeshBorder: \"mesh\",\r\n  ExplodeMeshes: \"mesh\",\r\n  IsMesh: \"mesh\",\r\n  IsMeshClosed: \"mesh\",\r\n  IsMeshManifold: \"mesh\",\r\n  IsPointOnMesh: \"mesh\",\r\n  JoinMeshes: \"mesh\",\r\n  MeshArea: \"mesh\",\r\n  MeshAreaCentroid: \"mesh\",\r\n  MeshBooleanDifference: \"mesh\",\r\n  MeshBooleanIntersection: \"mesh\",\r\n  MeshBooleanSplit: \"mesh\",\r\n  MeshBooleanUnion: \"mesh\",\r\n  MeshClosestPoint: \"mesh\",\r\n  MeshFaceCenters: \"mesh\",\r\n  MeshFaceCount: \"mesh\",\r\n  MeshFaceNormals: \"mesh\",\r\n  MeshFaces: \"mesh\",\r\n  MeshFaceVertices: \"mesh\",\r\n  MeshHasFaceNormals: \"mesh\",\r\n  MeshHasTextureCoordinates: \"mesh\",\r\n  MeshHasVertexColors: \"mesh\",\r\n  MeshHasVertexNormals: \"mesh\",\r\n  MeshMeshIntersection: \"mesh\",\r\n  MeshNakedEdgePoints: \"mesh\",\r\n  MeshOffset: \"mesh\",\r\n  MeshOutline: \"mesh\",\r\n  MeshQuadCount: \"mesh\",\r\n  MeshQuadsToTriangles: \"mesh\",\r\n  MeshToNurb: \"mesh\",\r\n  MeshTriangleCount: \"mesh\",\r\n  MeshVertexColors: \"mesh\",\r\n  MeshVertexCount: \"mesh\",\r\n  MeshVertexFaces: \"mesh\",\r\n  MeshVertexNormals: \"mesh\",\r\n  MeshVertices: \"mesh\",\r\n  MeshVolume: \"mesh\",\r\n  MeshVolumeCentroid: \"mesh\",\r\n  PullCurveToMesh: \"mesh\",\r\n  SplitDisjointMesh: \"mesh\",\r\n  UnifyMeshNormals: \"mesh\",\r\n\r\n  // object\r\n  CopyObject: \"object\",\r\n  CopyObjects: \"object\",\r\n  DeleteObject: \"object\",\r\n  DeleteObjects: \"object\",\r\n  FlashObject: \"object\",\r\n  HideObject: \"object\",\r\n  HideObjects: \"object\",\r\n  IsLayoutObject: \"object\",\r\n  IsObject: \"object\",\r\n  IsObjectHidden: \"object\",\r\n  IsObjectInBox: \"object\",\r\n  IsObjectInGroup: \"object\",\r\n  IsObjectLocked: \"object\",\r\n  IsObjectNormal: \"object\",\r\n  IsObjectReference: \"object\",\r\n  IsObjectSelectable: \"object\",\r\n  IsObjectSelected: \"object\",\r\n  IsObjectSolid: \"object\",\r\n  IsObjectValid: \"object\",\r\n  IsVisibleInView: \"object\",\r\n  LockObject: \"object\",\r\n  LockObjects: \"object\",\r\n  MatchObjectAttributes: \"object\",\r\n  MirrorObject: \"object\",\r\n  MirrorObjects: \"object\",\r\n  MoveObject: \"object\",\r\n  MoveObjects: \"object\",\r\n  ObjectColor: \"object\",\r\n  ObjectColorSource: \"object\",\r\n  ObjectDescription: \"object\",\r\n  ObjectGroups: \"object\",\r\n  ObjectLayer: \"object\",\r\n  ObjectLayout: \"object\",\r\n  ObjectLinetype: \"object\",\r\n  ObjectLinetypeSource: \"object\",\r\n  ObjectMaterialIndex: \"object\",\r\n  ObjectMaterialSource: \"object\",\r\n  ObjectName: \"object\",\r\n  ObjectPrintColor: \"object\",\r\n  ObjectPrintColorSource: \"object\",\r\n  ObjectPrintWidth: \"object\",\r\n  ObjectPrintWidthSource: \"object\",\r\n  ObjectType: \"object\",\r\n  OrientObject: \"object\",\r\n  RotateObject: \"object\",\r\n  RotateObjects: \"object\",\r\n  ScaleObject: \"object\",\r\n  ScaleObjects: \"object\",\r\n  SelectObject: \"object\",\r\n  SelectObjects: \"object\",\r\n  ShearObject: \"object\",\r\n  ShearObjects: \"object\",\r\n  ShowObject: \"object\",\r\n  ShowObjects: \"object\",\r\n  TransformObject: \"object\",\r\n  TransformObjects: \"object\",\r\n  UnlockObject: \"object\",\r\n  UnlockObjects: \"object\",\r\n  UnselectObject: \"object\",\r\n  UnselectObjects: \"object\",\r\n\r\n  // plane\r\n  DistanceToPlane: \"plane\",\r\n  EvaluatePlane: \"plane\",\r\n  IntersectPlanes: \"plane\",\r\n  MovePlane: \"plane\",\r\n  PlaneClosestPoint: \"plane\",\r\n  PlaneCurveIntersection: \"plane\",\r\n  PlaneEquation: \"plane\",\r\n  PlaneFitFromPoints: \"plane\",\r\n  PlaneFromFrame: \"plane\",\r\n  PlaneFromNormal: \"plane\",\r\n  PlaneFromPoints: \"plane\",\r\n  PlanePlaneIntersection: \"plane\",\r\n  PlaneSphereIntersection: \"plane\",\r\n  PlaneTransform: \"plane\",\r\n  RotatePlane: \"plane\",\r\n  WorldXYPlane: \"plane\",\r\n  WorldYZPlane: \"plane\",\r\n  WorldZXPlane: \"plane\",\r\n\r\n  // pointvector\r\n  IsVectorParallelTo: \"pointvector\",\r\n  IsVectorPerpendicularTo: \"pointvector\",\r\n  IsVectorTiny: \"pointvector\",\r\n  IsVectorZero: \"pointvector\",\r\n  PointAdd: \"pointvector\",\r\n  PointArrayClosestPoint: \"pointvector\",\r\n  PointArrayTransform: \"pointvector\",\r\n  PointClosestObject: \"pointvector\",\r\n  PointCompare: \"pointvector\",\r\n  PointDivide: \"pointvector\",\r\n  PointsAreCoplanar: \"pointvector\",\r\n  PointScale: \"pointvector\",\r\n  PointSubtract: \"pointvector\",\r\n  PointTransform: \"pointvector\",\r\n  ProjectPointToMesh: \"pointvector\",\r\n  ProjectPointToSurface: \"pointvector\",\r\n  PullPoints: \"pointvector\",\r\n  VectorAdd: \"pointvector\",\r\n  VectorAngle: \"pointvector\",\r\n  VectorCompare: \"pointvector\",\r\n  VectorCreate: \"pointvector\",\r\n  VectorCrossProduct: \"pointvector\",\r\n  VectorDivide: \"pointvector\",\r\n  VectorDotProduct: \"pointvector\",\r\n  VectorLength: \"pointvector\",\r\n  VectorMultiply: \"pointvector\",\r\n  VectorReverse: \"pointvector\",\r\n  VectorRotate: \"pointvector\",\r\n  VectorScale: \"pointvector\",\r\n  VectorSubtract: \"pointvector\",\r\n  VectorTransform: \"pointvector\",\r\n  VectorUnitize: \"pointvector\",\r\n  PointArrayBoundingBox: \"pointvector\",\r\n\r\n  // selection\r\n  AllObjects: \"selection\",\r\n  FirstObject: \"selection\",\r\n  GetCurveObject: \"selection\",\r\n  GetObject: \"selection\",\r\n  GetObjectEx: \"selection\",\r\n  GetObjects: \"selection\",\r\n  GetObjectsEx: \"selection\",\r\n  GetPointCoordinates: \"selection\",\r\n  GetSurfaceObject: \"selection\",\r\n  LockedObjects: \"selection\",\r\n  HiddenObjects: \"selection\",\r\n  InvertSelectedObjects: \"selection\",\r\n  LastCreatedObjects: \"selection\",\r\n  LastObject: \"selection\",\r\n  NextObject: \"selection\",\r\n  NormalObjects: \"selection\",\r\n  ObjectsByColor: \"selection\",\r\n  ObjectsByGroup: \"selection\",\r\n  ObjectsByLayer: \"selection\",\r\n  ObjectsByName: \"selection\",\r\n  ObjectsByType: \"selection\",\r\n  SelectedObjects: \"selection\",\r\n  UnselectAllObjects: \"selection\",\r\n  VisibleObjects: \"selection\",\r\n  WindowPick: \"selection\",\r\n\r\n  // surface\r\n  AddBox: \"surface\",\r\n  AddCone: \"surface\",\r\n  AddCutPlane: \"surface\",\r\n  AddCylinder: \"surface\",\r\n  AddEdgeSrf: \"surface\",\r\n  AddNetworkSrf: \"surface\",\r\n  AddNurbsSurface: \"surface\",\r\n  AddPatch: \"surface\",\r\n  AddPipe: \"surface\",\r\n  AddPlanarSrf: \"surface\",\r\n  AddPlaneSurface: \"surface\",\r\n  AddLoftSrf: \"surface\",\r\n  AddRevSrf: \"surface\",\r\n  AddSphere: \"surface\",\r\n  AddSrfContourCrvs: \"surface\",\r\n  AddSrfControlPtGrid: \"surface\",\r\n  AddSrfPt: \"surface\",\r\n  AddSrfPtGrid: \"surface\",\r\n  AddSweep1: \"surface\",\r\n  AddSweep2: \"surface\",\r\n  AddRailRevSrf: \"surface\",\r\n  AddTorus: \"surface\",\r\n  BooleanDifference: \"surface\",\r\n  BooleanIntersection: \"surface\",\r\n  BooleanUnion: \"surface\",\r\n  BrepClosestPoint: \"surface\",\r\n  CapPlanarHoles: \"surface\",\r\n  DuplicateEdgeCurves: \"surface\",\r\n  DuplicateSurfaceBorder: \"surface\",\r\n  EvaluateSurface: \"surface\",\r\n  ExtendSurface: \"surface\",\r\n  ExplodePolysurfaces: \"surface\",\r\n  ExtractIsoCurve: \"surface\",\r\n  ExtractSurface: \"surface\",\r\n  ExtrudeCurve: \"surface\",\r\n  ExtrudeCurvePoint: \"surface\",\r\n  ExtrudeCurveStraight: \"surface\",\r\n  ExtrudeSurface: \"surface\",\r\n  FilletSurfaces: \"surface\",\r\n  FlipSurface: \"surface\",\r\n  IntersectBreps: \"surface\",\r\n  IntersectSpheres: \"surface\",\r\n  IsBrep: \"surface\",\r\n  IsCone: \"surface\",\r\n  IsCylinder: \"surface\",\r\n  IsPlaneSurface: \"surface\",\r\n  IsPointInSurface: \"surface\",\r\n  IsPointOnSurface: \"surface\",\r\n  IsPolysurface: \"surface\",\r\n  IsPolysurfaceClosed: \"surface\",\r\n  IsSphere: \"surface\",\r\n  IsSurface: \"surface\",\r\n  IsSurfaceClosed: \"surface\",\r\n  IsSurfacePeriodic: \"surface\",\r\n  IsSurfacePlanar: \"surface\",\r\n  IsSurfaceRational: \"surface\",\r\n  IsSurfaceSingular: \"surface\",\r\n  IsSurfaceTrimmed: \"surface\",\r\n  IsTorus: \"surface\",\r\n  SurfaceSphere: \"surface\",\r\n  JoinSurfaces: \"surface\",\r\n  MakeSurfacePeriodic: \"surface\",\r\n  OffsetSurface: \"surface\",\r\n  PullCurve: \"surface\",\r\n  RebuildSurface: \"surface\",\r\n  RemoveSurfaceKnot: \"surface\",\r\n  ReverseSurface: \"surface\",\r\n  ShootRay: \"surface\",\r\n  ShortPath: \"surface\",\r\n  ShrinkTrimmedSurface: \"surface\",\r\n  SplitBrep: \"surface\",\r\n  SurfaceArea: \"surface\",\r\n  SurfaceAreaCentroid: \"surface\",\r\n  SurfaceAreaMoments: \"surface\",\r\n  SurfaceClosestPoint: \"surface\",\r\n  SurfaceCone: \"surface\",\r\n  SurfaceCurvature: \"surface\",\r\n  SurfaceCylinder: \"surface\",\r\n  SurfaceDegree: \"surface\",\r\n  SurfaceDomain: \"surface\",\r\n  SurfaceEditPoints: \"surface\",\r\n  SurfaceEvaluate: \"surface\",\r\n  SurfaceFrame: \"surface\",\r\n  SurfaceIsocurveDensity: \"surface\",\r\n  SurfaceKnotCount: \"surface\",\r\n  SurfaceKnots: \"surface\",\r\n  SurfaceNormal: \"surface\",\r\n  SurfaceNormalizedParameter: \"surface\",\r\n  SurfaceParameter: \"surface\",\r\n  SurfacePointCount: \"surface\",\r\n  SurfacePoints: \"surface\",\r\n  SurfaceTorus: \"surface\",\r\n  SurfaceVolume: \"surface\",\r\n  SurfaceVolumeCentroid: \"surface\",\r\n  SurfaceVolumeMoments: \"surface\",\r\n  SurfaceWeights: \"surface\",\r\n  TrimBrep: \"surface\",\r\n  TrimSurface: \"surface\",\r\n  UnrollSurface: \"surface\",\r\n  ChangeSurfaceDegree: \"surface\",\r\n\r\n  // toolbar\r\n  CloseToolbarCollection: \"toolbar\",\r\n  HideToolbar: \"toolbar\",\r\n  IsToolbar: \"toolbar\",\r\n  IsToolbarCollection: \"toolbar\",\r\n  IsToolbarDocked: \"toolbar\",\r\n  IsToolbarVisible: \"toolbar\",\r\n  OpenToolbarCollection: \"toolbar\",\r\n  SaveToolbarCollection: \"toolbar\",\r\n  SaveToolbarCollectionAs: \"toolbar\",\r\n  ShowToolbar: \"toolbar\",\r\n  ToolbarCollectionCount: \"toolbar\",\r\n  ToolbarCollectionNames: \"toolbar\",\r\n  ToolbarCollectionPath: \"toolbar\",\r\n  ToolbarCount: \"toolbar\",\r\n  ToolbarNames: \"toolbar\",\r\n\r\n  // transformation\r\n  IsXformIdentity: \"transformation\",\r\n  IsXformSimilarity: \"transformation\",\r\n  IsXformZero: \"transformation\",\r\n  XformChangeBasis: \"transformation\",\r\n  XformChangeBasis2: \"transformation\",\r\n  XformCompare: \"transformation\",\r\n  XformCPlaneToWorld: \"transformation\",\r\n  XformDeterminant: \"transformation\",\r\n  XformDiagonal: \"transformation\",\r\n  XformIdentity: \"transformation\",\r\n  XformInverse: \"transformation\",\r\n  XformMirror: \"transformation\",\r\n  XformMultiply: \"transformation\",\r\n  XformPlanarProjection: \"transformation\",\r\n  XformRotation1: \"transformation\",\r\n  XformRotation2: \"transformation\",\r\n  XformRotation3: \"transformation\",\r\n  XformRotation4: \"transformation\",\r\n  XformScale: \"transformation\",\r\n  XformScreenToWorld: \"transformation\",\r\n  XformShear: \"transformation\",\r\n  XformTranslation: \"transformation\",\r\n  XformWorldToCPlane: \"transformation\",\r\n  XformWorldToScreen: \"transformation\",\r\n  XformZero: \"transformation\",\r\n\r\n  // userdata\r\n  DeleteDocumentData: \"userdata\",\r\n  DocumentDataCount: \"userdata\",\r\n  DocumentUserTextCount: \"userdata\",\r\n  GetDocumentData: \"userdata\",\r\n  GetDocumentUserText: \"userdata\",\r\n  GetUserText: \"userdata\",\r\n  IsDocumentData: \"userdata\",\r\n  IsDocumentUserText: \"userdata\",\r\n  IsUserText: \"userdata\",\r\n  SetDocumentData: \"userdata\",\r\n  SetDocumentUserText: \"userdata\",\r\n  SetUserText: \"userdata\",\r\n\r\n  // userinterface\r\n  BrowseForFolder: \"userinterface\",\r\n  CheckListBox: \"userinterface\",\r\n  ComboListBox: \"userinterface\",\r\n  EditBox: \"userinterface\",\r\n  GetAngle: \"userinterface\",\r\n  GetBoolean: \"userinterface\",\r\n  GetBox: \"userinterface\",\r\n  GetColor: \"userinterface\",\r\n  GetCursorPos: \"userinterface\",\r\n  GetDistance: \"userinterface\",\r\n  GetEdgeCurves: \"userinterface\",\r\n  GetInteger: \"userinterface\",\r\n  GetLayer: \"userinterface\",\r\n  GetLayers: \"userinterface\",\r\n  GetLine: \"userinterface\",\r\n  GetLinetype: \"userinterface\",\r\n  GetMeshFaces: \"userinterface\",\r\n  GetMeshVertices: \"userinterface\",\r\n  GetPoint: \"userinterface\",\r\n  GetPointOnCurve: \"userinterface\",\r\n  GetPointOnMesh: \"userinterface\",\r\n  GetPointOnSurface: \"userinterface\",\r\n  GetPoints: \"userinterface\",\r\n  GetPolyline: \"userinterface\",\r\n  GetReal: \"userinterface\",\r\n  GetRectangle: \"userinterface\",\r\n  GetString: \"userinterface\",\r\n  ListBox: \"userinterface\",\r\n  MessageBox: \"userinterface\",\r\n  PropertyListBox: \"userinterface\",\r\n  MultiListBox: \"userinterface\",\r\n  OpenFileName: \"userinterface\",\r\n  OpenFileNames: \"userinterface\",\r\n  PopupMenu: \"userinterface\",\r\n  RealBox: \"userinterface\",\r\n  SaveFileName: \"userinterface\",\r\n  StringBox: \"userinterface\",\r\n  TextOut: \"userinterface\",\r\n\r\n  // utility\r\n  ContextIsRhino: \"utility\",\r\n  ContextIsGrasshopper: \"utility\",\r\n  Angle: \"utility\",\r\n  Angle2: \"utility\",\r\n  ClipboardText: \"utility\",\r\n  ColorAdjustLuma: \"utility\",\r\n  ColorBlueValue: \"utility\",\r\n  ColorGreenValue: \"utility\",\r\n  ColorHLSToRGB: \"utility\",\r\n  ColorRedValue: \"utility\",\r\n  ColorRGBToHLS: \"utility\",\r\n  CullDuplicateNumbers: \"utility\",\r\n  CullDuplicatePoints: \"utility\",\r\n  Distance: \"utility\",\r\n  GetSettings: \"utility\",\r\n  Polar: \"utility\",\r\n  SimplifyArray: \"utility\",\r\n  Sleep: \"utility\",\r\n  SortPointList: \"utility\",\r\n  SortPoints: \"utility\",\r\n  Str2Pt: \"utility\",\r\n  CreatePoint: \"utility\",\r\n  CreateVector: \"utility\",\r\n  CreatePlane: \"utility\",\r\n  CreateXform: \"utility\",\r\n  CreateColor: \"utility\",\r\n  CreateInterval: \"utility\",\r\n\r\n  // view\r\n  AddDetail: \"view\",\r\n  AddLayout: \"view\",\r\n  AddNamedCPlane: \"view\",\r\n  AddNamedView: \"view\",\r\n  CurrentDetail: \"view\",\r\n  CurrentView: \"view\",\r\n  DeleteNamedCPlane: \"view\",\r\n  DeleteNamedView: \"view\",\r\n  DetailLock: \"view\",\r\n  DetailScale: \"view\",\r\n  IsDetail: \"view\",\r\n  IsLayout: \"view\",\r\n  IsView: \"view\",\r\n  IsViewCurrent: \"view\",\r\n  IsViewMaximized: \"view\",\r\n  IsViewPerspective: \"view\",\r\n  IsViewTitleVisible: \"view\",\r\n  IsWallpaper: \"view\",\r\n  MaximizeRestoreView: \"view\",\r\n  NamedCPlane: \"view\",\r\n  NamedCPlanes: \"view\",\r\n  NamedViews: \"view\",\r\n  RenameView: \"view\",\r\n  RestoreNamedCPlane: \"view\",\r\n  RestoreNamedView: \"view\",\r\n  RotateCamera: \"view\",\r\n  RotateView: \"view\",\r\n  ShowGrid: \"view\",\r\n  ShowGridAxes: \"view\",\r\n  ShowViewTitle: \"view\",\r\n  ShowWorldAxes: \"view\",\r\n  TiltView: \"view\",\r\n  ViewCamera: \"view\",\r\n  ViewCameraLens: \"view\",\r\n  ViewCameraPlane: \"view\",\r\n  ViewCameraTarget: \"view\",\r\n  ViewCameraUp: \"view\",\r\n  ViewCPlane: \"view\",\r\n  ViewDisplayMode: \"view\",\r\n  ViewDisplayModeId: \"view\",\r\n  ViewDisplayModeName: \"view\",\r\n  ViewDisplayModes: \"view\",\r\n  ViewNames: \"view\",\r\n  ViewNearCorners: \"view\",\r\n  ViewProjection: \"view\",\r\n  ViewRadius: \"view\",\r\n  ViewSize: \"view\",\r\n  ViewSpeedTest: \"view\",\r\n  ViewTarget: \"view\",\r\n  ViewTitle: \"view\",\r\n  Wallpaper: \"view\",\r\n  WallpaperGrayScale: \"view\",\r\n  WallpaperHidden: \"view\",\r\n  ZoomBoundingBox: \"view\",\r\n  ZoomExtents: \"view\",\r\n  ZoomSelected: \"view\",\r\n};\r\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n"],
  "mappings": "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ACA,qCACA,qCACA,aACA,mBACA,MACA,MACA,OACA,OACA,QACA,WACA,mBACA,iBACA,UACA,KACA,WACA,QACA,YACA,MACA,aACA,KACA,YACA,UACA,UACA,cACA,UACA,wBACA,iBACAC,SACA,MACA,WACA,eACA,aACA,IACA,KACA,MACA,KACA,MACA,iBACA,qBACA,cACA,SACA,oBACA,gBACA,QACA,eACA,iBACA,sBACA,QACA,OACA,QACA,OACA,kBACA,kBACA,OACA,QACA,SACA,UACA,QACA,YACA,gBACA,YACA,WACAC,SACA,SACA,MACA,UACA,SACA,SACA,SACA,QACA,WACA,QACA,SACA,SACA,QACA,WACA,QACA,YACA,YACA,SACA,cACA,UACA,eACA,WACA,eACA,iBACA,mBACA,oBACA,OACA,kBACA,WACA,4BACA,2BACA,eACA,aACA,cACA,iBACA,UACA,OACA,gBAEI,UA8GC;AAnOP,IAAAC,gBAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC;AAAA;AACA;AACA,IAAM,gBAAgB,WAAW,SAAS;AACnC,IAAM,mBAAmB,cAAc;AACvC,KAAM,EAAE,MAAM,UAAU,aAAa;AAAA,MAC1C;AAAA,IACF;AACA,IAAM,eAAe,IAAI,QAAa;AAAA,MACpC,KAAK,cAAc;AAAA,MACnB;AAAA,MACA;AAAA,IACF,CAAC;AACM,KAAM;AAAA,MACX;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAH;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACE;AACJ,IAAM,WAAW;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAAD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAA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",
  "names": ["name", "init_performance", "performance", "init_performance", "name", "PerformanceMark", "_options", "init_performance", "init_performance", "performance", "init_performance", "init_performance", "clear", "count", "countReset", "createTask", "debug", "dir", "dirxml", "error", "group", "groupCollapsed", "groupEnd", "info", "log", "profile", "profileEnd", "table", "time", "timeEnd", "timeLog", "timeStamp", "trace", "warn", "init_console", "init_performance", "init_console", "init_performance", "hrtime", "init_performance", "dir", "env", "count", "init_performance", "init_performance", "init_performance", "cwd", "hrtime", "assert", "init_process", "init_performance", "init_process", "init_performance", "_a", "name", "UsedValueState", "_a", "name", "error", "_a", "mergeValues", "Type", "error", "group", "_a", "DataType", "context", "_a", "init_performance", "init_performance", "count", "group", "env", "_a", "init_performance", "init_performance", "init_performance", "init_performance", "_a", "Ajv", "group", "name", "text", "log", "env", "_a", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "error", "count", "error", "error", "error", "error", "error", "DiscrError", "error", "_a", "Ajv", "init_performance", "text", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "_a", "__privateAdd", "__privateGet", "__privateMethod", "__privateSet", "init_performance", "init_performance", "util", "object", "objectUtil", "error", "errorUtil", "error", "errorMap", "_a", "version", "ctx", "result", "issues", "elements", "processed", "r", "_b", "ZodFirstPartyTypeKind", "ErrorCode", "init_performance", "init_performance", "crypto", "init_performance", "codeVerifier", "tokens", "error", "_a", "error", "_a", "text", "init_performance", "init_performance", "_options", "info", "error", "_a", "_b", "_a", "error", "validator", "isValid", "_a", "_AISDKError", "name", "error", "marker", "symbol", "_a", "symbol", "name", "marker", "_a", "symbol", "error", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "text", "error", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_TypeValidationError", "error", "_a", "symbol", "init_performance", "error", "zodSchema", "validator", "error", "text", "SecureJSON", "error", "btoa", "atob", "init_performance", "init_performance", "init_performance", "_options", "name", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "emojiRegex", "init_performance", "object", "init_performance", "init_performance", "init_performance", "init_performance", "types", "x", "base", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "init_performance", "jsonSchema", "init_performance", "init_performance", "name", "schema", "title", "textStreamPart", "errorStreamPart", "validCodes", "NEWLINE", "zodSchema", "_a", "jsonSchema", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "symbol", "_a", "AISDKError", "text", "error", "_a", "symbol", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "symbol", "_a", "_a", "symbol", "z", "originalGenerateId", "createIdGenerator", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "name", "marker", "_a", "symbol", "originalGenerateId", "createIdGenerator", "name", "marker", "symbol", "_a", "_a", "symbol", "name", "marker", "_a", "symbol", "text", "asSchema", "parsePartialJson", "context", "safeParseJSON", "safeValidateTypes", "error", "result", "originalGenerateId", "createIdGenerator", "originalGenerateMessageId", "name", "marker", "symbol", "_a", "_a", "symbol", "z", "ResultSchema", "RequestSchema", "ServerCapabilitiesSchema", "InitializeResultSchema", "PaginatedResultSchema", "ToolSchema", "ListToolsResultSchema", "TextContentSchema", "ImageContentSchema", "ResourceContentsSchema", "TextResourceContentsSchema", "BlobResourceContentsSchema", "EmbeddedResourceSchema", "CallToolResultSchema", "JSONRPC_VERSION", "JSONRPCRequestSchema", "JSONRPCResponseSchema", "JSONRPCErrorSchema", "JSONRPCNotificationSchema", "JSONRPCMessageSchema", "_a", "formatDataStreamPart", "mergeIntoDataStream", "toDataStream", "toDataStreamResponse", "toDataStreamInternal", "text", "init_performance", "init_performance", "info", "name", "version", "url", "env", "error", "e", "name", "context", "init_performance", "init_performance", "init_performance", "name", "dir", "_a", "_a", "init_performance", "env", "_onMessage", "ctx", "error", "time", "url", "DurableObject", "error", "_started", "_McpAgent", "DurableObject", "env", "_a", "binding", "event", "body", "init_performance", "init_performance", "Server", "_a", "init_performance", "McpZodTypeKind", "processCreateParams", "processCreateParams", "errorMap", "_a", "init_performance", "Server", "name", "error", "config", "name", "init_performance", "init_performance", "printedOutput", "error", "env", "init_performance", "env", "init_performance", "env", "error", "init_performance", "env", "env"]
}
